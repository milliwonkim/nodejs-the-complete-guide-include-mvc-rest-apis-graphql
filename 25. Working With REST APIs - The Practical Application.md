\* Chapter 365: Module Introduction
===================================

![](images/365-module-introduction-1.png)![365-module-introduction-1.png](resources/18B964F9F98E39CEF2D3F7DC9F256F90.png)

\* Chapter 366: REST APIs & The Rest Of The Course
==================================================

![](images/366-rest-apis-and-the-rest-of-the-course-1.png)![366-rest-apis-and-the-rest-of-the-course-1.png](resources/CC8F57266D02AC63097B8C1BFAE7E3B3.png)

- for Sessions and Cookies, we have changes because we will not use sessions and cookies anymore with REST API. the reason for that is you learned these RESTful principle or these REST API principles and one of them was that each request is treated separately, it is looked at independently from previous requests, so we have no connection between the client and server, we have no shared connection history to be precise and therefore we manage no sessions on the server because REST API doesn’t care about the clients or whether that client connected to the API before. therefore Authentication will also have to change.

\* Chapter 367: Understanding The Frontend Setup
================================================

![](images/367-understanding-the-frontend-setup-1.png) ![367-understanding-the-frontend-setup-1.png](resources/43227BCF4E64261C9DF67A4DF7A2E1DF.png)

- you will start with attached project in Udemy. folder name is '01-frontend-fetching-list-of-posts' so ’npm install’ to install node\_modules. 

![](images/367-understanding-the-frontend-setup-2.png)![367-understanding-the-frontend-setup-2.png](resources/5F69859A1C1C457859010640658AE74A.png)

- once you ran all of that, you can run ’npm start’ to start a development server which is now actually a node.js server. but it’s not related to the node server we will build. it’s not related to our backend. this is only a dummy development server which serves the build version of our frontend application. so it serves a simple HTML file in public folder. 

![](images/367-understanding-the-frontend-setup-3.png)

![](images/367-understanding-the-frontend-setup-4.png) ![367-understanding-the-frontend-setup-3.png](resources/CAB999CE02BDC9E7924EDF932C21290D.png)![367-understanding-the-frontend-setup-4.png](resources/E7DECB28D381F7A8DA659A07BBB80EC4.png)

- this interface is fully rendered through React.js. 

- right now nothing is working because i got no backend attached. this is also the reason why we have an error message right at the start but we will get rid of that throughout this moudule. 

- this is the frontend and this is now the frontend i wanna connect to my backend. 

\* Chapter 368: Planning The API
================================

![](images/368-planning-the-api-1.png)![368-planning-the-api-1.png](resources/E134DFFA89839F8F15C521B69FFC8694.png)

- the app.js file is our entry file where our react application starts or where it starts rendering the first screens. 

\* Chapter 369: Fetching Lists Of Posts
=======================================

\* backend = (b)

\* frontend = (f)

1\. update

- ./controllers/feed.js(b)

- ./images/duck.jpg

- ./src/pages/Feed/Feed.js(f)

![](images/369-fetching-lists-of-posts-1.png)![369-fetching-lists-of-posts-1.png](resources/90918C3B89EFB2F835879ACC632D73C0.png)

- i’m using different ports. i’m starting the application server on port 8080, my frontend application automatically takes port 3000 and this simulates that these 2 ends of my application are served by different servers whichi is common scenario since frontend only applications like React can be served on so-called static hosts which are optimized for application that only consist of HTML, javascript, CSS. and hence you might have 2 different servers even if you created both the backend and frontend. 

![](images/369-fetching-lists-of-posts-2.png)![369-fetching-lists-of-posts-2.png](resources/9039A93ADD6C35FCE9CC1DAD7954B4D5.png)

- we have different ports and therefore we have different domains and therefore we need our course headers otherwise nothing would work. 

![](images/369-fetching-lists-of-posts-3.png)

![](images/369-fetching-lists-of-posts-4.png)![369-fetching-lists-of-posts-3.png](resources/A176D314263D0F46A6E53A8CF01F7328.png)![369-fetching-lists-of-posts-4.png](resources/759D8F203C59EEDD95376698BAAEEF50.png)

```js
//./controllers/feed.js(b)

exports.getPosts = (req, res, next) => {
  res.status(200).json({
  posts: [
    {
      _id: '1',
      title: 'First Post',
      content: 'This is the first post!',
      imageUrl: 'images/duck.jpg',
      creator: {
        name: 'Maximilian'
      },
      createdAt: new Date()
    }
  ]
});
};

exports.createPost = (req, res, next) => {
const title = req.body.title;
const content = req.body.content;
console.log(title, content);
  //Create post in db
  res.status(201).json({
  message: 'Post created successfully!',
  post: { id: new Date().toISOString(), title: title, content: content }
});
};
```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    /**this route i just talked about in the REST API
     * this should fetch all these posts. 
     */
    fetch('http://localhost:8080/feed/posts')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts,
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    // Set up data (with image!)
    let url = 'URL';
    if (this.state.editPost) {
      url = 'URL';
    }

    fetch(url)
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

//images/duck.jpg

![pexels-photo-2227826.jpg](resources/FFF55F4A65731052DA50FE463E8A37F5.jpg)

\* Chapter 370: Adding A Create Post Endpoint
=============================================

1\. update

- ./src/pages/Feed/Feed.js(f)

- ./controllers/feed.js(b)

![](images/370-adding-a-create-post-endpoint-1.png)

![](images/370-adding-a-create-post-endpoint-2.png)![370-adding-a-create-post-endpoint-1.png](resources/C986143EE2515E825DD79579DD001AD3.png)![370-adding-a-create-post-endpoint-2.png](resources/B21E5126E1B248931456C0BEA5CFD451.png)

- 2 things are missing. server-side validation. we only got client-side validation but that can always be tricked because users can see your browser side javascript code. they could basically find ways around that. so it’s not safe mechanism.

```js
//./controllers/feed.js(b)

exports.getPosts = (req, res, next) => {
  res.status(200).json({
  posts: [
    {
      _id: '1',
      title: 'First Post',
      content: 'This is the first post!',
      imageUrl: 'images/duck.jpg',
      creator: {
        name: 'Maximilian'
      },
      createdAt: new Date()
    }
  ]
});
};

exports.createPost = (req, res, next) => {
const title = req.body.title;
const content = req.body.content;
console.log(title, content);
  //Create post in db
  res.status(201).json({
  message: 'Post created successfully!',
  post: {
    _id: new Date().toISOString(),
    title: title,
    content: content,
    creator: { name: 'Maximilian' },
    createdAt: new Date()
  }
});
};
```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    /**this route i just talked about in the REST API
     * this should fetch all these posts. 
     */
    fetch('http://localhost:8080/feed/posts')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts,
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    // Set up data (with image!)
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST'
    if (this.state.editPost) {
      url = 'URL';
    }

    fetch(url, {
      method: method,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        title: postData.title,
        content: postData.content
      })
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData)
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

\* Chapter 371: Adding Server Side Validation
=============================================

1\. update

- ./routes/feed.js(b)

- ./controllers/feed.js(b)

![](images/371-adding-server-side-validation-1.png)![371-adding-server-side-validation-1.png](resources/87117F70C77A0A7A9E64FA7A93022B15.png)

- ’npm install —save express-validator’ is the package that helps us with implementing validation into our node express applications. 

![](images/371-adding-server-side-validation-2.png)![371-adding-server-side-validation-2.png](resources/E2BF9B8D72617A80F356BB2571CED526.png)

- in the ./src/components/Feed/FeedEdit/FeedEdit.js(f) file, i’m validating this to have minimum length of 5 characters and to be non-empty which is the case if it is at least 5 characters long. that’s a little side note on what i’m doing on the frontend.

![](images/371-adding-server-side-validation-3.png)![371-adding-server-side-validation-3.png](resources/8C5E7B55593E7123296167AA1686198F.png)

- and the backend should meed that same pattern

![](images/371-adding-server-side-validation-4.png)

![](images/371-adding-server-side-validation-5.png)![371-adding-server-side-validation-4.png](resources/E27CB7F5FF9A878A19B6346FB4F96F13.png)![371-adding-server-side-validation-5.png](resources/A5270AD0C865C4DD743EE9D9A3766B65.png)

- if we increate the title minimum length to 7 on the server, if i go back to the frontend and i enter a title which is only 5 characters long and therefore long enough for the client side validation but too short for the server side validation which is mismatch you don’t wanna have in a real app but it’s great for testing. 

![](images/371-adding-server-side-validation-6.png)

![](images/371-adding-server-side-validation-7.png)

![](images/371-adding-server-side-validation-8.png)

![](images/371-adding-server-side-validation-9.png)![371-adding-server-side-validation-6.png](resources/8AB70D54BBDAFFF0FCC306E88312A585.png)![371-adding-server-side-validation-7.png](resources/25770FBE9A09A4065D6BEA49F3F65616.png)![371-adding-server-side-validation-8.png](resources/286A276F1E3221D089BF8686DDDD0D1D.png)![371-adding-server-side-validation-9.png](resources/A2598D692C45492F99B419A383BDE26C.png)

- that is the error message i’m showing on the frontend.

- but if you have a look at our console.log in the dev tools, we see a 422 error here and if we click on that we are taken to the network tab, we see that red request and if we inspect that, we see our response and that has that message we sent on the server side 'validation failed and so on’ and it has this errors array wherer we see that the title failed. so you see that the server side validation is working

```js
//./controllers/feed.js(b)

const { validationResult } = require('express-validator/check')

exports.getPosts = (req, res, next) => {
  res.status(200).json({
  posts: [
    {
      _id: '1',
      title: 'First Post',
      content: 'This is the first post!',
      imageUrl: 'images/duck.jpg',
      creator: {
        name: 'Maximilian'
      },
      createdAt: new Date()
    }
  ]
});
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if(!errors.isEmpty()){
    return res.status(422).json({
      message: 'Validation Failed, Entered data is incorrect.',
      errors: errors.array()
    })
  }
  const title = req.body.title;
  const content = req.body.content;
  console.log(title, content);
    //Create post in db
    res.status(201).json({
    message: 'Post created successfully!',
    post: {
      _id: new Date().toISOString(),
      title: title,
      content: content,
      creator: { name: 'Maximilian' },
      createdAt: new Date()
    }
  });
};
```

```js
//./routes/feed.js(b)

const express = require('express');
/**'check' is the sub-package
 * and that something is 'check' method to check the headers, the query parameters and so on.
 * or the 'body' method to check the request body
 */
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');

const router = express.Router();

// GET /feed/posts
router.get('/posts', feedController.getPosts);

// POST /feed/post
router.post('/post', [
    body('title').trim().isLength({min: 5}),
    body('content').trim().isLength({min: 5})
], feedController.createPost);

module.exports = router;
```

\* Chapter 372: Setting Up A Post Model
=======================================

1\. update

- app.js(b)

- ./models/post.js(b)

![](images/372-setting-up-a-post-model-1.png)

![](images/372-setting-up-a-post-model-2.png)![372-setting-up-a-post-model-1.png](resources/DBBB0627A32FA4874BBF4626E6DC6621.png)![372-setting-up-a-post-model-2.png](resources/F5927B1833E4ACC8CB8A4866B6EDF4F4.png)

```js
//app.js(b)

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');


const feedRoutes = require('./routes/feed')

const app = express();

app.use(bodyParser.json())

app.use((req, res, next) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    next()
})

app.use('/feed', feedRoutes)

/**connecting with MongoDB Atlas */
mongoose
    .connect(
        'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/message?retryWrites=true'
        )
    .then(result => {
        app.listen(8080);
    })
    .catch(err => console.log(err));
```

```js
//./models/post.js(b)

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const postSchema = new Schema({
    title: {
        type: String
    },
    imageUrl: {
        type: String,
        required: true
    },
    content: {
        type: String,
        required: true
    },
    creator: {
        type: Object,
        required: String
    }
/**we can pass an option to the schema constructor
 * which we haven't seen before,
 * we can configure this
 * and in that object, i'm passing as a 2nd argument to the schema constructor,
 * i can add the 'timestamps' key
 * and set this to true
 * and mongoose will then automatically add timestamps
 * when a new version is added to the database,
 * when a new object is added to the database.
 */
    },
    { timestamps: true }
);

/**we don't export the schema but a model-based on the schema 
 * i will name it 'Post'
 * and therefore this will create a Post database
 * and i will export my postSchema here.
*/
module.exports = mongoose.model('Post', postSchema)
```

\* Chapter 373: Storing Posts In The Database
=============================================

1\. update

- ./controllers/feed.js(b)

![](images/373-storing-posts-in-the-database-1.png)

![](images/373-storing-posts-in-the-database-2.png)

![](images/373-storing-posts-in-the-database-3.png)![373-storing-posts-in-the-database-1.png](resources/009730D8EA9676353A890667E183E450.png)![373-storing-posts-in-the-database-2.png](resources/C34C322180935C1B0857F473AA8B639A.png)![373-storing-posts-in-the-database-3.png](resources/7B793408C8458513DD309D97C93C6B6D.png)

```js
//./controllers/feed.js(b)

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  res.status(200).json({
    posts: [
      {
        _id: '1',
        title: 'First Post',
        content: 'This is the first post!',
        imageUrl: 'images/duck.jpg',
        creator: {
          name: 'Maximilian'
        },
        createdAt: new Date()
      }
    ]
  });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(422).json({
      message: 'Validation failed, entered data is incorrect.',
      errors: errors.array()
    });
  }
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    /**i don't need to set createdAt
     * because mongoose will do that for me
     * thanks to that timestamps option in ./models/post.js file
     * 
     * i don't need to set _id
     * because mongoose will create that for me as well
     */
    title: title,
    content: content,
    imageUrl: 'images/duck.jpg',
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      console.log(err);
    });
};

```

\* Chapter 374: Static Images & Error Handling
==============================================

1\. update

- app.js(b)

- ./controllers/feed.js

- ./routes/feed.js

![](images/374-static-images-and-error-handling-1.png)

![](images/374-static-images-and-error-handling-2.png)

![](images/374-static-images-and-error-handling-3.png)

![](images/374-static-images-and-error-handling-4.png)![374-static-images-and-error-handling-1.png](resources/A4EFEEC99937868B279679F6650C47BA.png)![374-static-images-and-error-handling-2.png](resources/F4222A25B9EF448122C6C745FD2D7124.png)![374-static-images-and-error-handling-3.png](resources/2CEE2E8638FFCF1F6CC2BF2019B109CF.png)![374-static-images-and-error-handling-4.png](resources/62FA8B4C3DFA0A4BBAB351C1F51662A1.png)

- if i fill in title which is not long enough, we still get that error being thrown with the right status code. 422.

```js
//app.js(b)

const path = require('path')

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');


const feedRoutes = require('./routes/feed')

const app = express();


app.use(bodyParser.json()) //application/json
/**i will use a middleware built into express,
 * the static middleware which i use by calling the static function
 * 
 * let's import the 'path' package,
 * the core path package node provides
 * andn then we can use 'path.join' to construct an absolute path to that images folder
 * '__dirname' is available globally in node.js
 * which gives us access to the directory path to that file, to the app.js file
 * and in that same location as this app.js file,
 * we find the images folder.
 * 
 */
app.use('/images', express.static(path.join(__dirname, 'images')))

app.use((req, res, next) => {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, PUT, PATCH, DELETE');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')
    next()
})

app.use('/feed', feedRoutes);

/**this will be executed whenever an error is thrown or forwarded with next*/
app.use((error, req, res, next) => {
    console.log(error);
    const status = error.statusCode || 500;
    const message = error.message;
    res.status(status).json({message: message})
})

mongoose
    .connect(
        'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/message?retryWrites=true'
        )
    .then(result => {
        app.listen(8080);
    })
    .catch(err => console.log(err));
```

```js
//./controllers/feed.js(b)

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  res.status(200).json({
    posts: [
      {
        _id: '1',
        title: 'First Post',
        content: 'This is the first post!',
        imageUrl: 'images/duck.jpg',
        creator: {
          name: 'Maximilian'
        },
        createdAt: new Date()
      }
    ]
  });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    /**what does throwing an error do here?
     * since i'm not doing this in an asynchronous code snippet or anything like that,
     * it will automatically exit the function execution here
     * and instead try to reach the next error handling function or error handling middleware
     * provided in the express application
     */
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: 'images/duck.jpg',
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      /**we also got another possible error
       * and that is in here
       * if something goes wrong with storing the post,
       * i don't wanna log the error
       * instead i will check if my error has a status code field
       * which it will not have 
       * but theoretically if i had more complex code
       * where i throw my own errors,
       * there might be some error that has it
       */
        if(err.statusCode){
          err.statusCode = 500;
        }
        /**since i'm inside of promise chain,
         * so inside of an async code snippet,
         * throwing an error will not do the trick.
         * this will not reach the next error handling middleware
         * this will now go and reach the next error handling express middleware
         * 
          */
        next(err)
    });
};

```

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');

const router = express.Router();

// GET /feed/posts
router.get('/posts', feedController.getPosts);

// POST /feed/post
router.post('/post', [
    body('title').trim().isLength({min: 7}),
    body('content').trim().isLength({min: 5})
], feedController.createPost);

module.exports = router;
```

\* Chapter 375: Fetching A Single Post
======================================

1\. update

- ./routes/feed.js(b)

- ./controllers/feed.js(b)

- ./src/pages/Feed/SinglePost/SinglePost.js(f)

![](images/375-fetching-a-single-post-1.png)

![](images/375-fetching-a-single-post-2.png)

![](images/375-fetching-a-single-post-3.png)

![](images/375-fetching-a-single-post-4.png)![375-fetching-a-single-post-1.png](resources/59C3157DF170F02C427E0DB890D17EB0.png)![375-fetching-a-single-post-2.png](resources/689D11E0D3A98AA5B1DD21DE0D4BEF48.png)![375-fetching-a-single-post-3.png](resources/A45AA8602C76F29AA00984088980F877.png)![375-fetching-a-single-post-4.png](resources/1D107AF706B4706A7CA74AF96916F7DA.png)

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');

const router = express.Router();

// GET /feed/posts
router.get('/posts', feedController.getPosts);

// POST /feed/post
router.post(
  '/post',
  [
    body('title')
      .trim()
      .isLength({ min: 7 }),
    body('content')
      .trim()
      .isLength({ min: 5 })
  ],
  feedController.createPost
);

router.get('/post/:postId', feedController.getPost);

module.exports = router;

```

```js
//./controllers/feed.js(b)

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  Post.find()
    .then(posts => {
      res
        .status(200)
        .json({ message: 'Fetched posts successfully.', posts: posts });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: 'images/duck.jpg',
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
  /**this can be confusing
   * because i'm inside of '.then()' block
   * and you learned that
   * you should use '.next()' in there
   * but if you throw an error inside of '.then()' block,
   * the next '.catch()' block will be reached
   * and that error will be passed as an error to the catch block.
   */
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

```

```js
//./src/pages/Feed/SinglePost/SinglePost.js

import React, { Component } from 'react';

import Image from '../../../components/Image/Image';
import './SinglePost.css';

class SinglePost extends Component {
  state = {
    title: '',
    author: '',
    date: '',
    image: '',
    content: ''
  };

  componentDidMount() {
    const postId = this.props.match.params.postId;
    fetch('http://localhost:8080/feed/post/' + postId)
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch status');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          title: resData.post.title,
          author: resData.post.creator.name,
          image: 'http://localhost:8080/' + resData.post.imageUrl,
          date: new Date(resData.post.createdAt).toLocaleDateString('en-US'),
          content: resData.post.content
        });
      })
      .catch(err => {
        console.log(err);
      });
  }

  render() {
    return (
      <section className="single-post">
        <h1>{this.state.title}</h1>
        <h2>
          Created by {this.state.author} on {this.state.date}
        </h2>
        <div className="single-post__image">
          <Image contain imageUrl={this.state.image} />
        </div>
        <p>{this.state.content}</p>
      </section>
    );
  }
}

export default SinglePost;

```

\* Chapter 377: Uploading Images
================================

1\. update

- app.js(b)

- ./controllers/feed.js(b)

- ./src/pages/Feed/Feed.js(f)

![](images/377-uploading-images-1.png)

![](images/377-uploading-images-2.png)

![](images/377-uploading-images-3.png)

![](images/377-uploading-images-4.png)

![](images/377-uploading-images-5.png)

![](images/377-uploading-images-6.png)![377-uploading-images-1.png](resources/E54A2A749BCBFCA533151E14DDD8B511.png)![377-uploading-images-2.png](resources/9D0208D9C78DB828334EE31883BB8786.png)![377-uploading-images-3.png](resources/D9F0910259BE36701FB9A3CC02F34EDA.png)![377-uploading-images-4.png](resources/82E794ED936DE44A80DBE64F5F330405.png)![377-uploading-images-5.png](resources/F4AB5D4FF45D2A739484D0DB89C31CF4.png)![377-uploading-images-6.png](resources/AC175732DC0A5EA897D6091C96A9AC85.png)

```js
//app.js(b)

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const multer = require('multer');

const feedRoutes = require('./routes/feed');

const app = express();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    /**got no error so 'null'
     * and the destination is images pointing at 'images' folder here.
     */
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if(
    file.mimetype === 'image/png' || 
    file.mimetype === 'image/jpg' || 
    file.mimetype === 'image/jpeg'
    ) {
      cb(null, true);
    } else {
      cb(null, false);
    }
}

// app.use(bodyParser.urlencoded()); // x-www-form-urlencoded <form>
app.use(bodyParser.json()); // application/json
/**on that multer function,
 * i will then call single image to inform multer
 * that i will extract a single file stored in some field named 'image' in the incoming requests.
 * every incoming request is parsed for that file or such files
 * with that, multer is registered,
 * now we can use the file in our controller
 * where we create a new Post. 
 */
app.use(multer({storage: fileStorage, fileFilter: fileFilter}).single('image'))
app.use('/images', express.static(path.join(__dirname, 'images')));

app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader(
    'Access-Control-Allow-Methods',
    'OPTIONS, GET, POST, PUT, PATCH, DELETE'
  );
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

app.use('/feed', feedRoutes);

app.use((error, req, res, next) => {
  console.log(error);
  const status = error.statusCode || 500;
  const message = error.message;
  res.status(status).json({ message: message });
});

mongoose
  .connect(
    'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/message?retryWrites=true'
    )
  .then(result => {
    app.listen(8080);
  })
  .catch(err => console.log(err));
```

```js
//./controllers/feed.js(b)

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  Post.find()
    .then(posts => {
      res
        .status(200)
        .json({ message: 'Fetched posts successfully.', posts: posts });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }
  /**there the path variable which multer generates
   * which holds the path to the file as it was stored on my server.
   */
  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    fetch('http://localhost:8080/feed/posts')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts,
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    /**we can create a new Form data object with a built-in object
     * that browser side javascript offeres, the form data object.
     */
    const formData = new FormData()
    /**first argument to append is the name of the field,
     * second argument is the actual data.
     * 
     * now i got from data prepared that now has mixed content, text,file
     */
    formData.append('title', postData.title);
    formData.append('content', postData.content);
    formData.append('image', postData.image);
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST';
    if (this.state.editPost) {
      url = 'URL';
    }

    fetch(url, {
      method: method,
        /**we won't use JSON data anymore
         * because JSON data is only text,
         * so only data that can be represented as a text
         * which a file can't be or not easily,
         * it will be very big quickly
         * and very big files are a hugh issue.
         * so we can't use JSON for data
         * where we have both a file or normal text data.
         * instead we will use form data.
         * 
         * when we used a form with this multipart form anchor tag
         * which we added to the form HTML element.
         * but we will not use anything to any form element,
         * we will do it all in javascript instead. 
         */

         /**form data will automatically set the headers.
          * that is kind of convenience
          */
      body: formData
      
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

\* Chapter 378: Updating Posts
==============================

1\. update

- ./routes/feed.js(b)

- ./controllers/feed.js(b)

- ./src/pages/Feed/Feed.js(f)

![](images/378-updating-posts-1.png)![378-updating-posts-1.png](resources/4E073E82B808ACFCEBF7FDC9A357B544.png)

- 'imageUrl' is from ./models/post.js file in backend. i'm storing the original path ‘imagePath’. 

![](images/378-updating-posts-2.png)![378-updating-posts-2.png](resources/FF293C801D866263C17236565EDB5E0B.png)

- because when i'm viewing a single post for example, i extract imageUrl and i append my URL to the domain like below in ./src/pages/Feed/SinglePost/SinglePost.js file,

 image: 'http://localhost:8080/' + resData.post.imageUrl 

![](images/378-updating-posts-3.png)![378-updating-posts-3.png](resources/285CAC8399A650237CFCCD7FA8D05FA2.png)

- now the path should be a path without a domain. 

![](images/378-updating-posts-4.png)

![](images/378-updating-posts-5.png)![378-updating-posts-4.png](resources/3BCB3961CCC6E9C5200208EBEFBE483F.png)![378-updating-posts-5.png](resources/082EB3B0A515C3B95FB608A88D357C59.png)

- because i'm keeping that here 'imagePath: post.imageUrl’ and this will get reused later when we edit this through the edit model, behind the scene, this path will be stored and if i don’t choose a new file here, this path will be submitted with my edited post and there, the path will be stored in a property named image which you can see in the ./src/components/Feed/FeedEdit/FeedEdit.js file

![](images/378-updating-posts-6.png)

![](images/378-updating-posts-7.png)

![](images/378-updating-posts-8.png)

![](images/378-updating-posts-9.png)

![](images/378-updating-posts-10.png)![378-updating-posts-6.png](resources/1242B093206B9D1D9E44113BF7665AD0.png)![378-updating-posts-7.png](resources/B2E7CF8FD97332809336348A47E8037C.png)![378-updating-posts-8.png](resources/947CAC032B8A505B57E0D3E9D4BF6234.png)![378-updating-posts-9.png](resources/851F8C2962C950115A33BF6D34D70F0B.png)![378-updating-posts-10.png](resources/FE3E6B918A942B4FB1AA85D4F5DEDF1B.png)

- if we edit it, changed. and on the backend, i have coffee mug now.

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    fetch('http://localhost:8080/feed/posts')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts.map(post => {
            return {
              ...post,
              /**'imageUrl' is from ./models/post.js file in backend
               * i'm storing the original path 'imagePath'
               * because when i'm viewing a single post for example,
               * i extract imageUrl and i append my URL to the domain like below
               * in ./src/pages/Feed/SinglePost/SinglePost.js file,
               *
               *    image: 'http://localhost:8080/' + resData.post.imageUrl
               *
               * now the path should be a path without a domain.
               * because i'm keeping that here 'imagePath: post.imageUrl'
               * and this will get reused later when we edit through the edit model.
               * behind the scene, this path will be stored
               * and if i don’t choose a new file here,
               * this path will be submitted with my edited post
               * and there, the path will be stored in a property named image
               * which you can see in the
               * ./src/components/Feed/FeedEdit/FeedEdit.js file
              */
              imagePath: post.imageUrl
            };
          }),
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    const formData = new FormData()
    formData.append('title', postData.title);
    formData.append('content', postData.content);
    formData.append('image', postData.image);
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST';
    if (this.state.editPost) {
      url = 'http://localhost:8080/feed/post/' + this.state.editPost._id;
      method = 'PUT';
    }

    fetch(url, {
      method: method,
      body: formData

    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');

const router = express.Router();

// GET /feed/posts
router.get('/posts', feedController.getPosts);

// POST /feed/post
router.post(
  '/post',
  [
    body('title')
      .trim()
      .isLength({ min: 5 }),
    body('content')
      .trim()
      .isLength({ min: 5 })
  ],
  feedController.createPost
);

router.get('/post/:postId', feedController.getPost);

/**i wanna be able to edit posts now
 * and for that, i will use a new HTTP method
 * editing a post is like replacing it,
 * replacing the old post with a new one,
 * we will keep the old Id but that is it.
 * since we will replace a resource.
 * i will use the put method
 * with normal browser forms,
 * you are not able to send it, 
 * through asynchronous requests triggered by javascript
 * you are however.
 * 
 * the important thing about PUT requests
 * and the same is true for PATCH requests,
 * is that they also have a request body, just like POST requests.
 * request body will hold the actual post data i wanna use
 * and that i wanna use to replace my existing post.
  */

  /**i will not validate my image
   * because that is done directly in the controller action
   * and i don't need to do any other validation for now.
   */
router.put('/post/:postId', [
  body('title')
    .trim()
    .isLength({ min: 5 }),
  body('content')
    .trim()
    .isLength({ min: 5 })
  ], feedController.updatePost
);

module.exports = router;

```

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  Post.find()
    .then(posts => {
      res
        .status(200)
        .json({ message: 'Fetched posts successfully.', posts: posts });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }
  /**there the path variable which multer generates
   * which holds the path to the file as it was stored on my server.
   */
  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  /**the imageUrl is part of the incoming request
   * and it's just some text in the req.body
   * that would be the case if no new file was added.
   * if no new file was picked.
   * then my frontend code has all the logic to take the existing URL
   * and keep that.
   *
   * but we might have picked a file
   * and in this case, request file will be set
   * and i can set imageUrl equal to req.file.path
   * this is alternative.
   *
   * after all, at least one of the 2 should be set.
   */

  /**'image' from frontend. */
  let imageUrl = req.body.image;
  if(req.file) {
    imageUrl = req.file.path
  }
  if(!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if(imageUrl !== post.image) {
        clearImage(post.ImageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({message: 'Post updated!', post: result});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
  })
};

const clearImage = filePath => {
  /**we should go up one folder to be in the root folder
   * and then we look for whatever file path we got here
   * images and then the image name would be the case in our application 
   * 
   * and i can then use 'unlink' function to delete that file
   * by passing the file path to it
   * and we can also log any error message
   * 
   * i wanna trigger that clearImage function
   * when i uploaded a new image
   * 
  */
  filePath = path.join(__dirname, '..', filePath)
  fs.unlink(filePath, err => console.log(err));
}

```

\* Chapter 379: Deleting Posts
==============================

1\. update

- ./routes/feed.js(b)

- ./controllers/feed.js(b)

- ./src/pages/Feed/Feed.js(f)

![](images/379-deleting-posts-1.png)

![](images/379-deleting-posts-2.png)

![](images/379-deleting-posts-3.png)![379-deleting-posts-1.png](resources/2F581C7229AC0AC405A295AC2BD0C8C2.png)![379-deleting-posts-2.png](resources/AB7CE6B2DC18292E031317E99108710A.png)![379-deleting-posts-3.png](resources/3CF998CC479E2382A9C25EABDFFB0128.png)

- the picture duck is gone. 

![](images/379-deleting-posts-4.png)![379-deleting-posts-4.png](resources/4EB0FB70F59B06CB7200FB64863BB83F.png)

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  Post.find()
    .then(posts => {
      res
        .status(200)
        .json({ message: 'Fetched posts successfully.', posts: posts });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }
  /**there the path variable which multer generates
   * which holds the path to the file as it was stored on my server.
   */
  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if(req.file) {
    imageUrl = req.file.path
  }
  if(!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if(imageUrl !== post.image) {
        clearImage(post.ImageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({message: 'Post updated!', post: result});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
  })
};

exports.deletePost = (req, res, next) => {
  const postId = req.params.postId;
  /**why would i find it by Id first?
   * i can also use findByIdAndRemove
   * i will use this eventually
   * but later we edit a user,
   * i wanna verify whether that user created the post before i delete it.
   */
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      //Check logged in user
      clearImage(post.imageUrl);
      return Post.findByIdAndRemove(postId);
    })
    .then(result => {
      console.log(result);
      res.status(200).json({message: 'Deleted post.'});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
}

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath)
  fs.unlink(filePath, err => console.log(err));
}

```

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');

const router = express.Router();

// GET /feed/posts
router.get('/posts', feedController.getPosts);

// POST /feed/post
router.post(
  '/post',
  [
    body('title')
      .trim()
      .isLength({ min: 5 }),
    body('content')
      .trim()
      .isLength({ min: 5 })
  ],
  feedController.createPost
);

router.get('/post/:postId', feedController.getPost);

/**i wanna be able to edit posts now
 * and for that, i will use a new HTTP method
 * editing a post is like replacing it,
 * replacing the old post with a new one,
 * we will keep the old Id but that is it.
 * since we will replace a resource.
 * i will use the put method
 * with normal browser forms,
 * you are not able to send it, 
 * through asynchronous requests triggered by javascript
 * you are however.
 * 
 * the important thing about PUT requests
 * and the same is true for PATCH requests,
 * is that they also have a request body, just like POST requests.
 * request body will hold the actual post data i wanna use
 * and that i wanna use to replace my existing post.
  */

  /**i will not validate my image
   * because that is done directly in the controller action
   * and i don't need to do any other validation for now.
   */
router.put('/post/:postId', [
  body('title')
    .trim()
    .isLength({ min: 5 }),
  body('content')
    .trim()
    .isLength({ min: 5 })
  ], feedController.updatePost
);

router.delete('/post/:postId', feedController.deletePost);

module.exports = router;

```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    fetch('http://localhost:8080/feed/posts')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts.map(post => {
            return {
              ...post,
              imagePath: post.imageUrl
            };
          }),
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    const formData = new FormData()
    formData.append('title', postData.title);
    formData.append('content', postData.content);
    formData.append('image', postData.image);
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST';
    if (this.state.editPost) {
      url = 'http://localhost:8080/feed/post/' + this.state.editPost._id;
      method = 'PUT';
    }

    fetch(url, {
      method: method,
      body: formData

    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('http://localhost:8080/feed/post/' + postId, {
      method: 'DELETE'
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;
```

\* Chapter 380: Adding Pagination
=================================

1\. update

- ./src/pages/Feed/Feed.js(f)

- ./controllers/feed.js(b)

![](images/380-adding-pagination-1.png)

![](images/380-adding-pagination-2.png)

![](images/380-adding-pagination-3.png)

![](images/380-adding-pagination-4.png)

![](images/380-adding-pagination-5.png)![380-adding-pagination-1.png](resources/9B8BA0DED4002838449953CECBDF5A3F.png)![380-adding-pagination-2.png](resources/6BA222E5A15681CF8318A0E0C6E8966C.png)![380-adding-pagination-3.png](resources/AD80A9254F2533761FD79C14EEFC6DF4.png)![380-adding-pagination-4.png](resources/F32EE6ACC8B5239CD54E9EED98D6769E.png)![380-adding-pagination-5.png](resources/98A55AE5AA9487FC1C5AA40F0C00D59C.png)

- i wanna limit showing data which is called pagination.

![](images/380-adding-pagination-6.png)

![](images/380-adding-pagination-7.png)

![](images/380-adding-pagination-8.png)![380-adding-pagination-6.png](resources/28E1B2B4F055BEA1CF28B72CA260DFB6.png)![380-adding-pagination-7.png](resources/DDECA501D4B3B6CC3E71EED7D8A4E3AC.png)![380-adding-pagination-8.png](resources/C57A2C9DF4FE97BDDCF7CF128420C20F.png)

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');

exports.getPosts = (req, res, next) => {
  const currentPage = req.query.page || 1;
  /**i will set the per page value to 2
   * and i do this because i have the same value in the frontend.
   */
  const perPage = 2;
  let totalItems;
  Post.find()
    .countDocuments()
    .then(count => {
      totalItems = count;
      /**we can skip a certain amount of items with the '.skip()' method*/
      return Post.find()
        .skip((currentPage - 1) * perPage)
        .limit(perPage)
    })
    .then(posts => {
      res
        .status(200)
        .json({
          message: 'Fetched posts successfully.',
          posts: posts,
          totalItems: totalItems
        });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }

  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: { name: 'Maximilian' }
  });
  post
    .save()
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: result
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if(req.file) {
    imageUrl = req.file.path
  }
  if(!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if(imageUrl !== post.image) {
        clearImage(post.ImageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({message: 'Post updated!', post: result});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
  })
};

exports.deletePost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      //Check logged in user
      clearImage(post.imageUrl);
      return Post.findByIdAndRemove(postId);
    })
    .then(result => {
      console.log(result);
      res.status(200).json({message: 'Deleted post.'});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
}

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath)
  fs.unlink(filePath, err => console.log(err));
}

```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    fetch('http://localhost:8080/feed/posts?page=' + page)
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts.map(post => {
            return {
              ...post,
              imagePath: post.imageUrl
            };
          }),
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    const formData = new FormData()
    formData.append('title', postData.title);
    formData.append('content', postData.content);
    formData.append('image', postData.image);
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST';
    if (this.state.editPost) {
      url = 'http://localhost:8080/feed/post/' + this.state.editPost._id;
      method = 'PUT';
    }

    fetch(url, {
      method: method,
      body: formData

    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('http://localhost:8080/feed/post/' + postId, {
      method: 'DELETE'
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

\* Chapter 381: Adding A User Model
===================================

1\. update

- ./models/user.js(b)

- ./routes/auth.js(b)

- app.js(b)

```js
//./models/user.js(b)

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const userSchema = new Schema({
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    name: {
        type: String,
        required: true
    },
    status: {
        type: String,
        required: true
    },
    /**each object in the array will be of Type 'Schema.Types.ObjectId'
     * because this will be reference to a post
     * and therefore i add this ref key and add the post model.
     * so i will store references to Post in my users or on my users.
     */
    posts: [{
        type: Schema.Types.ObjectId,
        ref: 'Post'
    }]
});

module.exports = mongoose.model('User', userSchema);
```

```js
//./routes/auth.js(b)

const express = require('express');

const router = express.Router();

/**let's go for a PUT route
 * because we create a user once.
 */
router.put('/singup');

module.exports = router;
```

```js
//app.js(b)

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const multer = require('multer');

const feedRoutes = require('./routes/feed');
const authRoutes = require('./routes/auth');

const app = express();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if(
    file.mimetype === 'image/png' || 
    file.mimetype === 'image/jpg' || 
    file.mimetype === 'image/jpeg'
    ) {
      cb(null, true);
    } else {
      cb(null, false);
    }
}

// app.use(bodyParser.urlencoded()); // x-www-form-urlencoded <form>
app.use(bodyParser.json()); // application/json
app.use(multer({storage: fileStorage, fileFilter: fileFilter}).single('image'))
app.use('/images', express.static(path.join(__dirname, 'images')));

app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader(
    'Access-Control-Allow-Methods',
    'OPTIONS, GET, POST, PUT, PATCH, DELETE'
  );
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

app.use('/feed', feedRoutes);
app.use('/auth', authRoutes);

app.use((error, req, res, next) => {
  console.log(error);
  const status = error.statusCode || 500;
  const message = error.message;
  res.status(status).json({ message: message });
});

mongoose
  .connect(
    'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/message?retryWrites=true'
    )
  .then(result => {
    app.listen(8080);
  })
  .catch(err => console.log(err));
```

\* Chapter 382: Adding User Signup Validation
=============================================

1\. update

- ./controllers/auth.js(b)

- ./routes/auth.js(b)

- app.js(b)

```js
//./controllers/auth.js(b)

const { validationResult } = require('express-validator/check');

const User = require('../models/user');

exports.singup = (req, res, next) => {
    const errors = validationResult(req);
    if(!errors.isEmpty()){
        const error = new Error('Validation failed');
        error.statusCode = 422;
        /**'error.data = errors.array()'
         * this would allow me to keep my errors
         * which were retrieved by that validation package
         */
        error.data = errors.array();
        throw error;
    }
    const email = req.body.email;
    const name = req.body.name;
    const password = req.body.password;

}
```

```js
//./routes/auth.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const User = require('../models/user');
const authController = require('../controllers/auth');

const router = express.Router();

/**let's go for a PUT route
 * because we create a user once.
 */
router.put(
  '/signup',
  [
    body('email')
      .isEmail()
      .withMessage('Please enter a valid email.')
        /**we can also add our own custom validator
         * to check whether the email address already exists.
         *
         * value and then an object from which we can extract the request
         * as a property with this destructuring syntax
         */
      .custom((value, { req }) => {
        return User.findOne({ email: value }).then(userDoc => {
          if (userDoc) {
                        /**if thta is set,
                         * then i will reject a promise,
                         * so i will return Promise.reject()
                         * and that will cause the validation
                         * all other scenarios will cause it to succeed
                         * and then i will return 'E-Mail address already exists!'
                         */
            return Promise.reject('E-Mail address already exists!');
          }
        });
      })
      .normalizeEmail(),
    body('password')
      .trim()
      .isLength({ min: 5 }),
    body('name')
      .trim()
      .not()
      .isEmpty()
  ],
  authController.signup
);

router.post('/login', authController.login);

module.exports = router;

```

```js
//app.js(b)

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const multer = require('multer');

const feedRoutes = require('./routes/feed');
const authRoutes = require('./routes/auth');

const app = express();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if(
    file.mimetype === 'image/png' || 
    file.mimetype === 'image/jpg' || 
    file.mimetype === 'image/jpeg'
    ) {
      cb(null, true);
    } else {
      cb(null, false);
    }
}

// app.use(bodyParser.urlencoded()); // x-www-form-urlencoded <form>
app.use(bodyParser.json()); // application/json
app.use(multer({storage: fileStorage, fileFilter: fileFilter}).single('image'))
app.use('/images', express.static(path.join(__dirname, 'images')));

app.use((req, res, next) => {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader(
    'Access-Control-Allow-Methods',
    'OPTIONS, GET, POST, PUT, PATCH, DELETE'
  );
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  next();
});

app.use('/feed', feedRoutes);
app.use('/auth', authRoutes);

app.use((error, req, res, next) => {
  console.log(error);
  const status = error.statusCode || 500;
  const message = error.message;
  const data = error.data;
  res.status(status).json({ message: message, data: data });
});

mongoose
  .connect(
    'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/message?retryWrites=true'
    )
  .then(result => {
    app.listen(8080);
  })
  .catch(err => console.log(err));
```

\* Chapter 383: Signing User Up
===============================

1\. update

- ./controllers/auth.js(b)

- ./models/user.js(b)

- App.js(f)

![](images/383-signing-user-up-1.png)![383-signing-user-up-1.png](resources/30DAC23892D7993F92AEF562E46B3EE0.png)

- i will install a new package called ‘bcrypt.js’ which allows us to hash a password in a secure way.

![](images/383-signing-user-up-2.png)

![](images/383-signing-user-up-3.png)

![](images/383-signing-user-up-4.png)![383-signing-user-up-2.png](resources/1EAAD3EB40C9BED5FCC3A2F9B35709D4.png)![383-signing-user-up-3.png](resources/974BAD1256F389EDB2E6C136A6741D4C.png)![383-signing-user-up-4.png](resources/7F15F32203AE77F8EB6FA387BC2049C8.png)

```js
//./controllers/auth.js(b)

const { validationResult } = require('express-validator/check');
const bcrypt = require('bcryptjs');


const User = require('../models/user');

exports.singup = (req, res, next) => {
    const errors = validationResult(req);
    if(!errors.isEmpty()){
        const error = new Error('Validation failed');
        error.statusCode = 422;
        error.data = errors.array();
        throw error;
    }
    const email = req.body.email;
    const name = req.body.name;
    const password = req.body.password;
    /**password which is plaintext with a salt of 12,
     * so a strength of 12.
     */
    bcrypt.hash(password, 12)
        .then(hashedPw => {
            const user = new User({
                email: email,
                passowrd: hashedPw,
                name: name
            });
            /**we can add 'return'
             * so that we can add another '.then()'
             */
            return user.save();
        })
        .then(result => {
            res.status(201).json({message: 'User created!', userId: result._id});
        })
        .catch(err => {
            if(!err.statusCode) {
                err.statusCode = 500;
            }
            next(err);
    })
}
```

```js
//./models/user.js(b)

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const userSchema = new Schema({
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    name: {
        type: String,
        required: true
    },
    status: {
        type: String,
        default: 'I am new!'
    },
    posts: [{
        type: Schema.Types.ObjectId,
        ref: 'Post'
    }]
});

module.exports = mongoose.model('User', userSchema);
```

```js
//App.js(f)

import React, { Component, Fragment } from 'react';
import { Route, Switch, Redirect, withRouter } from 'react-router-dom';

import Layout from './components/Layout/Layout';
import Backdrop from './components/Backdrop/Backdrop';
import Toolbar from './components/Toolbar/Toolbar';
import MainNavigation from './components/Navigation/MainNavigation/MainNavigation';
import MobileNavigation from './components/Navigation/MobileNavigation/MobileNavigation';
import ErrorHandler from './components/ErrorHandler/ErrorHandler';
import FeedPage from './pages/Feed/Feed';
import SinglePostPage from './pages/Feed/SinglePost/SinglePost';
import LoginPage from './pages/Auth/Login';
import SignupPage from './pages/Auth/Signup';
import './App.css';

class App extends Component {
  state = {
    showBackdrop: false,
    showMobileNav: false,
    /**we should change 'true' of 'isAuth' to 'false'
     * so that we start unauthenticated.
     */
    isAuth: false,
    token: null,
    userId: null,
    authLoading: false,
    error: null
  };

  componentDidMount() {
    const token = localStorage.getItem('token');
    const expiryDate = localStorage.getItem('expiryDate');
    if (!token || !expiryDate) {
      return;
    }
    if (new Date(expiryDate) <= new Date()) {
      this.logoutHandler();
      return;
    }
    const userId = localStorage.getItem('userId');
    const remainingMilliseconds =
      new Date(expiryDate).getTime() - new Date().getTime();
    this.setState({ isAuth: true, token: token, userId: userId });
    this.setAutoLogout(remainingMilliseconds);
  }

  mobileNavHandler = isOpen => {
    this.setState({ showMobileNav: isOpen, showBackdrop: isOpen });
  };

  backdropClickHandler = () => {
    this.setState({ showBackdrop: false, showMobileNav: false, error: null });
  };

  logoutHandler = () => {
    this.setState({ isAuth: false, token: null });
    localStorage.removeItem('token');
    localStorage.removeItem('expiryDate');
    localStorage.removeItem('userId');
  };

  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }
        if (res.status !== 200 && res.status !== 201) {
          console.log('Error!');
          throw new Error('Could not authenticate you!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState({
          isAuth: true,
          token: resData.token,
          authLoading: false,
          userId: resData.userId
        });
        localStorage.setItem('token', resData.token);
        localStorage.setItem('userId', resData.userId);
        const remainingMilliseconds = 60 * 60 * 1000;
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err
        });
      });
  };

  signupHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/signup', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      /**everything which we extract on the server side.
       * this is now all passed to our backend.
       * 
       * '.signupForm' is how the data is stored internally in the React app
       * and this is how we should extract it
       */
      body: JSON.stringify({
        email: authData.signupForm.email.value,
        password: authData.signupForm.password,
        name: authData.signupForm.name
      })
    })
      .then(res => {
        if (res.status === 422) {
          throw new Error(
            "Validation failed. Make sure the email address isn't used yet!"
          );
        }
        if (res.status !== 200 && res.status !== 201) {
          console.log('Error!');
          throw new Error('Creating a user failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState({ isAuth: false, authLoading: false });
        this.props.history.replace('/');
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err
        });
      });
  };

  setAutoLogout = milliseconds => {
    setTimeout(() => {
      this.logoutHandler();
    }, milliseconds);
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  render() {
    let routes = (
      <Switch>
        <Route
          path="/"
          exact
          render={props => (
            <LoginPage
              {...props}
              onLogin={this.loginHandler}
              loading={this.state.authLoading}
            />
          )}
        />
        <Route
          path="/signup"
          exact
          render={props => (
            <SignupPage
              {...props}
              onSignup={this.signupHandler}
              loading={this.state.authLoading}
            />
          )}
        />
        <Redirect to="/" />
      </Switch>
    );
    if (this.state.isAuth) {
      routes = (
        <Switch>
          <Route
            path="/"
            exact
            render={props => (
              <FeedPage userId={this.state.userId} token={this.state.token} />
            )}
          />
          <Route
            path="/:postId"
            render={props => (
              <SinglePostPage
                {...props}
                userId={this.state.userId}
                token={this.state.token}
              />
            )}
          />
          <Redirect to="/" />
        </Switch>
      );
    }
    return (
      <Fragment>
        {this.state.showBackdrop && (
          <Backdrop onClick={this.backdropClickHandler} />
        )}
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <Layout
          header={
            <Toolbar>
              <MainNavigation
                onOpenMobileNav={this.mobileNavHandler.bind(this, true)}
                onLogout={this.logoutHandler}
                isAuth={this.state.isAuth}
              />
            </Toolbar>
          }
          mobileNav={
            <MobileNavigation
              open={this.state.showMobileNav}
              mobile
              onChooseItem={this.mobileNavHandler.bind(this, false)}
              onLogout={this.logoutHandler}
              isAuth={this.state.isAuth}
            />
          }
        />
        {routes}
      </Fragment>
    );
  }
}

export default withRouter(App);

```

\* Chapter 384: How Does Authentication Work?
=============================================

![](images/384-how-does-authentication-work-1.png)![384-how-does-authentication-work-1.png](resources/BD7A6884A1F5D271E04298BDE9FC0F5B.png)

- we don’t use a session anymore because RESTful APIs are stateless, they don’t care about client. you learned about that strict decoupling of server and client and every request should be treated standalone which means every request should have all the data it needs to authenticate itself. with session, the server needs to store data about the client, the server then stores that a client is a authenticated. that is not how RESTful APIs work. the server will not store anything about any client. 

- but instead we return so-called ’token’ to the client which will be generated on the server and will hold some information which can only be validated by the server which create a token. 

- so stored token is attached to every request that targets a resource on the serer which requires authentication. and if you change that token on the frontend or you try to create it to fake that you are authenticated, that will be detected because the server used a certain algorithm for generating the token which you can’t fake because you don’t know the private key by the server. 

![](images/384-how-does-authentication-work-2.png)![384-how-does-authentication-work-2.png](resources/E4FF3483FC360AFA195E1406C962B989.png)

- Token contains JSON Data which is javascript data + signature which is generated on the server with a special private key which is only stored on the server. 

- the result is ‘JSON Web Token(JWT)’ which is returned to the client

\* Chapter 386: Logging In & Creating JSON Web Tokens(JWTs)
===========================================================

1\. update

- ./routes/auth.js(b)

- ./controllers/auth.js(b)

- App.js(f)

![](images/386-logging-in-and-creating-json-web-tokens-jwts-1.png)![386-logging-in-and-creating-json-web-tokens-jwts-1.png](resources/3935A776FD880434BA33D414302FC1D3.png)

- ’npm install —save jsonwebtoken’ is the package which allows us to conveniently create such new JSON web tokens. 

![](images/386-logging-in-and-creating-json-web-tokens-jwts-2.png)

![](images/386-logging-in-and-creating-json-web-tokens-jwts-3.png)

![](images/386-logging-in-and-creating-json-web-tokens-jwts-4.png)

![](images/386-logging-in-and-creating-json-web-tokens-jwts-5.png)![386-logging-in-and-creating-json-web-tokens-jwts-2.png](resources/DE6F4A8B36FC7B45DF212699D1102804.png)![386-logging-in-and-creating-json-web-tokens-jwts-3.png](resources/7D77244E0FED1EA7F835A548B1A253D3.png)![386-logging-in-and-creating-json-web-tokens-jwts-4.png](resources/6F5D3FDF906DF86BD356D119D2363C28.png)![386-logging-in-and-creating-json-web-tokens-jwts-5.png](resources/8B301D1970E7E88BE4164E4E74F76160.png)

- that is the token we generated on the server. 

![](images/386-logging-in-and-creating-json-web-tokens-jwts-6.png)![386-logging-in-and-creating-json-web-tokens-jwts-6.png](resources/478D3D1EBB117DC1049B475C73931590.png)

- the other data is data i’m storing here or that was stored way back by other application so we don’t need that. that has nothing to do with our app. we have the expiry date which i generated on the client to know when i should remove the token because it expired and this is the token itself. 

![](images/386-logging-in-and-creating-json-web-tokens-jwts-7.png)

![](images/386-logging-in-and-creating-json-web-tokens-jwts-8.png)![386-logging-in-and-creating-json-web-tokens-jwts-7.png](resources/2AF1CCAE112D1B9F3F27D551B896B404.png)![386-logging-in-and-creating-json-web-tokens-jwts-8.png](resources/8E8825C48F22C83222ED792DF2C6EEE3.png)

- if i change the email address, the token changes on the left and therefore if i edit this, it will not be validated because now the token is not the same as it was when it was generated on the server with this secret. 

![](images/386-logging-in-and-creating-json-web-tokens-jwts-9.png)![386-logging-in-and-creating-json-web-tokens-jwts-9.png](resources/1445435DA174427C4B33AEFC0FA013D4.png)

- so if i try to generate my own one with a different secret, i will end up with a different token and if i try to edit the data in there, i also do so i can’t mess around with the token in the client. the server will detect this.

```js
//./controllers/auth.js(b)

const { validationResult } = require('express-validator/check');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const User = require('../models/user');

exports.signup = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array();
    throw error;
  }
  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;
  /**password which is plaintext with a salt of 12,
   * so a strength of 12.
   */
  bcrypt
    .hash(password, 12)
    .then(hashedPw => {
      const user = new User({
        email: email,
        password: hashedPw,
        name: name
      });
    /**we can add 'return'
     * so that we can add another '.then()'
     */
      return user.save();
    })
    .then(result => {
      res.status(201).json({ message: 'User created!', userId: result._id });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.login = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;
  User.findOne({ email: email })
    .then(user => {
      if (!user) {
        const error = new Error('A user with this email could not be found.');
        error.statusCode = 401;
        throw error;
      }
      loadedUser = user;
      /**'password' is what i filled in
       * 'user.password' is what is stored in the server
       */
      return bcrypt.compare(password, user.password);
    })
    .then(isEqual => {
      if (!isEqual) {
        const error = new Error('Wrong password!');
        error.statusCode = 401;
        throw error;
      }
      /**'jwt.sign()' creates a new signature
       * and packs that into a new JSON web token.
       * we can add any data we wanna into the token.
       */
      const token = jwt.sign(
        {
          email: loadedUser.email,
          userId: loadedUser._id.toString()
        },
      /**then you need to pass a 2nd argument
       * which is that secret,
       * so that private key which is used for signing
       * and that is only known to the server
       * and therefore you can't fake that token on the client.
       * 
       * you can use 'secret'
       * but typically you wanna use a longer string
       * like 'somesupersecretsecret' like that.
       * this is security mechanism you should add
       * because the token is stored in the client.
       * by the client to whom it belongs
       * but technically that token could be stolen.
       * if the user doesn't logout,
       * another person copies the token from his browser storage
       * and then he can use it on his own PC forever.
      */
        'somesupersecretsecret',
        { expiresIn: '1h' }
      );
      res.status(200).json({ token: token, userId: loadedUser._id.toString() });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

```

```js
//./routes/auth.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const User = require('../models/user');
const authController = require('../controllers/auth');

const router = express.Router();

router.put(
  '/signup',
  [
    body('email')
      .isEmail()
      .withMessage('Please enter a valid email.')
      .custom((value, { req }) => {
        return User.findOne({ email: value }).then(userDoc => {
          if (userDoc) {
            return Promise.reject('E-Mail address already exists!');
          }
        });
      })
      .normalizeEmail(),
    body('password')
      .trim()
      .isLength({ min: 5 }),
    body('name')
      .trim()
      .not()
      .isEmpty()
  ],
  authController.signup
);

router.post('/login', authController.login);

module.exports = router;

```

```js
//App.js(f)

import React, { Component, Fragment } from 'react';
import { Route, Switch, Redirect, withRouter } from 'react-router-dom';

import Layout from './components/Layout/Layout';
import Backdrop from './components/Backdrop/Backdrop';
import Toolbar from './components/Toolbar/Toolbar';
import MainNavigation from './components/Navigation/MainNavigation/MainNavigation';
import MobileNavigation from './components/Navigation/MobileNavigation/MobileNavigation';
import ErrorHandler from './components/ErrorHandler/ErrorHandler';
import FeedPage from './pages/Feed/Feed';
import SinglePostPage from './pages/Feed/SinglePost/SinglePost';
import LoginPage from './pages/Auth/Login';
import SignupPage from './pages/Auth/Signup';
import './App.css';

class App extends Component {
  state = {
    showBackdrop: false,
    showMobileNav: false,
    isAuth: false,
    token: null,
    userId: null,
    authLoading: false,
    error: null
  };

  componentDidMount() {
    const token = localStorage.getItem('token');
    const expiryDate = localStorage.getItem('expiryDate');
    if (!token || !expiryDate) {
      return;
    }
    if (new Date(expiryDate) <= new Date()) {
      this.logoutHandler();
      return;
    }
    const userId = localStorage.getItem('userId');
    const remainingMilliseconds =
      new Date(expiryDate).getTime() - new Date().getTime();
    this.setState({ isAuth: true, token: token, userId: userId });
    this.setAutoLogout(remainingMilliseconds);
  }

  mobileNavHandler = isOpen => {
    this.setState({ showMobileNav: isOpen, showBackdrop: isOpen });
  };

  backdropClickHandler = () => {
    this.setState({ showBackdrop: false, showMobileNav: false, error: null });
  };

  logoutHandler = () => {
    this.setState({ isAuth: false, token: null });
    localStorage.removeItem('token');
    localStorage.removeItem('expiryDate');
    localStorage.removeItem('userId');
  };

  loginHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/login', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        email: authData.email,
        password: authData.password
      })
    })
      .then(res => {
        if (res.status === 422) {
          throw new Error('Validation failed.');
        }
        if (res.status !== 200 && res.status !== 201) {
          console.log('Error!');
          throw new Error('Could not authenticate you!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState({
          isAuth: true,
          token: resData.token,
          authLoading: false,
          userId: resData.userId
        });
        localStorage.setItem('token', resData.token);
        localStorage.setItem('userId', resData.userId);
        const remainingMilliseconds = 60 * 60 * 1000;
        const expiryDate = new Date(
          new Date().getTime() + remainingMilliseconds
        );
        localStorage.setItem('expiryDate', expiryDate.toISOString());
        this.setAutoLogout(remainingMilliseconds);
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err
        });
      });
  };

  signupHandler = (event, authData) => {
    event.preventDefault();
    this.setState({ authLoading: true });
    fetch('http://localhost:8080/auth/signup', {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        email: authData.signupForm.email.value,
        password: authData.signupForm.password.value,
        name: authData.signupForm.name.value
      })
    })
      .then(res => {
        if (res.status === 422) {
          throw new Error(
            "Validation failed. Make sure the email address isn't used yet!"
          );
        }
        if (res.status !== 200 && res.status !== 201) {
          console.log('Error!');
          throw new Error('Creating a user failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState({ isAuth: false, authLoading: false });
        this.props.history.replace('/');
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isAuth: false,
          authLoading: false,
          error: err
        });
      });
  };

  setAutoLogout = milliseconds => {
    setTimeout(() => {
      this.logoutHandler();
    }, milliseconds);
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  render() {
    let routes = (
      <Switch>
        <Route
          path="/"
          exact
          render={props => (
            <LoginPage
              {...props}
              onLogin={this.loginHandler}
              loading={this.state.authLoading}
            />
          )}
        />
        <Route
          path="/signup"
          exact
          render={props => (
            <SignupPage
              {...props}
              onSignup={this.signupHandler}
              loading={this.state.authLoading}
            />
          )}
        />
        <Redirect to="/" />
      </Switch>
    );
    if (this.state.isAuth) {
      routes = (
        <Switch>
          <Route
            path="/"
            exact
            render={props => (
              <FeedPage userId={this.state.userId} token={this.state.token} />
            )}
          />
          <Route
            path="/:postId"
            render={props => (
              <SinglePostPage
                {...props}
                userId={this.state.userId}
                token={this.state.token}
              />
            )}
          />
          <Redirect to="/" />
        </Switch>
      );
    }
    return (
      <Fragment>
        {this.state.showBackdrop && (
          <Backdrop onClick={this.backdropClickHandler} />
        )}
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <Layout
          header={
            <Toolbar>
              <MainNavigation
                onOpenMobileNav={this.mobileNavHandler.bind(this, true)}
                onLogout={this.logoutHandler}
                isAuth={this.state.isAuth}
              />
            </Toolbar>
          }
          mobileNav={
            <MobileNavigation
              open={this.state.showMobileNav}
              mobile
              onChooseItem={this.mobileNavHandler.bind(this, false)}
              onLogout={this.logoutHandler}
              isAuth={this.state.isAuth}
            />
          }
        />
        {routes}
      </Fragment>
    );
  }
}

export default withRouter(App);

```

\* Chapter 387: Using & Validating The Token
============================================

1\. update

- ./middleware/is-auth.js(b)

- ./src/pages/Feed/Feed.js(f)

- ./routes/feed.js(b)

![](images/387-using-and-validating-the-token-1.png)

![](images/387-using-and-validating-the-token-2.png)![387-using-and-validating-the-token-1.png](resources/A79A5E4572E7A39CB7DE2AD0B00AB021.png)![387-using-and-validating-the-token-2.png](resources/0EF12E1EDD39AD45C7214D9DE1706B68.png)

- let me show you how this fails. if i remove this header, so this extra configuration on my getPosts request in the frontend. 

![](images/387-using-and-validating-the-token-3.png)

![](images/387-using-and-validating-the-token-4.png)

![](images/387-using-and-validating-the-token-5.png)![387-using-and-validating-the-token-3.png](resources/D0D753ACDF7D260F1971630522B9A0DA.png)![387-using-and-validating-the-token-4.png](resources/59107B14C48A46C12439C24EC9181311.png)![387-using-and-validating-the-token-5.png](resources/9A39DE50DAE63A37740335624607AEB2.png)

- if i remove that and i reload the page, i get failed to fetch posts and in the console log, i also see that here. because it fails to read split of undefined. 

![](images/387-using-and-validating-the-token-6.png)![387-using-and-validating-the-token-6.png](resources/49D183A97988FA57E3A41A0BAADF6984.png)

- we get a technical error becasue in my middleware, it can’t get anything from that header because the header is not defined. 

![](images/387-using-and-validating-the-token-7.png)![387-using-and-validating-the-token-7.png](resources/FD4C4C40B9589DE307FB934659EA4376.png)

- therefore we could add an extra check here and first of all get the ‘authHeader’ would then be ‘req.get(‘Authorization’)'

![](images/387-using-and-validating-the-token-8.png)![387-using-and-validating-the-token-8.png](resources/BF6F72CDFAAAD040347B33038DB5ECBB.png)

- we still get error but technically we now have a 401 error which is better.

![](images/387-using-and-validating-the-token-9.png)![387-using-and-validating-the-token-9.png](resources/A7073F95CBE66363970AEB18D5E595FF.png)

- if i add the some rubbish which is not a valid token,

![](images/387-using-and-validating-the-token-10.png)![387-using-and-validating-the-token-10.png](resources/E64C7F85756C613A70D4678836BF5BD5.png)

- now if that reload it still fails and it fails because not the jsonwebtoken package has a problem with the format of our token.

![](images/387-using-and-validating-the-token-11.png)![387-using-and-validating-the-token-11.png](resources/DABD28AD0FC2B31B3021A2746820B2F7.png)

- so now let me revert this and add the valid token

![](images/387-using-and-validating-the-token-12.png)![387-using-and-validating-the-token-12.png](resources/484C8E14E5BB5A1C293D42F0BF262777.png)

- and if i reload, now our posts load because now we are validating this and we have a valid token indeed.

```js
//./middleware/auth.js(b)

const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
    const authHeader = req.get('Autorization');
    if(!authHeader) {
        const error = new Error('Not authenticated.');
        error.statusCode = 401;
        throw error;
    }
    const token = authHeader.split(' ')[1];
    let decodedToken;
    try {
        /**'jwt.verify()' will both decode and verify your token.
         * 'jwt.decode()' will have decode token
         * but this will only decode it
         * and not check if it's valid.
         * so definitely use 'verify'
         *
         * and then you pass in that token
         * which you extracted from the header
         * and then the 'secret'
         * and that has to be the same secret you used for signing the token.
         * so the same secret you used in your ./controllers/auth.js(b) file,
         * 'somesupersecretsecret' is the secret which we will use for validating the token
        */
        decodedToken = jwt.verify(token, 'somesupersecretsecret');
    } catch (err) {
        err.statusCode = 500;
        throw err;
    }
    if (!decodedToken) {
        const error = new Error('Not authenticated.');
        error.statusCode = 401;
        throw error;
    }
    /**if we make it past this if check,
     * we know that we have a valid token
     * however and that we were able to decode it,
     * i will extract some information from the token,
     * the 'userId' and i will store it in the request
     * so that i can use it in toehr places
     * where this request will go, like in my routes
     * and there i will just access the decodedToken
     * so i can now access my userId field
     * which i stored in the token.
     */
    req.userId = decodedToken.userId;
    next();
};
```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    /**using headers keeps URLs beautiful
     * and header makes a lot of sense for meta information like the token
     */
    fetch('http://localhost:8080/feed/posts?page=' + page, {
      headers: {
        /**'Authorization' header the official header 
         * use for passing authentication information to the backend
         * remember that on the backend in the app.js(b) file
         * where we added our cource headers,
         * i did enable the authorization header
         *    'res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization')'
         * you need to have that enabled for this to work. 
         */
        /**'Bearer ' is just a convention to kind of identify
         * that the type of token you have 
         * and the bearer token is simply an authentication token,
         * you typically use bearer for JSON Web Token.
         * but you could work without Bearer
         * but it's a common convention
         * and therefore i wanna keep that convention. 
         */
        Authorization : 'Bearer ' + this.props.token
      }
    })
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts,
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    // Set up data (with image!)
    let url = 'URL';
    if (this.state.editPost) {
      url = 'URL';
    }

    fetch(url)
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

// GET /feed/posts
router.get('/posts', isAuth, feedController.getPosts);

// POST /feed/post
router.post(
  '/post',
  [
    body('title')
      .trim()
      .isLength({ min: 5 }),
    body('content')
      .trim()
      .isLength({ min: 5 })
  ],
  feedController.createPost
);

router.get('/post/:postId', feedController.getPost);

router.put('/post/:postId', [
  body('title')
    .trim()
    .isLength({ min: 5 }),
  body('content')
    .trim()
    .isLength({ min: 5 })
  ], feedController.updatePost
);

router.delete('/post/:postId', feedController.deletePost);

module.exports = router;

```

\* Chapter 388: Adding Auth Middleware To All Routes
====================================================

1\. update

- ./routes/feed.js(b)

- ./src/pages/Feed/Feed.js(f)

- ./src/pages/Feed/SinglePost/SinglePost.js(f)

```js
//./routes/feed.js(b)

const express = require('express');
const { body } = require('express-validator/check');

const feedController = require('../controllers/feed');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

// GET /feed/posts
router.get('/posts', isAuth, feedController.getPosts);

// POST /feed/post
router.post(
  '/post',
  isAuth,
  [
    body('title')
      .trim()
      .isLength({ min: 5 }),
    body('content')
      .trim()
      .isLength({ min: 5 })
  ],
  feedController.createPost
);

router.get('/post/:postId', isAuth, feedController.getPost);

router.put('/post/:postId', 
  isAuth,
  [
  body('title')
    .trim()
    .isLength({ min: 5 }),
  body('content')
    .trim()
    .isLength({ min: 5 })
  ], feedController.updatePost
);

router.delete('/post/:postId', isAuth, feedController.deletePost);

module.exports = router;

```

```js
//./src/pages/Feed/Feed.js(f)

import React, { Component, Fragment } from 'react';

import Post from '../../components/Feed/Post/Post';
import Button from '../../components/Button/Button';
import FeedEdit from '../../components/Feed/FeedEdit/FeedEdit';
import Input from '../../components/Form/Input/Input';
import Paginator from '../../components/Paginator/Paginator';
import Loader from '../../components/Loader/Loader';
import ErrorHandler from '../../components/ErrorHandler/ErrorHandler';
import './Feed.css';

class Feed extends Component {
  state = {
    isEditing: false,
    posts: [],
    totalPosts: 0,
    editPost: null,
    status: '',
    postPage: 1,
    postsLoading: true,
    editLoading: false
  };

  componentDidMount() {
    fetch('URL')
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch user status.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({ status: resData.status });
      })
      .catch(this.catchError);

    this.loadPosts();
  }

  loadPosts = direction => {
    if (direction) {
      this.setState({ postsLoading: true, posts: [] });
    }
    let page = this.state.postPage;
    if (direction === 'next') {
      page++;
      this.setState({ postPage: page });
    }
    if (direction === 'previous') {
      page--;
      this.setState({ postPage: page });
    }
    fetch('http://localhost:8080/feed/posts?page=' + page, {
      headers: {
        Authorization: 'Bearer ' + this.props.token
      }
    })
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch posts.');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          posts: resData.posts.map(post => {
            return {
              ...post,
              imagePath: post.imageUrl
            };
          }),
          totalPosts: resData.totalItems,
          postsLoading: false
        });
      })
      .catch(this.catchError);
  };

  statusUpdateHandler = event => {
    event.preventDefault();
    fetch('URL')
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error("Can't update status!");
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
      })
      .catch(this.catchError);
  };

  newPostHandler = () => {
    this.setState({ isEditing: true });
  };

  startEditPostHandler = postId => {
    this.setState(prevState => {
      const loadedPost = { ...prevState.posts.find(p => p._id === postId) };

      return {
        isEditing: true,
        editPost: loadedPost
      };
    });
  };

  cancelEditHandler = () => {
    this.setState({ isEditing: false, editPost: null });
  };

  finishEditHandler = postData => {
    this.setState({
      editLoading: true
    });
    const formData = new FormData();
    formData.append('title', postData.title);
    formData.append('content', postData.content);
    formData.append('image', postData.image);
    let url = 'http://localhost:8080/feed/post';
    let method = 'POST';
    if (this.state.editPost) {
      url = 'http://localhost:8080/feed/post/' + this.state.editPost._id;
      method = 'PUT';
    }

    fetch(url, {
      method: method,
      body: formData,
      headers: {
        Authorization: 'Bearer ' + this.props.token
      }
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Creating or editing a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        const post = {
          _id: resData.post._id,
          title: resData.post.title,
          content: resData.post.content,
          creator: resData.post.creator,
          createdAt: resData.post.createdAt
        };
        this.setState(prevState => {
          let updatedPosts = [...prevState.posts];
          if (prevState.editPost) {
            const postIndex = prevState.posts.findIndex(
              p => p._id === prevState.editPost._id
            );
            updatedPosts[postIndex] = post;
          } else if (prevState.posts.length < 2) {
            updatedPosts = prevState.posts.concat(post);
          }
          return {
            posts: updatedPosts,
            isEditing: false,
            editPost: null,
            editLoading: false
          };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({
          isEditing: false,
          editPost: null,
          editLoading: false,
          error: err
        });
      });
  };

  statusInputChangeHandler = (input, value) => {
    this.setState({ status: value });
  };

  deletePostHandler = postId => {
    this.setState({ postsLoading: true });
    fetch('http://localhost:8080/feed/post/' + postId, {
      method: 'DELETE',
      headers: {
        Authorization: 'Bearer ' + this.props.token
      }
    })
      .then(res => {
        if (res.status !== 200 && res.status !== 201) {
          throw new Error('Deleting a post failed!');
        }
        return res.json();
      })
      .then(resData => {
        console.log(resData);
        this.setState(prevState => {
          const updatedPosts = prevState.posts.filter(p => p._id !== postId);
          return { posts: updatedPosts, postsLoading: false };
        });
      })
      .catch(err => {
        console.log(err);
        this.setState({ postsLoading: false });
      });
  };

  errorHandler = () => {
    this.setState({ error: null });
  };

  catchError = error => {
    this.setState({ error: error });
  };

  render() {
    return (
      <Fragment>
        <ErrorHandler error={this.state.error} onHandle={this.errorHandler} />
        <FeedEdit
          editing={this.state.isEditing}
          selectedPost={this.state.editPost}
          loading={this.state.editLoading}
          onCancelEdit={this.cancelEditHandler}
          onFinishEdit={this.finishEditHandler}
        />
        <section className="feed__status">
          <form onSubmit={this.statusUpdateHandler}>
            <Input
              type="text"
              placeholder="Your status"
              control="input"
              onChange={this.statusInputChangeHandler}
              value={this.state.status}
            />
            <Button mode="flat" type="submit">
              Update
            </Button>
          </form>
        </section>
        <section className="feed__control">
          <Button mode="raised" design="accent" onClick={this.newPostHandler}>
            New Post
          </Button>
        </section>
        <section className="feed">
          {this.state.postsLoading && (
            <div style={{ textAlign: 'center', marginTop: '2rem' }}>
              <Loader />
            </div>
          )}
          {this.state.posts.length <= 0 && !this.state.postsLoading ? (
            <p style={{ textAlign: 'center' }}>No posts found.</p>
          ) : null}
          {!this.state.postsLoading && (
            <Paginator
              onPrevious={this.loadPosts.bind(this, 'previous')}
              onNext={this.loadPosts.bind(this, 'next')}
              lastPage={Math.ceil(this.state.totalPosts / 2)}
              currentPage={this.state.postPage}
            >
              {this.state.posts.map(post => (
                <Post
                  key={post._id}
                  id={post._id}
                  author={post.creator}
                  date={new Date(post.createdAt).toLocaleDateString('en-US')}
                  title={post.title}
                  image={post.imageUrl}
                  content={post.content}
                  onStartEdit={this.startEditPostHandler.bind(this, post._id)}
                  onDelete={this.deletePostHandler.bind(this, post._id)}
                />
              ))}
            </Paginator>
          )}
        </section>
      </Fragment>
    );
  }
}

export default Feed;

```

```js
//./src/pages/Feed/SinglePost/SinglePost.js(f)

import React, { Component } from 'react';

import Image from '../../../components/Image/Image';
import './SinglePost.css';

class SinglePost extends Component {
  state = {
    title: '',
    author: '',
    date: '',
    image: '',
    content: ''
  };

  componentDidMount() {
    const postId = this.props.match.params.postId;
    fetch('http://localhost:8080/feed/post/' + postId, {
      headers: {
        Authorization: 'Bearer ' + this.props.token
      }
    })
      .then(res => {
        if (res.status !== 200) {
          throw new Error('Failed to fetch status');
        }
        return res.json();
      })
      .then(resData => {
        this.setState({
          title: resData.post.title,
          author: resData.post.creator.name,
          date: new Date(resData.post.createdAt).toLocaleDateString('en-US'),
          content: resData.post.content
        });
      })
      .catch(err => {
        console.log(err);
      });
  }

  render() {
    return (
      <section className="single-post">
        <h1>{this.state.title}</h1>
        <h2>
          Created by {this.state.author} on {this.state.date}
        </h2>
        <div className="single-post__image">
          <Image contain imageUrl={this.state.image} />
        </div>
        <p>{this.state.content}</p>
      </section>
    );
  }
}

export default SinglePost;

```

\* Chapter 389: Connecting Posts & Users
========================================

1\. update

- ./models/post.js(b)

- ./models/user.js(b)

- ./controllers/feed.js(b)

![](images/389-connecting-posts-and-users-1.png)

![](images/389-connecting-posts-and-users-2.png)

![](images/389-connecting-posts-and-users-3.png)

![](images/389-connecting-posts-and-users-4.png)![389-connecting-posts-and-users-1.png](resources/547947A33AB37C561313CA991BFB4553.png)![389-connecting-posts-and-users-2.png](resources/7885BEFCF33C0369D8C8ED7CAFEE9EB9.png)![389-connecting-posts-and-users-3.png](resources/9B687DF8F03E7A106FD81210903C05E3.png)![389-connecting-posts-and-users-4.png](resources/AFDADFE91C7695A22F4D45953C9888D9.png)

```js
//./models/post.js(b)

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const postSchema = new Schema(
  {
    title: {
      type: String,
      required: true
    },
    imageUrl: {
      type: String,
      required: true
    },
    content: {
      type: String,
      required: true
    },
    creator: {
      type: Schema.Types.ObjectId,
      ref: 'User',
      required: true
    }
  },
  { timestamps: true }
);

module.exports = mongoose.model('Post', postSchema);
```

```js
//./models/user.js(b)

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const userSchema = new Schema({
    email: {
        type: String,
        required: true
    },
    password: {
        type: String,
        required: true
    },
    name: {
        type: String,
        required: true
    },
    status: {
        type: String,
        default: 'I am new!'
    },
    /**we store the creator of a post in every post we create
     * and on the ./models/user.js(b) file,
     * we add the post to the list of posts for that user.
     * that means we now need to adjust our ./controllers/feed.js(b) file 
     * in the place where we create new posts.
    */
    posts: [{
        type: Schema.Types.ObjectId,
        ref: 'Post'
    }]
});

module.exports = mongoose.model('User', userSchema);
```

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');
const User = require('../models/user');

exports.getPosts = (req, res, next) => {
  const currentPage = req.query.page || 1;
  const perPage = 2;
  let totalItems;
  Post.find()
    .countDocuments()
    .then(count => {
      totalItems = count;
      return Post.find()
        .skip((currentPage - 1) * perPage)
        .limit(perPage)
    })
    .then(posts => {
      res
        .status(200)
        .json({
          message: 'Fetched posts successfully.',
          posts: posts,
          totalItems: totalItems
        });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }

  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  /**remember in my ./middleware/is-auth.js(b) file,
   * i store that in the request object,
   * 
   *    'req.userId = decodedToken.userId'
   * 
   * so we have that userId available here.
   * with that information,
   * i will set creator equal to 'req.userId'
   * that will be string not an objectId
   * but mongoose will take care about that and convert it.
   * so now we create a new post assigned to that user
   */
  
   let creator;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: req.userId
  });
  post
    .save()
    .then(result => {
      return User.findById(req.userId);
    })
    .then(user => {
      creator = user;
      user.posts.push(post);
      return user.save()
    })
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: post,
        creator: { _id: creator._id, name: creator.name }
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if(req.file) {
    imageUrl = req.file.path
  }
  if(!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if(imageUrl !== post.image) {
        clearImage(post.ImageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({message: 'Post updated!', post: result});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
  })
};

exports.deletePost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      //Check logged in user
      clearImage(post.imageUrl);
      return Post.findByIdAndRemove(postId);
    })
    .then(result => {
      console.log(result);
      res.status(200).json({message: 'Deleted post.'});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
}

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath)
  fs.unlink(filePath, err => console.log(err));
}

```

\* Chapter 390: Adding Authorization Checks
===========================================

1\. update

- ./controllers/feed.js(b)

![](images/390-adding-authorization-checks-1.png)

![](images/390-adding-authorization-checks-2.png)

![](images/390-adding-authorization-checks-3.png)

![](images/390-adding-authorization-checks-4.png)

![](images/390-adding-authorization-checks-5.png)![390-adding-authorization-checks-1.png](resources/C2230117130179A5FFDEF9F7391C2D31.png)![390-adding-authorization-checks-2.png](resources/7F9FB4E31B493466F4CD4DC9A307E3F4.png)![390-adding-authorization-checks-3.png](resources/60AB44EE43B4CDA5DDCA9227FCF5981D.png)![390-adding-authorization-checks-4.png](resources/6044E3077ADE1C31CC897D0410612FE0.png)![390-adding-authorization-checks-5.png](resources/6539C9DEC75FDF7EC2229BFC621CD2EF.png)

- let’s use an unused email address and it succeeds. 

![](images/390-adding-authorization-checks-6.png)

![](images/390-adding-authorization-checks-7.png)

![](images/390-adding-authorization-checks-8.png)

![](images/390-adding-authorization-checks-9.png)![390-adding-authorization-checks-6.png](resources/04590088F5DE5A48B22C765532412179.png)![390-adding-authorization-checks-7.png](resources/1D75E787149E2991E344166D2D28BCF3.png)![390-adding-authorization-checks-8.png](resources/1289350CE5B41788C4C276139D10F673.png)![390-adding-authorization-checks-9.png](resources/0D4D53FEDE2F43BF5891AF69A32B12A8.png)

- this failed with 403 error.

![](images/390-adding-authorization-checks-10.png)![390-adding-authorization-checks-10.png](resources/4FB9CCDE36CF002911250ED2F44ACA4D.png)

- let’s login with the user who did create it and let’s now try editing with this user and this now 

![](images/390-adding-authorization-checks-11.png)

![](images/390-adding-authorization-checks-12.png)![390-adding-authorization-checks-11.png](resources/3DD0418A729265604A595F939B8B95B6.png)![390-adding-authorization-checks-12.png](resources/4418ECF6E8D7E738F8FC444C58060C1D.png)

- and try editing and this now succeed. 

![](images/390-adding-authorization-checks-13.png)

![](images/390-adding-authorization-checks-14.png)![390-adding-authorization-checks-13.png](resources/CA479182CEDE98844D842076D961B401.png)![390-adding-authorization-checks-14.png](resources/C98DE089EBD2107B937CD054103C3607.png)

- delete this and it succeeds because this was the right user.

![](images/390-adding-authorization-checks-15.png)

![](images/390-adding-authorization-checks-16.png)![390-adding-authorization-checks-15.png](resources/1AA8750FFD25B4B5EB3CE6E16F8A3E4C.png)![390-adding-authorization-checks-16.png](resources/4F6CDF3B2398E99EAA07C62FC8FDD264.png)

- let’s logout and let’s login with this user.

![](images/390-adding-authorization-checks-17.png) 

![](images/390-adding-authorization-checks-18.png)![390-adding-authorization-checks-17.png](resources/A684A857DC85BEF053BD48A59C6A600D.png)![390-adding-authorization-checks-18.png](resources/71FE048E563DA0B9D90700C8178B75C4.png)

- and logout and login with other user who didn’t create post. 

![](images/390-adding-authorization-checks-19.png)

![](images/390-adding-authorization-checks-20.png)![390-adding-authorization-checks-19.png](resources/607C0AD16C42E61428949C344347DEC1.png)![390-adding-authorization-checks-20.png](resources/6061815069DADA1073A37BE6BE993D24.png)

- click delete and you can see fails.

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');
const User = require('../models/user');

exports.getPosts = (req, res, next) => {
  const currentPage = req.query.page || 1;
  const perPage = 2;
  let totalItems;
  Post.find()
    .countDocuments()
    .then(count => {
      totalItems = count;
      return Post.find()
        .skip((currentPage - 1) * perPage)
        .limit(perPage)
    })
    .then(posts => {
      res
        .status(200)
        .json({
          message: 'Fetched posts successfully.',
          posts: posts,
          totalItems: totalItems
        });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if(!req.file){
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }

  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  /**remember in my ./middleware/is-auth.js(b) file,
   * i store that in the request object,
   * 
   *    'req.userId = decodedToken.userId'
   * 
   * so we have that userId available here.
   * with that information,
   * i will set creator equal to 'req.userId'
   * that will be string not an objectId
   * but mongoose will take care about that and convert it.
   * so now we create a new post assigned to that user
   */
  
   let creator;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: req.userId
  });
  post
    .save()
    .then(result => {
      return User.findById(req.userId);
    })
    .then(user => {
      creator = user;
      user.posts.push(post);
      return user.save()
    })
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: post,
        creator: { _id: creator._id, name: creator.name }
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if(req.file) {
    imageUrl = req.file.path
  }
  if(!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if (post.creator.toString() !== req.userId){
        const error = new Error('Not authorized!');
        error.statusCode = 403;
        throw error;
      }
      if(imageUrl !== post.image) {
        clearImage(post.ImageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({message: 'Post updated!', post: result});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
  })
};

exports.deletePost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if (post.creator.toString() !== req.userId){
        const error = new Error('Not authorized!');
        error.statusCode = 403;
        throw error;
      }
      //Check logged in user
      clearImage(post.imageUrl);
      return Post.findByIdAndRemove(postId);
    })
    .then(result => {
      console.log(result);
      res.status(200).json({message: 'Deleted post.'});
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
}

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath)
  fs.unlink(filePath, err => console.log(err));
}

```

\* Chapter 391: Clearing Post-User Relations
============================================

1\. update

- ./controllers/feed.js(b)

![](images/391-clearing-post-user-relations-1.png)![391-clearing-post-user-relations-1.png](resources/B1E941458DB3F40920B541E7A1437F7D.png)

- if we refresh the post collection, we only have one item there,

![](images/391-clearing-post-user-relations-2.png)![391-clearing-post-user-relations-2.png](resources/960EB56A67048D6B0FA3F08F183C3C02.png)

- but if i have a look at my users collection, the first user has a couple of posts. and the 2nd user has so too. because we have no logic to clear posts when i delete them to clear relations and we should do that. 

![](images/391-clearing-post-user-relations-3.png)

![](images/391-clearing-post-user-relations-4.png)![391-clearing-post-user-relations-3.png](resources/E851C179BBDADFC7E87D077A14C644E8.png)![391-clearing-post-user-relations-4.png](resources/227950B1BB0ACED27BDA9BF406EDD459.png)

- let me get rid of all users manually by using mongodb compass. 

![](images/391-clearing-post-user-relations-5.png)

![](images/391-clearing-post-user-relations-6.png)

![](images/391-clearing-post-user-relations-7.png)![391-clearing-post-user-relations-5.png](resources/60A097E8A188759D3172A273882EEEAE.png)![391-clearing-post-user-relations-6.png](resources/4309EF003167AC76DC6C02F2665FE612.png)![391-clearing-post-user-relations-7.png](resources/98E1985F0A937A9996B07B357F99BBB7.png)

- also get rid of all posts and logout here. let’s create a new user because we cleared all users. 

![](images/391-clearing-post-user-relations-8.png)

![](images/391-clearing-post-user-relations-9.png)![391-clearing-post-user-relations-8.png](resources/B67EDCA4B01FA1B9EB72E1BFBE8CC5FD.png)![391-clearing-post-user-relations-9.png](resources/218C2D25EDBED10746D5EDA5A5EAF006.png)

- let’s login with that user and let’s create a new posts. 

![](images/391-clearing-post-user-relations-10.png)

![](images/391-clearing-post-user-relations-11.png)

![](images/391-clearing-post-user-relations-12.png)

![](images/391-clearing-post-user-relations-13.png)

![](images/391-clearing-post-user-relations-14.png)

![](images/391-clearing-post-user-relations-15.png)![391-clearing-post-user-relations-10.png](resources/3A206800EE8225D1EAFC3C39566219D9.png)![391-clearing-post-user-relations-11.png](resources/C794EA879F2562661EE38ECF3FBD27A5.png)![391-clearing-post-user-relations-12.png](resources/57F9DAEE103B53231AF22898D2CC96A2.png)![391-clearing-post-user-relations-13.png](resources/ECFB4389A4B5FBD6B7A5FB37B0763097.png)![391-clearing-post-user-relations-14.png](resources/AC6B29FEAC0B39FD3D7750857A7323F0.png)![391-clearing-post-user-relations-15.png](resources/265E3D0C23C82CD17A9C7A4B5A0B55C4.png)

- and in users, this array is now also empty.

```js
//./controllers/feed.js(b)

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');
const User = require('../models/user');

exports.getPosts = (req, res, next) => {
  const currentPage = req.query.page || 1;
  const perPage = 2;
  let totalItems;
  Post.find()
    .countDocuments()
    .then(count => {
      totalItems = count;
      return Post.find()
        .skip((currentPage - 1) * perPage)
        .limit(perPage);
    })
    .then(posts => {
      res.status(200).json({
        message: 'Fetched posts successfully.',
        posts: posts,
        totalItems: totalItems
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.createPost = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if (!req.file) {
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }
  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  let creator;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: req.userId
  });
  post
    .save()
    .then(result => {
      return User.findById(req.userId);
    })
    .then(user => {
      creator = user;
      user.posts.push(post);
      return user.save();
    })
    .then(result => {
      res.status(201).json({
        message: 'Post created successfully!',
        post: post,
        creator: { _id: creator._id, name: creator.name }
      });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.getPost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      res.status(200).json({ message: 'Post fetched.', post: post });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.updatePost = (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if (req.file) {
    imageUrl = req.file.path;
  }
  if (!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if (post.creator.toString() !== req.userId) {
        const error = new Error('Not authorized!');
        error.statusCode = 403;
        throw error;
      }
      if (imageUrl !== post.imageUrl) {
        clearImage(post.imageUrl);
      }
      post.title = title;
      post.imageUrl = imageUrl;
      post.content = content;
      return post.save();
    })
    .then(result => {
      res.status(200).json({ message: 'Post updated!', post: result });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

exports.deletePost = (req, res, next) => {
  const postId = req.params.postId;
  Post.findById(postId)
    .then(post => {
      if (!post) {
        const error = new Error('Could not find post.');
        error.statusCode = 404;
        throw error;
      }
      if (post.creator.toString() !== req.userId) {
        const error = new Error('Not authorized!');
        error.statusCode = 403;
        throw error;
      }
      // Check logged in user
      clearImage(post.imageUrl);
      return Post.findByIdAndRemove(postId);
    })
    .then(result => {
      return User.findById(req.userId);
    })
    .then(user => {
      user.posts.pull(postId);
      return user.save();
    })
    .then(result => {
      res.status(200).json({ message: 'Deleted post.' });
    })
    .catch(err => {
      if (!err.statusCode) {
        err.statusCode = 500;
      }
      next(err);
    });
};

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath);
  fs.unlink(filePath, err => console.log(err));
};

```

\* Chapter 392: Wrap Up
=======================

![](images/392-wrap-up-1.png)![392-wrap-up-1.png](resources/6E6FDFF9ACA31AD959CD116EDB6259B0.png)