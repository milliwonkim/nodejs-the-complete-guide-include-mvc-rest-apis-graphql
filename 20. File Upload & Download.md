\* Chapter 314: Module Introduction
===================================

![](images/314-module-introduction-1.png)

\* Chapter 315: Adding A File Picker To The Frontend
====================================================

1\. update

- ./views/admin/edit-product.ejs

- Adding file upload means that we have to do 2 things. first thing is that we need to adjust our form to show a file picker to our users. so a tool which they can use to select a file on their operating system on their computer. 

- 2nd part is that we need to be able to accept that file in the place where we handle it, where we handle the incoming requests. 

![](images/315-adding-a-file-picker-to-the-frontend-1.png)

- now we have our file picker here which is a default HTML element

```js
<!--./views/admin/edit-product.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/forms.css">
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
   <%- include('../includes/navigation.ejs') %>

    <main>
        <% if (errorMessage) { %>
            <div class="user-message user-message--error"><%= errorMessage %></div>
        <% } %>
        <form class="product-form" action="/admin/<% if (editing) { %>edit-product<% } else { %>add-product<% } %>" method="POST">
            <div class="form-control">
                <label for="title">Title</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'title') ? 'invalid' : '' %>"
                    type="text" 
                    name="title" 
                    id="title" 
                    value="<% if (editing || hasError) { %><%= product.title %><% } %>">
            </div>
            <!--
            <div class="form-control">
                <label for="imageUrl">Image URL</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'imageUrl') ? 'invalid' : '' %>"
                    type="text" 
                    name="imageUrl" 
                    id="imageUrl" 
                    value="<% if (editing || hasError) { %><%= product.imageUrl %><% } %>">
            </div>
            -->
            <div class="form-control">
                <label for="image">Image</label>
                <input 
                    type="file" 
                    name="image" 
                    id="image" >
            </div>
            <div class="form-control">
                <label for="price">Price</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'price') ? 'invalid' : '' %>"
                    type="number" 
                    name="price" 
                    id="price" 
                    step="0.01" 
                    value="<% if (editing || hasError) { %><%= product.price %><% } %>">
            </div>
            <div class="form-control">
                <label for="description">Description</label>
                <textarea 
                    class="<%= validationErrors.find(e => e.param === 'description') ? 'invalid' : '' %>"
                    name="description" 
                    id="description" 
                    rows="5"><% if (editing || hasError) { %><%= product.description %><% } %></textarea>
            </div>
            <% if (editing) { %>
                <input type="hidden" value="<%= product._id %>" name="productId">
            <% } %>

            <input type="hidden" name="_csrf" value="<%= csrfToken %>">
            <button class="btn" type="submit"><% if (editing) { %>Update Product<% } else { %>Add Product<% } %></button>
        </form>
    </main>
<%- include('../includes/end.ejs') %>
```

\* Chapter 316: Handling Multipart Form Data
============================================

1\. update

- ./controllers/admin.js

- ./routes/admin.js

- ./views/admin/edit-product.ejs

![](images/316-handling-multipart-form-data-1.png)

![](images/316-handling-multipart-form-data-2.png)

- the error we are getting is stemming from the fact that we are not able to extract our image correctly. 

![](images/316-handling-multipart-form-data-3.png)

- if i console log, you don’t see anything. because we failed to extract an image from the req.body. 

![](images/316-handling-multipart-form-data-4.png)

- because for extracting the content of our incoming requests, we set up a middleware in app.js, we are using a special middleware, ‘body-parser’ middleware and this middleware uses or exposes a couple of different parsers and we are using the ‘urlencoded’ parser. 

![](images/316-handling-multipart-form-data-5.png)

- urlencoded data is text data. so if a form is submitted without a file, just with text field, no matter if that text field then stores a number, a url or plain text but it’s all encoded in text when it’s submitted. this format is then called urlencoded. 

![](images/316-handling-multipart-form-data-6.png)

- we can see that the content type is application and then x-www-form-urlencoded. this means it tries to put all the data as text into its form body. 

- we can see that down there, just form data, title, price and so on and just image with nothing. this is invalid. this is an empty text because it can’t extract our file as text because a file is binary data. 

- because of that, failing extraction, we need to parse our data differently and the body parser that we are using doesn’t give us any parser, it doesn’t include any parser that handle file data as well. so we need a new package for that. 

![](images/316-handling-multipart-form-data-7.png)

- ’npm install —save multer’

- multer is another third party package that parses incoming requests. but this package parses incoming requests for files. so it’s able to handle file requests or requests with mixed data, with text and file data. 

- we will still keep body-parser because we still have like for example, our sign up form where we only submit urlencoded data but now we will have to use a different encoding and that starts with our form.

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.image;
  const price = req.body.price;
  const description = req.body.description;
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  const product = new Product({
    //_id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        imageUrl: updatedImageUrl,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');
const { body } = require('express-validator/check')

const adminController = require('../controllers/admin');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', isAuth, adminController.getAddProduct);

// /admin/products => GET
router.get('/products', isAuth, adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', [
        body('title').isString().isLength({ min: 3 }).trim(),
        body('price').isFloat(),
        body('description').isLength({ min: 5, max: 400 }).trim()
    ],
    isAuth,
    adminController.postAddProduct);

router.get('/edit-product/:productId', isAuth, adminController.getEditProduct);

router.post('/edit-product',[
        body('title').isString().isLength({ min: 3 }).trim(),
        body('imageUrl').isURL(),
        body('price').isFloat(),
        body('description').isLength({ min: 5, max: 400 }).trim()
    ],
    isAuth,
    adminController.postEditProduct);

router.post('/delete-product', isAuth, adminController.postDeleteProduct);

module.exports = router;
```

```js
<!--./views/admin/edit-product.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/forms.css">
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
   <%- include('../includes/navigation.ejs') %>

    <main>
        <% if (errorMessage) { %>
            <div class="user-message user-message--error"><%= errorMessage %></div>
        <% } %>
        <!--
            'enctype' field which i will set to multipart form data application
            x-www-form-url-encoded as the default
            but now we will switch to multipart form data which is the content-type
            telling the server that this submission and this request will not contain plaintext
            but will contain mixed data, text and binary data
            and multer will be looking for incoming requests,
            with this type of data 'multipart/form-data'
            and will then be able to parse both the text and our file
        -->
        <form class="product-form" action="/admin/<% if (editing) { %>edit-product<% } else { %>add-product<% } %>" method="POST" enctype="multipart/form-data">
            <div class="form-control">
                <label for="title">Title</label>
                <input
                    class="<%= validationErrors.find(e => e.param === 'title') ? 'invalid' : '' %>"
                    type="text"
                    name="title"
                    id="title"
                    value="<% if (editing || hasError) { %><%= product.title %><% } %>">
            </div>
            <!--
            <div class="form-control">
                <label for="imageUrl">Image URL</label>
                <input
                    class="<%= validationErrors.find(e => e.param === 'imageUrl') ? 'invalid' : '' %>"
                    type="text"
                    name="imageUrl"
                    id="imageUrl"
                    value="<% if (editing || hasError) { %><%= product.imageUrl %><% } %>">
            </div>
            -->
            <div class="form-control">
                <label for="image">Image</label>
                <input
                    type="file"
                    name="image"
                    id="image" >
            </div>
            <div class="form-control">
                <label for="price">Price</label>
                <input
                    class="<%= validationErrors.find(e => e.param === 'price') ? 'invalid' : '' %>"
                    type="number"
                    name="price"
                    id="price"
                    step="0.01"
                    value="<% if (editing || hasError) { %><%= product.price %><% } %>">
            </div>
            <div class="form-control">
                <label for="description">Description</label>
                <textarea
                    class="<%= validationErrors.find(e => e.param === 'description') ? 'invalid' : '' %>"
                    name="description"
                    id="description"
                    rows="5"><% if (editing || hasError) { %><%= product.description %><% } %></textarea>
            </div>
            <% if (editing) { %>
                <input type="hidden" value="<%= product._id %>" name="productId">
            <% } %>

            <input type="hidden" name="_csrf" value="<%= csrfToken %>">
            <button class="btn" type="submit"><% if (editing) { %>Update Product<% } else { %>Add Product<% } %></button>
        </form>
    </main>
<%- include('../includes/end.ejs') %>
```

\* Chapter 317: Handling File Uploads With Multer
=================================================

1\. update

- app.js

- ./controllers/admin.js

![](images/317-handling-file-uploads-with-multer-1.png)

![](images/317-handling-file-uploads-with-multer-2.png)

![](images/317-handling-file-uploads-with-multer-3.png)

- what we see is that multer seems to have done something. it seems to have stored something in that file property on our request object. 

- it stored the name of the field where it extracted that, it detected the file name, it detected the mimetype and the buffer which is how node handles the binary data. this is the result of the streamed data, the file was sent to our server as a stream or was handled as a stream to handle it if it was bigger and then this is the collected data in a buffer like a bus stop. it gives you a way of working with the stream data in this case it’s the combined stream and data. and we work with the buffer to turn it into a file. 

![](images/317-handling-file-uploads-with-multer-4.png)

![](images/317-handling-file-uploads-with-multer-5.png)

- we don’t have the buffer because now multer is able to do something with the buffer, instead of just buffering it all in memory. it can turn that buffer back into binary data 

![](images/317-handling-file-uploads-with-multer-6.png)

- and it stores it in this path here. 

![](images/317-handling-file-uploads-with-multer-7.png)

- and now if you have a look at your folder, you should not have an images folder with some file in there. 

- now that file has some random hash name, doesn’t have a file extension and isn’t recognized as an image. 

![](images/317-handling-file-uploads-with-multer-8.png)

![](images/317-handling-file-uploads-with-multer-9.png)

![](images/317-handling-file-uploads-with-multer-10.png)

- but if i change that and i add ‘.png’ in the end, this is the image i uploaded. so this works.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer')

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

/**'multer' is some middleware
 * which we execute on every incoming requests
 * and it then has a look at that request
 * and see if it's multipart form data
 * and tries to extract file if that is the case. 
*/
app.use(bodyParser.urlencoded({ extended: false }));
/**i'm choosing 'image' here
 * because in ./views/admin/edit-product.ejs file,
 * this input name in file picker is named image
 * 
 * 'dest: 'images' or 'dest: '/images' will add a product
 * and 
 */
app.use(multer({dest: 'images'}).single('image'))
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use((req, res, next) => {
  //throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err))
    });
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  //res.redirect('/500')
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const image = req.file;
  const price = req.body.price;
  const description = req.body.description;
  console.log(imageUrl)
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  const product = new Product({
    //_id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        imageUrl: updatedImageUrl,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

\* Chapter 318: Configuring Multer To Adjust Filename & Filepath
================================================================

1\. update

- app.js

![](images/318-configuring-multer-to-adjust-filename-and-filepath-1.png)

![](images/318-configuring-multer-to-adjust-filename-and-filepath-2.png)

![](images/318-configuring-multer-to-adjust-filename-and-filepath-3.png)

![](images/318-configuring-multer-to-adjust-filename-and-filepath-4.png)

- you will see that in those images folder, you have undefined-boat.png instead of that random hash because since we did set our own filename with this function. multer doesn’t genearte that hash. 

![](images/318-configuring-multer-to-adjust-filename-and-filepath-5.png)

- ’new Date().toISOString()’ gives us a snapshop of the current date and that should also ensure uniqueness

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer')

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();
/**'idskStorage()' is a storage engine
 * which you can use with multer 
 * and pass the javascript object to configure that.
 * 
 * these are 2 functions 
 * which multer will call for an incoming file
 * these function then control how that file is handled
 * regarding the place where you store it and regarding the naming
 */
const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    /**the first argument is 'null' 
     * which would be error message you throw to inform mulber
     * that something is wrong with that incoming file it should not store it
     * but if that is null, you tell multer that it's OK to store it
     * 
     * the 2nd argument is the place 
     * where you wanna store.
     */
    cb(null, 'images')
  },
  /**'filename' is a function 
   *  
   * and we can extract file
   * and then there is an 'originalname' object
   * which holds the original file name
   * there's also is a file name object
   * which holds this random hash. 
   * 
   * if we have 2 images with the same name,
   * they don't overwrite each other
   * so i will use that 'file.filename'
   * which is auto-generated by multer
   * and i will concatenate it
   * with a dash in-between with the originalname
   * and i also ensure that i end with the extension
   * and i set my own filename by calling that callback. 
   */
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname)
  }
})

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
/**we can set the 'storage' key
 * which gives us way more configuration options thatn just the 'dest' option
 * 
 * now we need to inform multer
 * that we wanna use this storage engine
 * and we we do this by setting 'fileStorage' as a value for the storage key in the multer options
 */
app.use(multer({ storage: fileStorage }).single('image'))
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use((req, res, next) => {
  //throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err))
    });
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  //res.redirect('/500')
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 319: Filtering Files By Mimetype
===========================================

1\. update

- app.js

![](images/319-filtering-files-by-mimetype-1.png)

![](images/319-filtering-files-by-mimetype-2.png)

![](images/319-filtering-files-by-mimetype-3.png)

- if i submit a form with ‘boat.png’, i succeed, i get an error but i succeed. because i stores the file 

![](images/319-filtering-files-by-mimetype-4.png)

![](images/319-filtering-files-by-mimetype-5.png)

![](images/319-filtering-files-by-mimetype-6.png)

- but if i try to submit a different value like pdf file, you can see i only get undefined 

![](images/319-filtering-files-by-mimetype-7.png)

- and that undefined is stemming from my ./controllers/admin.js file

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer')

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();
const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images')
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname)
  }
})

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' || 
    file.mimetype === 'image/jpg' || 
    file.mimetype === 'image/jpeg'
    ) {
    /**'null' as an error
     * and true if we wanna accept that file it should be stored
     * so false if we don't wanna accept and store that file.
     */
    cb(null, true)
  } else {
    cb(null, false)
  }
}

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(multer({ storage: fileStorage, fileFilter }).single('image'))
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use((req, res, next) => {
  //throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err))
    });
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  //res.redirect('/500')
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 320: Storing File Data In The Database
=================================================

1\. update

- ./controllers/admin.js

- ./routes/admin.js

![](images/320-storing-file-data-in-the-database-1.png)

- i’m gonna remove all these products in database.

![](images/320-storing-file-data-in-the-database-2.png)

- first of all, image will be an object of this format with information about the file and where it was stored. so where the physical file can be found and i wanna save that. 

![](images/320-storing-file-data-in-the-database-3.png)

![](images/320-storing-file-data-in-the-database-4.png)

—————————————————————————

![](images/320-storing-file-data-in-the-database-5.png)

![](images/320-storing-file-data-in-the-database-6.png)

- if i upload an image, i succeed

![](images/320-storing-file-data-in-the-database-7.png)

![](images/320-storing-file-data-in-the-database-8.png)

- but if i upload pdf file, then i get ‘attached file is not a image’

- you should not store data like this in the database, file should not be stored in a database. they are too big. 

- you need to store the path to the file. that is something you can construct with the information given to you in the file object and you can then pass that data to the database. 

![](images/320-storing-file-data-in-the-database-9.png)

![](images/320-storing-file-data-in-the-database-10.png)

- if i save valid image and this works. saving does work.

![](images/320-storing-file-data-in-the-database-11.png)

- if you look into my database for the products, you see this is the part that was stored. 

![](images/320-storing-file-data-in-the-database-12.png)

- but if we inspect this, we see the image is not rendered because it can't find this. 

![](images/320-storing-file-data-in-the-database-13.png)

![](images/320-storing-file-data-in-the-database-14.png)

- i wanna have a behavior where if we choose 'no file' here, we keep the old one and we only overwrite it with a new file if i choose new one here.

![](images/320-storing-file-data-in-the-database-15.png)

![](images/320-storing-file-data-in-the-database-16.png)

![](images/320-storing-file-data-in-the-database-17.png)

![](images/320-storing-file-data-in-the-database-18.png)

- if i go to my database, that imageUrl didn’t change. 

![](images/320-storing-file-data-in-the-database-19.png)

![](images/320-storing-file-data-in-the-database-20.png)

![](images/320-storing-file-data-in-the-database-21.png)

- but if i select boat-2.png which is same image but a different file name, different file, i update this, and if we go to database, we see it set boat-2

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const image = req.file;
  const price = req.body.price;
  const description = req.body.description;
  /**if image is undefined,
   * then that means that multer declined the incoming file
   * 
   * if it is undefined,
   * then i wanna return a response with status 422
   * because i have an invalid input
   * so i wwanna return that response.
   */
  if (!image) {
    res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        price: price,
        description: description
      },
      errorMessage: 'Attached file is not an image',
      validationErrors: []
    });
  }
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }
  /**if we made it after our entire validation,
   * i have a valid file and valid input data
   * 
   * i will use my 'image' data which is that file object we get from multer
   * and there we have information like the file 'path'. 
   * this is the 'path' that a file on my operating system
   * so this is the path i wanna use later on when fetching that image.
   * so this is the path i will store in the imageUrl
   * and i can store imageUrl in the database again.
   */
  const imageUrl = image.path

  const product = new Product({
    //_id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  /**if 'image' is undefined,
   * i know that no file was saved.
   * and this means i wanna keep the old file,
   * by the way same will be true
   * if i upload a pdf.
   * so we don't need to throw an error message or error
   * 
   */
  const image = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        /**we don't need 'imageUrl: updatedImageUrl'
         * because we don't render image in page anymore.
         */
        title: updatedTitle,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      if (image) {
        /**this is the same logic as i have it in postAddProduct */
        product.imageUrl = updatedImageUrl;
      }
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');
const { body } = require('express-validator/check')

const adminController = require('../controllers/admin');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', isAuth, adminController.getAddProduct);

// /admin/products => GET
router.get('/products', isAuth, adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', [
        body('title').isString().isLength({ min: 3 }).trim(),
        body('price').isFloat(),
        body('description').isLength({ min: 5, max: 400 }).trim()
    ],
    isAuth,
    adminController.postAddProduct);

router.get('/edit-product/:productId', isAuth, adminController.getEditProduct);

router.post('/edit-product',[
        body('title').isString().isLength({ min: 3 }).trim(),
        body('price').isFloat(),
        body('description').isLength({ min: 5, max: 400 }).trim()
    ],
    isAuth,
    adminController.postEditProduct);

router.post('/delete-product', isAuth, adminController.postDeleteProduct);

module.exports = router;
```

\* Chapter 322: Serving Images Statically
=========================================

1\. update

- app.js

- ./views/admin/products.ejs

- ./views/shop/index.ejs

- ./views/shop/product-list.ejs

- ./views/shop/product-detail.ejs

![](images/322-serving-images-statically-1.png)

![](images/322-serving-images-statically-2.png)

- we got multiple options for serving files. option 1 is we serve our images folder in a static way which means that we are serving a public folder with the express.static middleware. and we can serve more than one folder statically. 

- 'statically serving a folder’ means that requests to files in that folder will be handled automatically and the files will be returned so all the heavy lifting is done behind the scenes by express. 

![](images/322-serving-images-statically-3.png)

- and now also serve the images folder just like this.

————————

![](images/322-serving-images-statically-4.png)

- we point to a folder like 'public' and ‘images' and we tell express serve the files from inside that folder as if they were on the root folder.

![](images/322-serving-images-statically-5.png)

- so we would copy that URL and open new tab and paste it on the URL. 

![](images/322-serving-images-statically-6.png)

![](images/322-serving-images-statically-7.png)

- and if we remove ‘images’ in URL, the reason for that is that express assumes that the files in the images folder are served as if they are in the root folder. so ‘/‘ slash nothing. 

![](images/322-serving-images-statically-8.png)

- so if we save and we reload, we see our image here. 

————————————————

![](images/322-serving-images-statically-9.png)

![](images/322-serving-images-statically-10.png)

- now i wanna do something differently. i have an order and i wanna download an invoice for that order. and that will now work differently because invoices will not be public files that everyone should be able to access. i wanna be able to access my invoice. but no one else should be.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer')

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();
const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images')
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname)
  }
})

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' || 
    file.mimetype === 'image/jpg' || 
    file.mimetype === 'image/jpeg'
    ) {
    cb(null, true)
  } else {
    cb(null, false)
  }
}

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(multer({ storage: fileStorage, fileFilter }).single('image'))
/**we point to a folder like 'public' and 'images'
 * and we tell express serve the files from inside that folder
 * as if they were on the root folder.
 * 
 * and if we remove ‘images’ in URL, 
 * the reason for that is that express assumes that 
 * the files in the images folder are served 
 * as if they are in the root folder. so ‘/‘ slash nothing. 
 * 
 * so we can adjust our middleware
 * and if we have a request that goes to '/images'
 * that start with '/images'
 * then serve these files statically
 * and now '/images' is the folder we assume for this static serving
 */
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use((req, res, next) => {
  //throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err))
    });
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  //res.redirect('/500')
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

```js
<!--./views/shop/index.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
    <%- include('../includes/navigation.ejs') %>

    <main>
        <% if (prods.length > 0) { %>
            <div class="grid">
                <% for (let product of prods) { %>
                    <article class="card product-item">
                        <header class="card__header">
                            <h1 class="product__title"><%= product.title %></h1>
                        </header>
                        <div class="card__image">
                            <img src="/<%= product.imageUrl %>"
                                alt="<%= product.title %>">
                        </div>
                        <div class="card__content">
                            <h2 class="product__price">$<%= product.price %></h2>
                            <p class="product__description"><%= product.description %></p>
                        </div>
                        <div class="card__actions">
                            <a href="/products/<%= product._id %>" class="btn">Details</a>
                            <% if (isAuthenticated) { %>
                                <%- include('../includes/add-to-cart.ejs', {product: product}) %>
                            <% } %>
                        </div>
                    </article>
                <% } %>
            </div>
        <% } else { %>
            <h1>No Products Found!</h1>
        <% } %>
    </main>
<%- include('../includes/end.ejs') %>
```

```js
<!--./views/shop/product-list.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>

            <main>
                <% if (prods.length > 0) { %>
                    <div class="grid">
                        <% for (let product of prods) { %>
                            <article class="card product-item">
                                <header class="card__header">
                                    <h1 class="product__title">
                                        <%= product.title %>
                                    </h1>
                                </header>
                                <div class="card__image">
                                    <img src="/<%= product.imageUrl %>" alt="<%= product.title %>">
                                </div>
                                <div class="card__content">
                                    <h2 class="product__price">$
                                        <%= product.price %>
                                    </h2>
                                    <p class="product__description">
                                        <%= product.description %>
                                    </p>
                                </div>
                                <div class="card__actions">
                                    <a href="/products/<%= product._id %>" class="btn">Details</a>
                                    <% if (isAuthenticated) { %>
                                        <%- include('../includes/add-to-cart.ejs', {product: product}) %>
                                    <% } %>
                                </div>
                            </article>
                            <% } %>
                    </div>
                    <% } else { %>
                        <h1>No Products Found!</h1>
                        <% } %>
            </main>
            <%- include('../includes/end.ejs') %>
```

```js
<!--./views/shop/product-detail.ejs-->

<%- include('../includes/head.ejs') %>
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>
        <main class="centered">
            <h1><%= product.title %></h1>
            <hr>
            <div class="image">
                <img src="/<%= product.imageUrl %>" alt="<%= product.title %>">
            </div>
            <h2><%= product.price %></h2>
            <p><%= product.description %></p>
            <% if (isAuthenticated) { %>
                <%- include('../includes/add-to-cart.ejs', {product: product}) %>
            <% } %>
        </main>
        <%- include('../includes/end.ejs') %>
```

```js
<!--./views/admin/products.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>

            <main>
                <% if (prods.length > 0) { %>
                    <div class="grid">
                        <% for (let product of prods) { %>
                            <article class="card product-item">
                                <header class="card__header">
                                    <h1 class="product__title">
                                        <%= product.title %>
                                    </h1>
                                </header>
                                <div class="card__image">
                                    <!--
                                        we need to add a slash at the beginning
                                        which will turn this into an absolute path
                                        it will not append it to the current path
                                        but rather create a new path with only our domain
                                        and then the path which get rendered here
                                        and i do this in products. 
                                    -->
                                    <img src="/<%= product.imageUrl %>" alt="<%= product.title %>">
                                </div>
                                <div class="card__content">
                                    <h2 class="product__price">$
                                        <%= product.price %>
                                    </h2>
                                    <p class="product__description">
                                        <%= product.description %>
                                    </p>
                                </div>
                                <div class="card__actions">
                                    <a href="/admin/edit-product/<%= product._id %>?edit=true" class="btn">Edit</a>
                                    <form action="/admin/delete-product" method="POST">
                                        <input type="hidden" value="<%= product._id %>" name="productId">
                                        <input type="hidden" name="_csrf" value="<%= csrfToken %>">
                                        <button class="btn" type="submit">Delete</button>
                                    </form>

                                </div>
                            </article>
                            <% } %>
                    </div>
                    <% } else { %>
                        <h1>No Products Found!</h1>
                        <% } %>
            </main>
            <%- include('../includes/end.ejs') %>
```

\* Chapter 323: Downloading Files With Authentication
=====================================================

1\. update

- ./views/shop/orders.ejs

- ./routes/shop.js

- ./controllers/shop.js

![](images/323-downloading-files-with-authentication-1.png)

![](images/323-downloading-files-with-authentication-2.png)

![](images/323-downloading-files-with-authentication-3.png)

![](images/323-downloading-files-with-authentication-4.png)

- grab that latest object’s \_id in orders collection, and paste it to the invoice.pdf title name like 'invoice-5ccec2e256bcaa07fd3631f0.pdf’

![](images/323-downloading-files-with-authentication-5.png)

![](images/323-downloading-files-with-authentication-6.png)

![](images/323-downloading-files-with-authentication-7.png)

- if i click ‘invoice’ anchor tag, and i get my download option here, let me save that and try to open that file. it should open as a PDF or you should be able to open it as a PDF but it was not the most convenient way of downloading this.

```js
<!--./views/shop/orders.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/orders.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>
        <main>
            <% if (orders.length <= 0) { %>
                <h1>Nothing there!</h1>
            <% } else { %>
                <ul class="orders">
                    <% orders.forEach(order => { %>
                        <li class="orders__item">
                            <h1>Order - # <%= order._id %></h1>
                            <ul class="orders__products">
                                <% order.products.forEach(p => { %>
                                    <li class="orders__products-item"><%= p.product.title %> (<%= p.quantity %>) - <a href="/orders/<%= order._id %>">Invoice</a></li>
                                <% }); %>
                            </ul>
                        </li>
                    <% }); %>
                </ul>
            <% } %>
        </main>
        <%- include('../includes/end.ejs') %>
```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);

router.get('/cart', isAuth, shopController.getCart);

router.post('/cart', isAuth, shopController.postCart);

router.post('/cart-delete-item', isAuth, shopController.postCartDeleteProduct);

router.post('/create-order', isAuth, shopController.postOrder);

router.get('/orders', isAuth, shopController.getOrders);

router.get('/orders/:orderId', isAuth, shopController.getInvoice)

module.exports = router;
```

```js
//./controllers/shop.js

const fs = require('fs')
const path = require('path')

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    })
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getInvoice = (req, res, next) => {
  /**request and encoded in the url
   * so it's params and then orderId
   *
   * that is specified in ./routes/shop.js
   *
   * and now we need to retrieve that file
   * and we can retrieve files with nodes file system.
   * now the path should be constructed with the path core module
   * so that it works on all operating system
   */
  const orderId = req.params.orderId
  const invoiceName = 'invoice-' + orderId + '.pdf'
  const invoicePath = path.join('data', 'invoices', invoiceName)
  fs.readFile(invoicePath, (err, data) => {
    if (err) {
      return next(err)
    }
    res.send(data)
  })
}
```

\* Chapter 324: Setting File Type Headers
=========================================

1\. update

- ./controllers/shop.js

![](images/324-setting-file-type-headers-1.png)

![](images/324-setting-file-type-headers-2.png)

- if i click this ‘invoice’ button, now i open it in the browser. so this already changes the behavior. it already gives the browser some information which allows the browser to handle this in a better way. 

![](images/324-setting-file-type-headers-3.png)

![](images/324-setting-file-type-headers-4.png)

———————————————————————

![](images/324-setting-file-type-headers-5.png)

![](images/324-setting-file-type-headers-6.png)

![](images/324-setting-file-type-headers-7.png)

- and if i save it and click ‘invoice’ button, the download menu opens again. and we have the proper file name with the proper extension. this is how you can control how the browser should handle the incoming data. 

![](images/324-setting-file-type-headers-8.png)

- now i have a set up where only authenticated users can requests this invoice. we can still improve that.

```js
//./controllers/shop.js

const fs = require('fs')
const path = require('path')

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    })
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId
  const invoiceName = 'invoice-' + orderId + '.pdf'
  const invoicePath = path.join('data', 'invoices', invoiceName)
  fs.readFile(invoicePath, (err, data) => {
    if (err) {
      return next(err)
    }
    res.setHeader('Content-Type', 'application/pdf')
    /**'Content-Disposition' allows us to define how this content should be served to the client.
     * and we can set this to 'inline' to tell the browser to open it inline.
     * 
     * and we can also add filename
     */
    res.setHeader('Content-Disposition', 'inline; filename="' + invoiceName + '"' )
    res.send(data)
  })
}
```

\* Chapter 325: Restricting File Access
=======================================

1\. update

- ./controllers/shop.js

![](images/325-restricting-file-access-1.png)

![](images/325-restricting-file-access-2.png)

- it works

![](images/325-restricting-file-access-3.png)

- and if i change 3 here to 2 in the URL, then i get my error because it’s an invalid URL

![](images/325-restricting-file-access-4.png)

![](images/325-restricting-file-access-5.png)

![](images/325-restricting-file-access-6.png)

- and if i logout and try to access this and access the original URL, i can’t see that.

![](images/325-restricting-file-access-7.png)

![](images/325-restricting-file-access-8.png)

- if i log in with the different user, and i try to access the original order before, i can’t access that. i get error.

```js
//./controllers/shop.js

const fs = require('fs');
const path = require('path');

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId;
  Order.findById(orderId)
    .then(order => {
      if (!order) {
        return next(new Error('No order found.'));
      }
      if (order.user.userId.toString() !== req.user._id.toString()) {
        return next(new Error('Unauthorized'));
      }
      const invoiceName = 'invoice-' + orderId + '.pdf';
      const invoicePath = path.join('data', 'invoices', invoiceName);
      fs.readFile(invoicePath, (err, data) => {
        if (err) {
          return next(err);
        }
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader(
          'Content-Disposition',
          'inline; filename="' + invoiceName + '"'
        );
        res.send(data);
      });
    })
    .catch(err => next(err));
};

```

\* Chapter 326: Streaming Data Vs Preloading Data
=================================================

1\. update

- ./controllers/shop.js

![](images/326-streaming-data-vs-preloading-data-1.png)

![](images/326-streaming-data-vs-preloading-data-2.png)

- this is streaned data created with that 'createReadStream()’ which is the recommanded way of getting your file data for bigger files.

```js
//./controllers/shop.js

const fs = require('fs');
const path = require('path');

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId;
  Order.findById(orderId)
    .then(order => {
      if (!order) {
        return next(new Error('No order found.'));
      }
      if (order.user.userId.toString() !== req.user._id.toString()) {
        return next(new Error('Unauthorized'));
      }
      const invoiceName = 'invoice-' + orderId + '.pdf';
      const invoicePath = path.join('data', 'invoices', invoiceName);
      /**if you read a file like this,
       * node will fisrt of all access that file,
       * read the entire content into memory
       * and then return it with the response. 
       * 
       * this means that for bigger files, 
       * this will take very long before a response is sent
       * and your memory on the server might overflow at some point for many incoming requests
       * because it has to read all the data into memory which is limited.
       * 
       * instead you should be streaming your response data
       */

      //fs.readFile(invoicePath, (err, data) => {
      //  if (err) {
      //    return next(err);
      //  }
      //  res.setHeader('Content-Type', 'application/pdf');
      //  res.setHeader(
      //    'Content-Disposition',
      //    'inline; filename="' + invoiceName + '"'
      //  );
      //  res.send(data);
      //});

      const file = fs.createReadStream(invoicePath)
        res.setHeader('Content-Type', 'application/pdf');
        res.setHeader(
          'Content-Disposition',
          'inline; filename="' + invoiceName + '"'
        )
        /**and call the 'pipe()' method to forward the data 
         * that is read in with that stream to my response
         * because the response object is a writable stream.
         * and you can use readable streams to pipe their output into a writable stream.
         * 
         * we can pipe our readable stream
         * the file stream into the response
         * and that means that the response will be streamed to the browser
         * and will contain the data
         * and the data will be downloaded by the browser step by step.
         * 
         * this is huge advantage for big file
         * because node never has to pre-load all the data into memory
         * but just streams it to the the client on the fly.
         * and the most it has to store is one chunk of data. 
         * 
         * the chunks are what we work with
         * the buffers gives us access to these chunks. 
         * 
         * we don't wait for all the chunks to come together
         * and concatenate them into one object,
         * instead we forward them to the browser
         * which is able to concatenate the incoming data pieces into the final file.
         */
        file.pipe(res)
    })
    .catch(err => next(err));
};

```

\* Chapter 327: Using PDFKit For .pdf Generation
================================================

1\. update

- ./controllers/shop.js

![](images/327-using-pdfkit-for-pdf-generation-1.png)

![](images/327-using-pdfkit-for-pdf-generation-2.png)

- delete my invoice.pdf file in ./invoice folder. but instead when we get the invoice for an order, i don’t wanna serve a file that already exists. but i wanna generate that file based on the real order data. 

![](images/327-using-pdfkit-for-pdf-generation-3.png)

- ‘PDFKit’ is the 3rd party package which we can use and is very prominet or popular package for creating pdfs on a node.js server. 

![](images/327-using-pdfkit-for-pdf-generation-4.png)

![](images/327-using-pdfkit-for-pdf-generation-5.png)

![](images/327-using-pdfkit-for-pdf-generation-6.png)

![](images/327-using-pdfkit-for-pdf-generation-7.png)

```js
//./controllers/shop.js

const fs = require('fs');
const path = require('path');

const PDFDocument= require('pdfkit')

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId;
  Order.findById(orderId)
    .then(order => {
      if (!order) {
        return next(new Error('No order found.'));
      }
      if (order.user.userId.toString() !== req.user._id.toString()) {
        return next(new Error('Unauthorized'));
      }
      const invoiceName = 'invoice-' + orderId + '.pdf';
      const invoicePath = path.join('data', 'invoices', invoiceName);

      const pdfDoc = new PDFDocument()
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader(
        'Content-Disposition',
        'inline; filename="' + invoiceName + '"'
      )
      /**this ensure that the pdf we generate also gets stored on the server
       * and not just serve to the client.
       * 
       * and when you call 'end()',
       * these writable streams for creating the file and for sending the response
       * will be closed. so file will be saved 
       * and the response will be sent.
       */
      pdfDoc.pipe(fs.createWriteStream(invoicePath))
      pdfDoc.pipe(res)

      /**'text()' allows us to ad a single line of text into the PDFDocumet
       * and you have to call pdfDoc to tell node
       * when you are done writing to that stream
       * because you have to be done at some point. 
       */
      pdfDoc.text('Hello World!')

      pdfDoc.end()
      //fs.readFile(invoicePath, (err, data) => {
      //  if (err) {
      //    return next(err);
      //  }
      //  res.setHeader('Content-Type', 'application/pdf');
      //  res.setHeader(
      //    'Content-Disposition',
      //    'inline; filename="' + invoiceName + '"'
      //  );
      //  res.send(data);
      //});

      //const file = fs.createReadStream(invoicePath)
      //file.pipe(res)
    })
    .catch(err => next(err));
};

```

\* Chapter 328: Generating .pdf Files With Order Data
=====================================================

1\. update

- ./controllers/shop.js

![](images/328-generating-pdf-files-with-order-data-1.png)

![](images/328-generating-pdf-files-with-order-data-2.png)

![](images/328-generating-pdf-files-with-order-data-3.png)

![](images/328-generating-pdf-files-with-order-data-4.png)

![](images/328-generating-pdf-files-with-order-data-5.png)

![](images/328-generating-pdf-files-with-order-data-6.png)

![](images/328-generating-pdf-files-with-order-data-7.png)

![](images/328-generating-pdf-files-with-order-data-8.png)

![](images/328-generating-pdf-files-with-order-data-9.png)

![](images/328-generating-pdf-files-with-order-data-10.png)

![](images/328-generating-pdf-files-with-order-data-11.png)

![](images/328-generating-pdf-files-with-order-data-12.png)

```js
//./controllers/shop.js

const fs = require('fs');
const path = require('path');

const PDFDocument= require('pdfkit')

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId;
  Order.findById(orderId)
    .then(order => {
      if (!order) {
        return next(new Error('No order found.'));
      }
      if (order.user.userId.toString() !== req.user._id.toString()) {
        return next(new Error('Unauthorized'));
      }
      const invoiceName = 'invoice-' + orderId + '.pdf';
      const invoicePath = path.join('data', 'invoices', invoiceName);

      const pdfDoc = new PDFDocument()
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader(
        'Content-Disposition',
        'inline; filename="' + invoiceName + '"'
      )
      pdfDoc.pipe(fs.createWriteStream(invoicePath))
      pdfDoc.pipe(res)

      pdfDoc.fontSize(26).text('Invoice', {
        underline: true
      })

      pdfDoc.text('----------------------')
      let totalPrice = 0
      /**'products' is an array
       * because we store this products in a database as an array.
       */
      order.products.forEach(prod => {
        totalPrice += prod.quantity * prod.product.price
        pdfDoc
          .fontSize(14)
          .text(
            prod.product.title +
            ' - ' +
            prod.quantity +
            ' x ' +
            '$' +
            prod.product.price)
      })
      pdfDoc.text('---')
      pdfDoc.fontSize(20).text('Total Price: $' + totalPrice)

      pdfDoc.end()
      //fs.readFile(invoicePath, (err, data) => {
      //  if (err) {
      //    return next(err);
      //  }
      //  res.setHeader('Content-Type', 'application/pdf');
      //  res.setHeader(
      //    'Content-Disposition',
      //    'inline; filename="' + invoiceName + '"'
      //  );
      //  res.send(data);
      //});

      //const file = fs.createReadStream(invoicePath)
      //file.pipe(res)
    })
    .catch(err => next(err));
};

```

\* Chapter 329: Deleting Files 
===============================

1\. update

- ./util/file.js

- ./controllers/admin.js

![](images/329-deleting-files-1.png)

![](images/329-deleting-files-2.png)

- i delete prod1, and in the images folder, one image connected to prod1 is removed. 

![](images/329-deleting-files-3.png)

![](images/329-deleting-files-4.png)

![](images/329-deleting-files-5.png)

![](images/329-deleting-files-6.png)

——————————————

![](images/329-deleting-files-7.png)

![](images/329-deleting-files-8.png)

- fetching my invoice or generating it on the fly works. thanks to the fact that we store a snapshot of that in the database, it even works after the product was deleted.

```js
//./util/file.js

const fs = require('fs')

const deleteFile = (filePath) => {
    /**'unlink()' method deletes the name and file
     * that is connected to the name,
     * so it deletes a file at this path.
     */
    fs.unlink(filePath, (err) => {
        if (err) {
            throw (err)
        }
    })
}

exports.deleteFile = deleteFile
```

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const fileHelper = require('../util/file')

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const image = req.file;
  const price = req.body.price;
  const description = req.body.description;
  if (!image) {
    res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        price: price,
        description: description
      },
      errorMessage: 'Attached file is not an image',
      validationErrors: []
    });
  }
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }
  const imageUrl = image.path

  const product = new Product({
    //_id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const image = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      if (image) {
        fileHelper.deleteFile(product.imageUrl)
        product.imageUrl = updatedImageUrl;
      }
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return next(new Error('Product not found'))
      }
      fileHelper.deleteFile(product.imageUrl)
      /**i should trigger 'deleteOne'
       * after i found 'product' above
       * otherwise we have a race condition
       * where deleting could finish before finding is finished
       * and that would be bad.
       */
      return Product.deleteOne({ _id: prodId, userId: req.user._id })
    })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

\* Chapter 330: Fixing Invoice Links
====================================

1\. update

- ./views/shop/orders.ejs

![](images/330-fixing-invoice-links-1.png)

```js
<!--./views/shop/orders.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/orders.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>
        <main>
            <% if (orders.length <= 0) { %>
                <h1>Nothing there!</h1>
            <% } else { %>
                <ul class="orders">
                    <% orders.forEach(order => { %>
                        <li class="orders__item">
                            <h1>Order - # <%= order._id %> - <a href="/orders/<%= order._id %>">Invoice</a></h1>
                            <ul class="orders__products">
                                <% order.products.forEach(p => { %>
                                    <li class="orders__products-item"><%= p.product.title %> (<%= p.quantity %>)</li>
                                <% }); %>
                            </ul>
                        </li>
                    <% }); %>
                </ul>
            <% } %>
        </main>
        <%- include('../includes/end.ejs') %>
```