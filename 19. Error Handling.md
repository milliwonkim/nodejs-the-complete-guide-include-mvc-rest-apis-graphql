\* Chapter 301: Module Introduction
===================================

![](images/301-module-introduction-1.png)![301-module-introduction-1.png](resources/638A0E80E85C3B932DA8B29776DC0623.png)

\* Chapter 302: Types Of Errors & Error Handling
================================================

![](images/302-types-of-errors-and-error-handling-1.png)

![](images/302-types-of-errors-and-error-handling-2.png)![302-types-of-errors-and-error-handling-1.png](resources/9E76B36BFB3D35AEE818595F762D75AE.png)![302-types-of-errors-and-error-handling-2.png](resources/9B809E8B69D56A4B41CEDFE4141A69C6.png)

- in technical/network errors, there’s not that much we can do. the best thing might be to show some error page to the user to let the user know that something is wrong on our end, that we are sorry and that we are working on fixing the issue. 

- expected errors is like we are interacting with a file or with a database that can fail. not very often. and it’s not really expected for this to fail but that can happen. maybe because there too many simultaneous requests to a certain file, anything like that.

- in bugs/logical errors, we should test our code and we should fix such issues. these are not errors, we should handle at runtime. 

![](images/302-types-of-errors-and-error-handling-3.png)![302-types-of-errors-and-error-handling-3.png](resources/045CD7391BF803890BBA226B51EFD03E.png)

- in all cases, we have got different ways of communicating with our users. 

\* Chapter 303: Analyzing The Error Handling In The Current Project
===================================================================

![](images/303-analyzing-the-error-handling-in-the-current-project-1.png)

![](images/303-analyzing-the-error-handling-in-the-current-project-2.png)![303-analyzing-the-error-handling-in-the-current-project-1.png](resources/E4EFB901D767902CA433D49905CE3161.png)![303-analyzing-the-error-handling-in-the-current-project-2.png](resources/8E409815AA528FE366DE3B128241ADD7.png)

- i check in login whether this email address exist and if not, i already return the same page with an error code where i pass that information that the input was invalid. 

![](images/303-analyzing-the-error-handling-in-the-current-project-3.png)

![](images/303-analyzing-the-error-handling-in-the-current-project-4.png)![303-analyzing-the-error-handling-in-the-current-project-3.png](resources/4898FD2DC26E54964498B840CD5F88CE.png)![303-analyzing-the-error-handling-in-the-current-project-4.png](resources/4A9683FFE83F529982BB2A7CD769B4C2.png)

- we do the same with the validation in ./routes/auth.js where we use the express-validator package to add built-in validation function. there behind the scene, this package also throws and handles errors and allows us to collect all these errors which are not these technical error object which is data managed by that package. 

![](images/303-analyzing-the-error-handling-in-the-current-project-5.png)

![](images/303-analyzing-the-error-handling-in-the-current-project-6.png)![303-analyzing-the-error-handling-in-the-current-project-5.png](resources/934FEF60B0941C0C76F25328301605BD.png)![303-analyzing-the-error-handling-in-the-current-project-6.png](resources/8F263F7BF5B758B57B663D8C1A33280C.png)

- we collect these errors and then we handle them manually

![](images/303-analyzing-the-error-handling-in-the-current-project-7.png)![303-analyzing-the-error-handling-in-the-current-project-7.png](resources/1002F2BAB996E0C6E526DA575C60E168.png)

- that would be the right side of this slide

![](images/303-analyzing-the-error-handling-in-the-current-project-8.png) ![303-analyzing-the-error-handling-in-the-current-project-8.png](resources/B0AF186013794F3B250ACEDCBCB29A8E.png)

- and proceed our own

- technical errors can always be seen if you have an error message down the console log.

![](images/303-analyzing-the-error-handling-in-the-current-project-9.png)![303-analyzing-the-error-handling-in-the-current-project-9.png](resources/BFDE819A39B6AA836466BD932BEDB517.png)

- in custom validator, i thrown a technical error when passwords don’t match. 

- this error would bubble up and would be handled by express but this express-validator package happens to handle it. 

\* Chapter 304: Errors - Some Theory
====================================

![](images/304-errors-some-theory-1.png)![304-errors-some-theory-1.png](resources/F30A43ACC593AB359E80FD9FC5F2CBE4.png)

- if i fill in only one argument, then i get NaN(Not a Number) but not a technical error object. 

![](images/304-errors-some-theory-2.png)![304-errors-some-theory-2.png](resources/AD2C2A1E56F9EB78951F509D0FF9EE38.png)

- here we have our own error message 

![](images/304-errors-some-theory-3.png)![304-errors-some-theory-3.png](resources/B5F683F72BE0980482579F16B0B55721.png)

- and then we got a callstack which allows us to find out at which function and which line number this error was thrown and what was called before that error. 

- if we don’t handle error, then our application just crashes. 

![](images/304-errors-some-theory-4.png)![304-errors-some-theory-4.png](resources/9FF12EF80EA4CC7268BE75D67E1A4372.png)

- in synchronous code, use ’try and catch’

- i get this additional 'error occurred’ message 

![](images/304-errors-some-theory-5.png)

![](images/304-errors-some-theory-6.png) ![304-errors-some-theory-5.png](resources/7A0B15365845764F5BDED25E4C2894BE.png)![304-errors-some-theory-6.png](resources/A5C919F33A893834C4007CC726F6A19E.png)

- and if i not log my error object, then i get just this. so then it doesn’t crash and log it automatically. but we could do anything we want. we could continue with other code after this. 

![](images/304-errors-some-theory-7.png)![304-errors-some-theory-7.png](resources/230AC001B16E1EE3A724BBAA706B0E9B.png)

- just to demonstrate this, if i comment out try and catch, and i just try to console log sum(1), so i call this with an error being thrown, then we don’t see 'this works' anywhere because it crashes with our error that is being thrown. and this doesn’t continue with other code. 

- this is why handling code like try and catch is a good thing to do because this ensures that we can continue with code, that we can handle this gracefully, in our node express application. we could send an error response which renders a valid page without crashing everything but which informs the user that something bad happened. 

![](images/304-errors-some-theory-8.png)![304-errors-some-theory-8.png](resources/9CD3599AADF68BB5851F23AD9DDF52F8.png)

- and this is what the express validator package does for us with our thrown error. in ./routes/auth.js, in the end express-validator catches this and then just adds it to its own error array and allows us to read that list of errors it caught. 

![](images/304-errors-some-theory-9.png)

![](images/304-errors-some-theory-10.png)![304-errors-some-theory-9.png](resources/A417B0CEF7C58E6B160A23C5F966D104.png)![304-errors-some-theory-10.png](resources/3A184B9B97CE7BA4D49F7C4B9FCE7EAE.png)

- we also have asynchronous operations that can fail and such operations when using promises are handled with 'then and catch’

- so if the database operation fails because we don’t have read access because the database server is down temperarilt, anything like that. then we make it into this catch block. 

- 'catch()’ collects all errors that are thrown by any prior then block. so if we had more than ’then()’ block in our chain here, catch would fire on any error thrown in any ’then()’ block or any operation executed in a ’then()’ block. 

\* Chapter 305: Throwing Errors In Code
=======================================

1\. update

- app.js

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  if (!req.session.user) {
    /**if '!req.session.user is true'
     * then return 'next()'
     * and execute next 'app.use()' right below
     * 
     * if i wouldn't not add this check,
     * it could try to find a user without the session object existing
     * and that would then crash our app. 
     */
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if(!user) {
        return next()
      }
      req.user = user;
      next();
    })
    /**any potential errors that might be happening
     * because this 'catch()' block will not fire 
     * if i don't find the user with this 'req.session.user._id'
     * it will only fire if there are any technical issues,
     * if the database is down
     * or if the user of this app doesn't have sufficient permissions to execute this action
     */
    .catch(err => {
      /**here in the 'catch' block,
       * logginig it is not useful.
       * it will make more sense to throw a new Error here
       * where we wrap the error object here
       * 
       * throwing this error has a significant advantage 
       *
       *    throw new Error(err)
       *  
       * if we have some technical issue,
       * we throw a real error 
       * as it turns out express.js gives us a way of taking care of such errors.
       * that is why i'm doing like this. 
       */
      throw new Error(err)
      /**alternatively, we could simply call 'next()' to continue without req.user being set
       */
    });
});

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.use(errorController.get404);

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 306: Returning Error Pages
=====================================

1\. update

- ./controllers/admin.js

- ./views/admin/edit-product.ejs

- ./views/500.ejs

- ./controllers/error.js

- app.js

![](images/306-returning-error-pages-1.png)

![](images/306-returning-error-pages-2.png)

![](images/306-returning-error-pages-3.png)

![](images/306-returning-error-pages-4.png)

![](images/306-returning-error-pages-5.png) ![306-returning-error-pages-1.png](resources/9381B41897242B2092092C07E384367E.png)![306-returning-error-pages-2.png](resources/CF408938B49856B62A57DED1A34FF997.png)![306-returning-error-pages-3.png](resources/B9C78C91E000776116A9C47BEA592087.png)![306-returning-error-pages-4.png](resources/809D8CEDF46377826C1A92762927E30D.png)![306-returning-error-pages-5.png](resources/F13D81EA182C10C0B30DE3AD6332D47B.png)

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  const product = new Product({
    _id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      res.redirect('/500');
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        imageUrl: updatedImageUrl,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

```

```js
<!--./views/admin/edit-product.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/forms.css">
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
   <%- include('../includes/navigation.ejs') %>

    <main>
        <% if (errorMessage) { %>
            <div class="user-message user-message--error"><%= errorMessage %></div>
        <% } %>
        <form class="product-form" action="/admin/<% if (editing) { %>edit-product<% } else { %>add-product<% } %>" method="POST">
            <div class="form-control">
                <label for="title">Title</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'title') ? 'invalid' : '' %>"
                    type="text" 
                    name="title" 
                    id="title" 
                    value="<% if (editing || hasError) { %><%= product.title %><% } %>">
            </div>
            <div class="form-control">
                <label for="imageUrl">Image URL</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'imageUrl') ? 'invalid' : '' %>"
                    type="text" 
                    name="imageUrl" 
                    id="imageUrl" 
                    value="<% if (editing || hasError) { %><%= product.imageUrl %><% } %>">
            </div>
            <div class="form-control">
                <label for="price">Price</label>
                <input 
                    class="<%= validationErrors.find(e => e.param === 'price') ? 'invalid' : '' %>"
                    type="number" 
                    name="price" 
                    id="price" 
                    step="0.01" 
                    value="<% if (editing || hasError) { %><%= product.price %><% } %>">
            </div>
            <div class="form-control">
                <label for="description">Description</label>
                <textarea 
                    class="<%= validationErrors.find(e => e.param === 'description') ? 'invalid' : '' %>"
                    name="description" 
                    id="description" 
                    rows="5"><% if (editing || hasError) { %><%= product.description %><% } %></textarea>
            </div>
            <% if (editing) { %>
                <input type="hidden" value="<%= product._id %>" name="productId">
            <% } %>

            <input type="hidden" name="_csrf" value="<%= csrfToken %>">
            <button class="btn" type="submit"><% if (editing) { %>Update Product<% } else { %>Add Product<% } %></button>
        </form>
    </main>
<%- include('../includes/end.ejs') %>
```

```js
<!--./views/500.ejs-->

<%- include('includes/head.ejs') %>
</head>

<body>
    <%- include('includes/navigation.ejs') %>
    <h1>Some error occurred!</h1>
    <p>We're working on fixing this, sorry for the inconvenience!</p>

<%- include('includes/end.ejs') %>
```

```js
//./controllers/error.js

exports.get404 = (req, res, next) => {
  res.status(404).render('404', {
    pageTitle: 'Page Not Found',
    path: '/404',
    isAuthenticated: req.session.isLoggedIn
  });
};

exports.get500 = (req, res, next) => {
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
};

```

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      throw new Error(err);
    });
});

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 307: Returning Error Pages
=====================================

1.update

- ./controllers/admin.js

- app.js

![](images/307-returning-error-pages-1.png)

![](images/307-returning-error-pages-2.png)

![](images/307-returning-error-pages-3.png)

![](images/307-returning-error-pages-4.png)

![](images/307-returning-error-pages-5.png)

![](images/307-returning-error-pages-6.png)![307-returning-error-pages-1.png](resources/854BEC9E57CFC3331EC22B58A7ED16B6.png)![307-returning-error-pages-2.png](resources/1422F266B3068720FD4E0A5BE460FD29.png)![307-returning-error-pages-3.png](resources/23AD29D7537F900828E5CAE496135E70.png)![307-returning-error-pages-4.png](resources/4372084BEC399E2167AF776DE1F25D33.png)![307-returning-error-pages-5.png](resources/FE6FB78E92F7830EF2B4066C6A8F62D4.png)![307-returning-error-pages-6.png](resources/893A8C4122AD39B568E884B6B638564E.png)

- this error handler will not execute for 404 errors. there we still handle this manually because technically, the 404 error is simply just a valid URL which we catch with our catch all handler where we then just happen to render 404 page. it’s not a technical error object that gets created at any point here.

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  const product = new Product({
    _id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      /**when we call 'next' as an error passed as an argument,
       * then we let express know that an error occurred
       * and it will skip all other middlewares
       * and move right away to an error handling middleware 
       * so 'next(error)' is the trick with an error object being passed instead of throwing it.
       * 
       */
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        imageUrl: updatedImageUrl,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

```

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      throw new Error(err);
    });
});

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

/**this could be never be reached
 * because we have our catch all middleware down there
 * 
 * but there's a special type of middleware which we haven't seen before
 * 
 */
app.use(errorController.get404);

/**express is clever enough to detect that
 * this is a special kind of middleware
 * and it will move right away to these error handling middlewares
 * when you call 'next(error)'
 * 
 * if you got more than one error-handling middleware,
 * they will execute from top to bottom just like the normal middleware
 */
app.use((error, req, res, next) => {
  /**i just wanna show you
   * that you can pass extra information with the error object
   * so that you can use it in this central error handler here
   * 
   *    res.status(error.httpStatusCode).render(...)
   *
   */
  res.redirect('/500')
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 308: Updating The App
================================

1\. update

- ./controllers/admin.js

- ./controllers/auth.js

- ./controllers/shop.js

![](images/308-updating-the-app-1.png)

![](images/308-updating-the-app-2.png)

![](images/308-updating-the-app-3.png)

![](images/308-updating-the-app-4.png)

![](images/308-updating-the-app-5.png) ![308-updating-the-app-1.png](resources/A70C508E381188F9B5313AE262AEBD2C.png)![308-updating-the-app-2.png](resources/2C24D92BBB20D5AEDFA0C18B0374A729.png)![308-updating-the-app-3.png](resources/D6CCCB7DF28D1FF3DE549B52BF81E684.png)![308-updating-the-app-4.png](resources/6931FF019D79E2582FDF941B829C9882.png)![308-updating-the-app-5.png](resources/3A31AEE427092BB7930EAC28E650995C.png)

```js
// ./controllers/admin.js

const mongoose = require('mongoose');

const { validationResult } = require('express-validator/check');

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false,
    hasError: false,
    errorMessage: null,
    validationErrors: []
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Add Product',
      path: '/admin/add-product',
      editing: false,
      hasError: true,
      product: {
        title: title,
        imageUrl: imageUrl,
        price: price,
        description: description
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  const product = new Product({
    //_id: new mongoose.Types.ObjectId('5badf72403fd8b5be0366e81'),
    title: title,
    price: price,
    description: description,
    imageUrl: imageUrl,
    userId: req.user
  });
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      // return res.status(500).render('admin/edit-product', {
      //   pageTitle: 'Add Product',
      //   path: '/admin/add-product',
      //   editing: false,
      //   hasError: true,
      //   product: {
      //     title: title,
      //     imageUrl: imageUrl,
      //     price: price,
      //     description: description
      //   },
      //   errorMessage: 'Database operation failed, please try again.',
      //   validationErrors: []
      // });
      //res.redirect('/500');
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product,
        hasError: false,
        errorMessage: null,
        validationErrors: []
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const errors = validationResult(req);

  if (!errors.isEmpty()) {
    return res.status(422).render('admin/edit-product', {
      pageTitle: 'Edit Product',
      path: '/admin/edit-product',
      editing: true,
      hasError: true,
      product: {
        title: updatedTitle,
        imageUrl: updatedImageUrl,
        price: updatedPrice,
        description: updatedDesc,
        _id: prodId
      },
      errorMessage: errors.array()[0].msg,
      validationErrors: errors.array()
    });
  }

  Product.findById(prodId)
    .then(product => {
      if (product.userId.toString() !== req.user._id.toString()) {
        return res.redirect('/');
      }
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save().then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProducts = (req, res, next) => {
  Product.find({ userId: req.user._id })
    // .select('title price -_id')
    // .populate('userId', 'name')
    .then(products => {
      console.log(products);
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteOne({ _id: prodId, userId: req.user._id })
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

```js
//./controllers/auth.js

const crypto = require('crypto');

const bcrypt = require('bcryptjs');
const nodemailer = require('nodemailer');
const sendgridTransport = require('nodemailer-sendgrid-transport');
const { validationResult } = require('express-validator/check');

const User = require('../models/user');

const transporter = nodemailer.createTransport(
  sendgridTransport({
    auth: {
      api_key:
      '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'    }
  })
);

exports.getLogin = (req, res, next) => {
  let message = req.flash('error');
  if (message.length > 0) {
    message = message[0];
  } else {
    message = null;
  }
  res.render('auth/login', {
    path: '/login',
    pageTitle: 'Login',
    errorMessage: message,
    oldInput: {
      email: '',
      password: ''
    },
    validationErrors: []
  });
};

exports.getSignup = (req, res, next) => {
  let message = req.flash('error');
  if (message.length > 0) {
    message = message[0];
  } else {
    message = null;
  }
  res.render('auth/signup', {
    path: '/signup',
    pageTitle: 'Signup',
    errorMessage: message,
    oldInput: {
      email: '',
      password: '',
      confirmPassword: ''
    },
    validationErrors: []
  });
};

exports.postLogin = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(422).render('auth/login', {
      path: '/login',
      pageTitle: 'Login',
      errorMessage: errors.array()[0].msg,
      oldInput: {
        email: email,
        password: password
      },
      validationErrors: errors.array()
    });
  }

  User.findOne({ email: email })
    .then(user => {
      if (!user) {
        return res.status(422).render('auth/login', {
          path: '/login',
          pageTitle: 'Login',
          errorMessage: 'Invalid email or password.',
          oldInput: {
            email: email,
            password: password
          },
          validationErrors: []
        });
      }
      bcrypt
        .compare(password, user.password)
        .then(doMatch => {
          if (doMatch) {
            req.session.isLoggedIn = true;
            req.session.user = user;
            return req.session.save(err => {
              console.log(err);
              res.redirect('/');
            });
          }
          return res.status(422).render('auth/login', {
            path: '/login',
            pageTitle: 'Login',
            errorMessage: 'Invalid email or password.',
            oldInput: {
              email: email,
              password: password
            },
            validationErrors: []
          });
        })
        .catch(err => {
          console.log(err);
          res.redirect('/login');
        });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postSignup = (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;

  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    console.log(errors.array());
    return res.status(422).render('auth/signup', {
      path: '/signup',
      pageTitle: 'Signup',
      errorMessage: errors.array()[0].msg,
      oldInput: {
        email: email,
        password: password,
        confirmPassword: req.body.confirmPassword
      },
      validationErrors: errors.array()
    });
  }

  bcrypt
    .hash(password, 12)
    .then(hashedPassword => {
      const user = new User({
        email: email,
        password: hashedPassword,
        cart: { items: [] }
      });
      return user.save();
    })
    .then(result => {
      res.redirect('/login');
      // return transporter.sendMail({
      //   to: email,
      //   from: 'shop@node-complete.com',
      //   subject: 'Signup succeeded!',
      //   html: '<h1>You successfully signed up!</h1>'
      // });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postLogout = (req, res, next) => {
  req.session.destroy(err => {
    console.log(err);
    res.redirect('/');
  });
};

exports.getReset = (req, res, next) => {
  let message = req.flash('error');
  if (message.length > 0) {
    message = message[0];
  } else {
    message = null;
  }
  res.render('auth/reset', {
    path: '/reset',
    pageTitle: 'Reset Password',
    errorMessage: message
  });
};

exports.postReset = (req, res, next) => {
  crypto.randomBytes(32, (err, buffer) => {
    if (err) {
      console.log(err);
      return res.redirect('/reset');
    }
    const token = buffer.toString('hex');
    User.findOne({ email: req.body.email })
      .then(user => {
        if (!user) {
          req.flash('error', 'No account with that email found.');
          return res.redirect('/reset');
        }
        user.resetToken = token;
        user.resetTokenExpiration = Date.now() + 3600000;
        return user.save();
      })
      .then(result => {
        res.redirect('/');
        transporter.sendMail({
          to: req.body.email,
          from: 'shop@node-complete.com',
          subject: 'Password reset',
          html: `
            <p>You requested a password reset</p>
            <p>Click this <a href="http://localhost:3000/reset/${token}">link</a> to set a new password.</p>
          `
        });
      })
      .catch(err => {
        const error = new Error(err)
        error.httpStatusCode = 500
        return next(error)
      });
  });
};

exports.getNewPassword = (req, res, next) => {
  const token = req.params.token;
  User.findOne({ resetToken: token, resetTokenExpiration: { $gt: Date.now() } })
    .then(user => {
      let message = req.flash('error');
      if (message.length > 0) {
        message = message[0];
      } else {
        message = null;
      }
      res.render('auth/new-password', {
        path: '/new-password',
        pageTitle: 'New Password',
        errorMessage: message,
        userId: user._id.toString(),
        passwordToken: token
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postNewPassword = (req, res, next) => {
  const newPassword = req.body.password;
  const userId = req.body.userId;
  const passwordToken = req.body.passwordToken;
  let resetUser;

  User.findOne({
    resetToken: passwordToken,
    resetTokenExpiration: { $gt: Date.now() },
    _id: userId
  })
    .then(user => {
      resetUser = user;
      return bcrypt.hash(newPassword, 12);
    })
    .then(hashedPassword => {
      resetUser.password = hashedPassword;
      resetUser.resetToken = undefined;
      resetUser.resetTokenExpiration = undefined;
      return resetUser.save();
    })
    .then(result => {
      res.redirect('/login');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

```

```js
//./controllers/shop.js

const Product = require('../models/product');
const Order = require('../models/order');

exports.getProducts = (req, res, next) => {
  Product.find()
    .then(products => {
      console.log(products);
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getIndex = (req, res, next) => {
  Product.find()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    })
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.postOrder = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err)
      error.httpStatusCode = 500
      return next(error)
    });
};


```

\* Chapter 309: Using The Error Handling Middleware Correctly
=============================================================

1.update

- app.js

![](images/309-using-the-error-handling-middleware-correctly-1.png)

![](images/309-using-the-error-handling-middleware-correctly-2.png)

![](images/309-using-the-error-handling-middleware-correctly-3.png)![309-using-the-error-handling-middleware-correctly-1.png](resources/9A0F3EA7726F126811D22D7964564481.png)![309-using-the-error-handling-middleware-correctly-2.png](resources/45E0EF55744AAE216E06ADB82FDBBDA8.png)![309-using-the-error-handling-middleware-correctly-3.png](resources/90DA86146AA7C3EDACDD2DA645DA0DFA.png)

- the app is still crashing. so one important takeaway is throwing an error doesn’t lead to our general error handling middleware being called like below

```js
//app.js

app.use(error, req, res, next) => {
    res.redirect('/500')
})
```

![](images/309-using-the-error-handling-middleware-correctly-4.png)![309-using-the-error-handling-middleware-correctly-4.png](resources/0992A3B2D084594288AA8AC2AA36186B.png)

- this is true because we are inside some async code, we are inside a promise here. we are inside a ’then or catch’ block. 

- if you throw errors there, you will not reach that express error handling middleware

![](images/309-using-the-error-handling-middleware-correctly-5.png)

![](images/309-using-the-error-handling-middleware-correctly-6.png)![309-using-the-error-handling-middleware-correctly-5.png](resources/FDB82EF9227C4CFC4345E2301224F868.png)![309-using-the-error-handling-middleware-correctly-6.png](resources/D77FB7585566A318BCE68D61C54BCFF3.png)

- if you would throw an error outside of async code like outside of a promise ’then and catch’ block or outside of a callback, this is now throwing in a normal function, not nested inside a promise or a callback. 

- if i now reload this page, you will see it tried to load the 500 page but it still failed. because we have our middleware in place where i retrieve my user and i throw the error, but this executes for every incoming request 

![](images/309-using-the-error-handling-middleware-correctly-7.png)![309-using-the-error-handling-middleware-correctly-7.png](resources/195FB3B618718E1D3921F6F4B262EFF3.png)

- when we redirect here, we send a new request, so we enter a infinite loop here. between ‘a' and ‘b’ below

```js
//app.js

//a
app.use((req, res, next) => {
  throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      throw new Error('Dummy')
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      throw new Error(err);
    });
});

//b
app.use((error, req, res, next) => {
  res.redirect('/500')
})
```

- we execute ‘a’ and it throws an error. we go to the error handling middleware, we trigger a new request. 

- so one solution is not redirecting to 500 but immediately execute our rendering code which is ‘get500' in ./controllers/error.js

![](images/309-using-the-error-handling-middleware-correctly-8.png)

![](images/309-using-the-error-handling-middleware-correctly-9.png)![309-using-the-error-handling-middleware-correctly-8.png](resources/9B37884D61AE6D9F59FDAD2F9B132077.png)![309-using-the-error-handling-middleware-correctly-9.png](resources/BCAE4E76AE3C567E1D698685AE308A80.png)

- because i still have this dummy error being thrown in my promise, hence the catch block executes, hence ’next(new Error(err))’ executes.

- for one, you should avoid infinite loops triggered through your error handling middleware as we had it.

- for second, you can throw the error in synchronous code places. but inside of promise ’then or catch block or callback’, you have to use ’next(new Error(err))'

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');

const errorController = require('./controllers/error');
const User = require('./models/user');

const MONGODB_URI =
'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/shop'

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);
app.use(csrfProtection);
app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use((req, res, next) => {
  /**i'm throwing an error 
   * and we still reach this global error handling middlware below
   * 
   *  app.use((error, req, res, next) => {
          res.status(500).render('500', {
          pageTitle: 'Error!',
          path: '/500',
          isAuthenticated: req.session.isLoggedIn
        });
      })
   * 
   * the reason is that in synchronous places,
   * so outside of callbacks and promises,
   * you throw an error and express will detect this
   * and execute your next error handling middleware.
   * inside of async code, 'then, catch, or callback',
   * you have to use 'next(new Error(err))'
   * so this is then detected by express again
   * and this is what we used in the other files
   * and inside of async code, you need to use 'next()' wrapping the error
   * outside you can just 'throw new Error('Sync Dummy')'


   */
  //throw new Error('Sync Dummy')
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err))
    });
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  //res.redirect('/500')
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
})

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 310: Status Codes
============================

![](images/310-status-codes-1.png)

![](images/310-status-codes-2.png)![310-status-codes-1.png](resources/FA2D988DA11CDFB225BDDB0664112E89.png)![310-status-codes-2.png](resources/E54C13B25375A8D43F09094BD9601978.png)

- if we succeed or in all cases here, we redirect which again will use 300 automatically. 

![](images/310-status-codes-3.png)![310-status-codes-3.png](resources/C84C6F068517AAA91AB678F875A07BDE.png)

- since i’m redirecting, i’m sending a 300 status code and we could also add status 401 here to make clear what the problem is.

![](images/310-status-codes-4.png)![310-status-codes-4.png](resources/D63DAA517668E54C7DB8E5498281584E.png)

- but it will be overwritten with a 300 code due to redirect. so it doesn’t make a lot of sense. 

![](images/310-status-codes-5.png)

![](images/310-status-codes-6.png)

![](images/310-status-codes-7.png)

![](images/310-status-codes-8.png)![310-status-codes-5.png](resources/658042F9632D001131CFA6F39B87D8B3.png)![310-status-codes-6.png](resources/784163272FF676852D4D15201D41F880.png)![310-status-codes-7.png](resources/51737E42620AB1A6D4363ED0F9FAC680.png)![310-status-codes-8.png](resources/C73E51BC68C6CCE2138EE8CD06DF8264.png)

- these status codes not means that our app crashes, that’s important to understand. instead if i enter some invalid route here, i get ‘page not found’, and if i open chrome developer tools, and we ca see this 404 marked as red. but the error doesn’t mean it crashes. 

![](images/310-status-codes-9.png)![310-status-codes-9.png](resources/C730FE82ACB62541F74821983FEF0520.png)

- we still render a valid page in the end, we pass that extra information of hey here’s the page but you see that page because something goes wrong. 

Which status codes are available? 

MDN has a nice list: <https://developer.mozilla.org/en-US/docs/Web/HTTP/Status>

Or, as a short overview:

**1×× Informational**

* 100 Continue
* 101 Switching Protocols
* 102 Processing

**2×× Success**

* 200 OK
* 201 Created
* 202 Accepted
* 203 Non-authoritative Information
* 204 No Content
* 205 Reset Content
* 206 Partial Content
* 207 Multi-Status
* 208 Already Reported
* 226 IM Used

**3×× Redirection**

* 300 Multiple Choices
* 301 Moved Permanently
* 302 Found
* 303 See Other
* 304 Not Modified
* 305 Use Proxy
* 307 Temporary Redirect
* 308 Permanent Redirect

**4×× Client Error**

* 400 Bad Request
* 401 Unauthorized
* 402 Payment Required
* 403 Forbidden
* 404 Not Found
* 405 Method Not Allowed
* 406 Not Acceptable
* 407 Proxy Authentication Required
* 408 Request Timeout
* 409 Conflict
* 410 Gone
* 411 Length Required
* 412 Precondition Failed
* 413 Payload Too Large
* 414 Request-URI Too Long
* 415 Unsupported Media Type
* 416 Requested Range Not Satisfiable
* 417 Expectation Failed
* 418 I'm a teapot
* 421 Misdirected Request
* 422 Unprocessable Entity
* 423 Locked
* 424 Failed Dependency
* 426 Upgrade Required
* 428 Precondition Required
* 429 Too Many Requests
* 431 Request Header Fields Too Large
* 444 Connection Closed Without Response
* 451 Unavailable For Legal Reasons
* 499 Client Closed Request

**5×× Server Error**

* 500 Internal Server Error
* 501 Not Implemented
* 502 Bad Gateway
* 503 Service Unavailable
* 504 Gateway Timeout
* 505 HTTP Version Not Supported
* 506 Variant Also Negotiates
* 507 Insufficient Storage
* 508 Loop Detected
* 510 Not Extended
* 511 Network Authentication Required
* 599 Network Connect Timeout Error

Source: <https://httpstatuses.com/>

\* Chapter 312: Wrap Up
=======================

![](images/312-wrap-up-1.png)![312-wrap-up-1.png](resources/43553C8755B21BA43A730DC7169FD53A.png)