\* Chapter 443: Module Introduction
===================================

![](images/443-module-introduction-1.png)![443-module-introduction-1.png](resources/3745BFB484A157F83C204A76CAE08980.png)

\* Chapter 444: Deploying Different Kinds Of Apps
=================================================

![](images/444-deploying-different-kinds-of-apps-1.png)![444-deploying-different-kinds-of-apps-1.png](resources/BBBD59AC709A0D898655AD5D0202A59D.png)

\* Chapter 445: Deployment Preparations
=======================================

![](images/445-deployment-preparations-1.png)![445-deployment-preparations-1.png](resources/C374ACB31D97E95A5F6BD432DBBB6D81.png)

\* Chapter 446: Using Environment Variables
===========================================

1\. update

- app.js

- ./controllers/shop.js

- nodemon.js

- package.json

![](images/446-using-environment-variables-1.png)

![](images/446-using-environment-variables-2.png)

![](images/446-using-environment-variables-3.png)![446-using-environment-variables-1.png](resources/1C3A517E2507EC1E88A9CEA528422881.png)![446-using-environment-variables-2.png](resources/8054D70082147440B1D690E755B0BE3C.png)![446-using-environment-variables-3.png](resources/4EA6FE6F23ABB19108F76108A2889DE1.png)

- in the “start”, this will not used at ’nodemon app.js’ but 'node app.js’ so if you wanna pass an environment variables here, you also got different solutions. and when using a hosting provider, you can set up the environment variables in the dashboard of your hosting provider. 

![](images/446-using-environment-variables-4.png)

![](images/446-using-environment-variables-5.png)

![](images/446-using-environment-variables-6.png)![446-using-environment-variables-4.png](resources/7A799AF267F450BEB5B0121533BEAF45.png)![446-using-environment-variables-5.png](resources/C9261FC413CFB20343CCC5E8A66E0907.png)![446-using-environment-variables-6.png](resources/4634FEA3FC4A2782C81DE5F5D574AEBE.png)

- as a simple solution, take the key value pairs you wanna set up and add them in your package.json file on the “start” script.

- we are running now this with our environment variables”MONGO\_USER” “MONGO\_PASSWORD” “MONGO\_DEFAULT\_DATABASE” “STRIPE KEY" here.

![](images/446-using-environment-variables-7.png)

![](images/446-using-environment-variables-8.png)![446-using-environment-variables-7.png](resources/B12D51347A58F5B9A5515308C006843F.png)![446-using-environment-variables-8.png](resources/BF30466B3FBD72E5E431B511E98F0D01.png)

- you see ‘undefined’ here. now again this will be set automatically by hosting providers. you can also set it on your own and hosting providers will set this to production. “NODE\_ENV=production” which is a special environment variables even though it’s not set by default because express.js will use this by default to determine the environment mode and if you set that to production, express.js will change certain things for example it will reduce the details for errors it frozes and general optimized some thigns for deployment.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

/**'process' object is an object not defined by us
 * this is globally abailable in the node app
 * it's part of the node core runtime
 * 
 * 'env' property is an object with all the environment variables
 * this node process knows there are a bunch of default environment variables
 * but we can also set our own ones.
 */
const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    /**most hosting providers or all those providers
     * that managed it for us
     * will automatically inject the PORT environment variable
     * so most of time we can rely on that being set
     * and for local development we will still foward back to 3000
     * because there will not be set
     */
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

```js
//./controllers/shop.js

const fs = require('fs');
const path = require('path');

const PDFDocument = require('pdfkit');
const stripe = require('stripe')(process.env.STRIPE_KEY);

const Product = require('../models/product');
const Order = require('../models/order');

const ITEMS_PER_PAGE = 2;

exports.getProducts = (req, res, next) => {
  const page = +req.query.page || 1;
  let totalItems;

  Product.find()
    .countDocuments()
    .then(numProducts => {
      totalItems = numProducts;
      return Product.find()
        .skip((page - 1) * ITEMS_PER_PAGE)
        .limit(ITEMS_PER_PAGE);
    })
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'Products',
        path: '/products',
        currentPage: page,
        hasNextPage: ITEMS_PER_PAGE * page < totalItems,
        hasPreviousPage: page > 1,
        nextPage: page + 1,
        previousPage: page - 1,
        lastPage: Math.ceil(totalItems / ITEMS_PER_PAGE)
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getIndex = (req, res, next) => {
  const page = +req.query.page || 1;
  let totalItems;

  Product.find()
    .countDocuments()
    .then(numProducts => {
      totalItems = numProducts;
      return Product.find()
        .skip((page - 1) * ITEMS_PER_PAGE)
        .limit(ITEMS_PER_PAGE);
    })
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/',
        currentPage: page,
        hasNextPage: ITEMS_PER_PAGE * page < totalItems,
        hasPreviousPage: page > 1,
        nextPage: page + 1,
        previousPage: page - 1,
        lastPage: Math.ceil(totalItems / ITEMS_PER_PAGE)
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .removeFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getCheckout = (req, res, next) => {
  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {
      const products = user.cart.items;
      let total = 0;
      products.forEach(p => {
        total += p.quantity * p.productId.price;
      });
      res.render('shop/checkout', {
        path: '/checkout',
        pageTitle: 'Checkout',
        products: products,
        totalSum: total
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.postOrder = (req, res, next) => {
  // Token is created using Checkout or Elements!
  // Get the payment token ID submitted by the form:
  const token = req.body.stripeToken; // Using Express
  let totalSum = 0;

  req.user
    .populate('cart.items.productId')
    .execPopulate()
    .then(user => {  
      user.cart.items.forEach(p => {
        totalSum += p.quantity * p.productId.price;
      });

      const products = user.cart.items.map(i => {
        return { quantity: i.quantity, product: { ...i.productId._doc } };
      });
      const order = new Order({
        user: {
          email: req.user.email,
          userId: req.user
        },
        products: products
      });
      return order.save();
    })
    .then(result => {
      const charge = stripe.charges.create({
        amount: totalSum * 100,
        currency: 'usd',
        description: 'Demo Order',
        source: token,
        metadata: { order_id: result._id.toString() }
      });
      return req.user.clearCart();
    })
    .then(() => {
      res.redirect('/orders');
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getOrders = (req, res, next) => {
  Order.find({ 'user.userId': req.user._id })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => {
      const error = new Error(err);
      error.httpStatusCode = 500;
      return next(error);
    });
};

exports.getInvoice = (req, res, next) => {
  const orderId = req.params.orderId;
  Order.findById(orderId)
    .then(order => {
      if (!order) {
        return next(new Error('No order found.'));
      }
      if (order.user.userId.toString() !== req.user._id.toString()) {
        return next(new Error('Unauthorized'));
      }
      const invoiceName = 'invoice-' + orderId + '.pdf';
      const invoicePath = path.join('data', 'invoices', invoiceName);

      const pdfDoc = new PDFDocument();
      res.setHeader('Content-Type', 'application/pdf');
      res.setHeader(
        'Content-Disposition',
        'inline; filename="' + invoiceName + '"'
      );
      pdfDoc.pipe(fs.createWriteStream(invoicePath));
      pdfDoc.pipe(res);

      pdfDoc.fontSize(26).text('Invoice', {
        underline: true
      });
      pdfDoc.text('-----------------------');
      let totalPrice = 0;
      order.products.forEach(prod => {
        totalPrice += prod.quantity * prod.product.price;
        pdfDoc
          .fontSize(14)
          .text(
            prod.product.title +
              ' - ' +
              prod.quantity +
              ' x ' +
              '$' +
              prod.product.price
          );
      });
      pdfDoc.text('---');
      pdfDoc.fontSize(20).text('Total Price: $' + totalPrice);

      pdfDoc.end();
      // fs.readFile(invoicePath, (err, data) => {
      //   if (err) {
      //     return next(err);
      //   }
      //   res.setHeader('Content-Type', 'application/pdf');
      //   res.setHeader(
      //     'Content-Disposition',
      //     'inline; filename="' + invoiceName + '"'
      //   );
      //   res.send(data);
      // });
      // const file = fs.createReadStream(invoicePath);

      // file.pipe(res);
    })
    .catch(err => next(err));
};

```

```js
//nodemon.json

{
    "env": {
        "MONGO_USER": "maximilian",
        "MONGO_PASSWORD": "rldnjs12",
        "MONGO_DEFAULT_DATABASE": "shop",
        "STRIPE_KEY": "sk_test_dAPYh6CKcipsTX13kbjOFklT00NICMWhhg"
    }
}
```

```js
{
  "name": "nodejs-complete-guide",
  "version": "1.0.0",
  "description": "Complete Node.js Guide",
  "main": "app.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "NODE_ENV=production MONGO_USER=maximilian MONGO_PASSWORD=rldnjs12 MONGO_DEFAULT_DATABASE=shop STRIPE_KEY=sk_test_dAPYh6CKcipsTX13kbjOFklT00NICMWhhg node app.js",
    "start-server": "node app.js",
    "start:dev": "nodemon app.js"
  },
  "author": "Maximilian Schwarzmüller",
  "license": "ISC",
  "devDependencies": {
    "nodemon": "^1.18.3"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.18.3",
    "connect-flash": "^0.1.1",
    "connect-mongodb-session": "^2.0.3",
    "csurf": "^1.9.0",
    "ejs": "^2.6.1",
    "express": "^4.16.3",
    "express-handlebars": "^3.0.0",
    "express-session": "^1.15.6",
    "express-validator": "^5.3.0",
    "lodash": "^4.17.11",
    "mongodb": "^3.1.6",
    "mongoose": "^5.2.17",
    "multer": "^1.4.0",
    "mysql2": "^1.6.1",
    "nodemailer": "^4.6.8",
    "nodemailer-sendgrid-transport": "^0.2.0",
    "pdfkit": "^0.8.3",
    "pug": "^2.0.3",
    "sequelize": "^5.0.0-beta.11",
    "stripe": "^6.12.1"
  }
}

```

\* Chapter 447: Using Production API Keys
=========================================

![](images/447-using-production-api-keys-1.png)

![](images/447-using-production-api-keys-2.png)

![](images/447-using-production-api-keys-3.png)![447-using-production-api-keys-1.png](resources/658E923B734651CBC9411D92348DAEEA.png)![447-using-production-api-keys-2.png](resources/DA3A2D4367A741D17B76286ED6F8168E.png)![447-using-production-api-keys-3.png](resources/9FE166CDB76BAB3D245A03C2715B3A36.png)

- if you wanna deploy this into production, you need to fill it all out and once you filled it out, you will be able to switch that toggle here at the top and see your life data your production ready keys and you should use these keys in your code. so wherever you are using the test key right now, you would have to replace them with the production ready keys and data is just stripe example. other API might use similar behavior.

\* Chapter 448: Setting Secure Response Headers With Helmet
===========================================================

1\. update

- app.js

===========================

![](images/448-setting-secure-response-headers-with-helmet-1.png)

![](images/448-setting-secure-response-headers-with-helmet-2.png)

![](images/448-setting-secure-response-headers-with-helmet-3.png)

![](images/448-setting-secure-response-headers-with-helmet-4.png)

![](images/448-setting-secure-response-headers-with-helmet-5.png)

![](images/448-setting-secure-response-headers-with-helmet-6.png)![448-setting-secure-response-headers-with-helmet-1.png](resources/8E3A4F25A09FD04F0A57FD9241798116.png)![448-setting-secure-response-headers-with-helmet-2.png](resources/AC1D18BE50242CCC6122ED3C69819F8B.png)![448-setting-secure-response-headers-with-helmet-3.png](resources/343EA08D8BCA64BBDA122B18E72055AB.png)![448-setting-secure-response-headers-with-helmet-4.png](resources/CF10EBD732533A8EFBA85D3338348C3C.png)![448-setting-secure-response-headers-with-helmet-5.png](resources/A5727AEF2C715CAD240E1B28939409DF.png)![448-setting-secure-response-headers-with-helmet-6.png](resources/8130E7926133419F1904F32076FA1244.png)

- i can see that on this response. i have a couple of headers being set and there are some special headers which were added by helmet and you can always check that by temporarily commenting out helmet

![](images/448-setting-secure-response-headers-with-helmet-7.png)

![](images/448-setting-secure-response-headers-with-helmet-8.png)

![](images/448-setting-secure-response-headers-with-helmet-9.png)

![](images/448-setting-secure-response-headers-with-helmet-10.png)![448-setting-secure-response-headers-with-helmet-7.png](resources/B79F903E405302900A13C186584D6F41.png)![448-setting-secure-response-headers-with-helmet-8.png](resources/78810B6707D4FB93AB7D1A7DFF7B4253.png)![448-setting-secure-response-headers-with-helmet-9.png](resources/2D821FF5AEAF7138D859F95607D841F1.png)![448-setting-secure-response-headers-with-helmet-10.png](resources/1A64DFA081C881ECABB01F2995C275D8.png)

- we had 11 response headers before. now i reload this, we just have 6 because now some special headers are missing and that is something you should consider doing.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');
const helmet = require('helmet');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(helmet());

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 449: Compressing Assets
==================================

1\. update

- app.js

![](images/449-compressing-assets-1.png)

![](images/449-compressing-assets-2.png)

![](images/449-compressing-assets-3.png)

![](images/449-compressing-assets-4.png)![449-compressing-assets-1.png](resources/92786A1B4EC0FE45AC1C4A0F0398C410.png)![449-compressing-assets-2.png](resources/5C0D4D48F4144FCFC80B40D020BE7300.png)![449-compressing-assets-3.png](resources/FFF1B9F18B027178DF1395F23634DA4B.png)![449-compressing-assets-4.png](resources/A53A9A9483030066214B01EA9BF878B5.png)

- now with response headers added, let’s make sure we serve optimized assets annd for that we can use another package called ’node compression’

![](images/449-compressing-assets-5.png)

![](images/449-compressing-assets-6.png)![449-compressing-assets-5.png](resources/B432680C8F5CB084CF18BCF982C8A7CD.png)![449-compressing-assets-6.png](resources/C0D5488BBB23529747EEE1E69AB56B2C.png)

- after commenting out, these are the size of the assets we are downloading especially have a look at main.css and main.js. obviously these are not super big but still this is the size of the asset as we downloading them by default. 

![](images/449-compressing-assets-7.png)

![](images/449-compressing-assets-8.png)![449-compressing-assets-7.png](resources/6ABC773D96DB41DD8F2014E2FC9DB2A4.png)![449-compressing-assets-8.png](resources/BC522D3B1CEFD0414A31045EFD29B26E.png)

- after commenting, these got a bit smaller and this will matter more if you have more content assets in your application that you need to search.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');
const helmet = require('helmet');
const compression = require('compression');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

app.use(helmet());
app.use(compression());

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 450: Setting Up Request Logging
==========================================

1\. update

- app.js

![](images/450-setting-up-request-logging-1.png)![450-setting-up-request-logging-1.png](resources/96C1086967430E756BC33CCF082476DE.png)

- ’npm install —save morgan’ is the package that makes logging request data really simple. 

- ’npm run start:dev’ is my nodemon server

![](images/450-setting-up-request-logging-2.png)

![](images/450-setting-up-request-logging-3.png)![450-setting-up-request-logging-2.png](resources/83D349653567052A9D8C491054CAB7E9.png)![450-setting-up-request-logging-3.png](resources/94850B56F22CED4A154E47194BBC6E0B.png)

- if i reload, you will find some logging data here in the console. you see detailed logging information about the incoming request that we had a GET request which browser i used which operating system and so on. 

- we typically don’t wanna see that in the console when we deploy our application. instead some files would be nice and to log that 2 files, we just have to add something here.

![](images/450-setting-up-request-logging-4.png)

![](images/450-setting-up-request-logging-5.png)![450-setting-up-request-logging-4.png](resources/14C58DA0C9AAFB148ED9909E257BC9E4.png)![450-setting-up-request-logging-5.png](resources/9957402E6F95E0527C3A52C43361B305.png)

- now if i reload, we don’t have a log here but we have this new ‘access.log’ file and here we see the log data and that is how we would wanna log that.

```js
//app.js

const path = require('path');
const fs = require('fs');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

/**we write to log with 'access.log' into this filel
 * '{ flags: 'a' }' means append
 * so new data will be appended to that file
 * and not overwrite the existing file
 * but added at the end of file
 * so that we don't have log statement in the file
 * but we continuously add them to the file
 *
 * this 'writeStream' can be used by 'morgan'
 * and we passed this Stream to morgan
*/
const accessLogStream = fs.createWriteStream(
  path.join(
    __dirname,
    'access.log'),
    { flags: 'a' }
  );

app.use(helmet());
app.use(compression());
/**in parentheses,
 * pass the information on how to log this into this function
 * now you fnd more in the official docs
 * that defines which data is being locked
 * and how it's formatted
 * i will go with 'combined'
 *
 * 2nd argument will be used to log our requests
 * and they offer it with a reload */
app.use(morgan('combined', { stream:accessLogStream }));

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 452: Setting Up A SSL Server
=======================================

1\. update

- app.js

![](images/452-setting-up-a-ssl-server-1.png)![452-setting-up-a-ssl-server-1.png](resources/2C4C56AA30933AD6183D7368E811D080.png)

- TLS is newer version of SSL. people know more about SSL however both is about securing your data that is sent from a client to server. 

- one such encryption is in place, eavesdropping is not possible anymore because while the data is unreadable as long as it is in transit and it will be decrypted on the server now. to enable that encryption and to be able to decrypt it, we work with a public private key pair. both is known to the server. public key is not something we have to protect. private key will ever only be known by the server because the private key will later be important for decrypting the data. 

- identity is something like the domain, the admin, email address you set to get data when you create a certificate. SSL connects a public key and a server and send that to the client browser. so that the client also is aware of the public key and knows it belongs to that server. 

- when you create your own keys, then the browser doesn’t trust you that information in there is correct and that is when you get informations or warnings like hey does page uses SSL but doesn’t seem to be secure. do you really wanna visit it? hence in production you would use a SSL certificate provided by a known certificate authority which browser trusts and therefore you have a real secure and trusted protection. 

- nontheless the way it works always is the same, we have that public key part of that certificate ideally is not created by you but by a trusted authority. we will create it here on our own because that will be free. 

- public key is then received by the client through SSL certificate and now the client can encrypt the data which it sends to the server and the server can decrypt the data with that private key and only that private key can decrypt that data. 

![](images/452-setting-up-a-ssl-server-2.png)![452-setting-up-a-ssl-server-2.png](resources/4E2C3A3E7C7F064301B62DE5F711E4C8.png)

- we need to create a certificate and we do it with a command named ‘openssl’ on Mac and Linux. you have that available by default. 

- ‘openssl req -nodes - new -x509 -keyout server.key -out server.cert’ will give you that private key and the public key packaged up in a certificate. 

- once you hit enter, you will be asked a couple of questions and there make sure to choose valid values. though that doesn’t really matter too much but the idea here is that you connect your identity of your application to your public key. though again your own self-censored defecate will not be accepted by browsers anyways. for production you should not use that option still. 

- one important value is just common name. you must set this to ‘localhost’ otherwiase the certificate will not work because this has to be set to your domain. so if you were to use your self-signed certificate on the server, you deploy your app to and you host this app on [example.com](http://example.com) then you would have to set this to [example.com](http://example.com). again typically you request a certificate for your domain by some authority and then they will do this for you. but if you create your own one use the domain your app is running on and locally that is localhost and this certificate will be denied and he will not be accepted if you set another value. 

![](images/452-setting-up-a-ssl-server-3.png)![452-setting-up-a-ssl-server-3.png](resources/2D3E28A038665FFC28D6FDC427541256.png)

- after you did all that, you will find 2 new files ’server.cert’ which is the certificate and ’server.key’ which is the private key. now a private key will always on your server. the certificate is what we send to the client in the end. 

![](images/452-setting-up-a-ssl-server-4.png)

![](images/452-setting-up-a-ssl-server-5.png)

![](images/452-setting-up-a-ssl-server-6.png)

![](images/452-setting-up-a-ssl-server-7.png)![452-setting-up-a-ssl-server-4.png](resources/56B8BEBC4BA6296619690805D8B555EA.png)![452-setting-up-a-ssl-server-5.png](resources/1FB2B40B0E6EB575DC7C5C714D8A088B.png)![452-setting-up-a-ssl-server-6.png](resources/CB2259239E38B07685A7D29D6B970DFC.png)![452-setting-up-a-ssl-server-7.png](resources/82F4DDE8930E22EF50319980ED85C6DE.png)

- but on windows you don’t get by default. so you need a extra process.

![](images/452-setting-up-a-ssl-server-8.png)![452-setting-up-a-ssl-server-8.png](resources/55B3820DDD48304076EDD22B7C585B8E.png)

- now using SSL encryption and if we now go back to our application and really reload localhost:3000, this will fail because by default it uses to HTTP.

![](images/452-setting-up-a-ssl-server-9.png)![452-setting-up-a-ssl-server-9.png](resources/43A67BF09ADF3851ABEA08056EF72397.png)

- if i use <https://localhost:3000>, it will fail because the browser doesn’t accept that custom or that self-signed certificate as you learned. 

![](images/452-setting-up-a-ssl-server-10.png)

![](images/452-setting-up-a-ssl-server-11.png)![452-setting-up-a-ssl-server-10.png](resources/B1982AF2EDE8576FF6C952B1065C41B5.png)![452-setting-up-a-ssl-server-11.png](resources/42F29217E32DAA0465A04C3E41AE2BAD.png)

- but if you click on ADVANCED, you can proceed to localhost and again the browser does warn us because it doens’t like our self-signed certificate. but technically we are now using SSL protection and this is how you enable it. but just as with logging and compression, typically you would set this up differently. you would let your hosting provider set this up because technically the hosting provider often also has its own service in front of yours and the servers of the hosting provider then use SSL and to traffic between your app and the in-between servers does use HTTP because it’s blocked or it’s not available to the public and the hosting providers fronts would implement this logic. so you wouldn’t write that code on your own.

![](images/452-setting-up-a-ssl-server-12.png)![452-setting-up-a-ssl-server-12.png](resources/8C3383A1B114972CD8B8928FAFA1307C.png)

- and indeed i will fall back to my old code where i had app.listen because we will need that later when we deployed because we will let our hosting provider manage SSL. but if you ever need to do it manually, this is how you start a node server in HTTPS mode.

```js
//app.js

const path = require('path');
const fs = require('fs');
/**'https' allows us to spin up and HTTPS server
 * we directly or indirectly through app.listen() use the HTTP
 * now we will use HTTPS
 */
const https = require('https');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

/**'readFileSync' will block code execution 
 * until the is read 
 * and you will learn this is what you wanna do
 * but i don't wanna continue with starting the server
 * unless i have read that file.
 * 
 *  */
const privateKey = fs.readFileSync('server.key');
const certificate = fs.readFileSync('server.cert');

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

const accessLogStream = fs.createWriteStream(
  path.join(
    __dirname,
    'access.log'),
    { flags: 'a' }
  );

app.use(helmet());
app.use(compression());
app.use(morgan('combined', { stream:accessLogStream }));

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    /**1st argument is the server. 
     * here we have to point it at our private key and certificate
     * and the 2nd argument will be our request handler.
     * in our case, our express application.
     * so the 2nd argument will be our 'app'
     * 
     * 1st argument will be a javascript object
     * where you need to set 2 things 
     * you need to set the 'key: privateKey'
     * and you also need to set the cert key 
     * which you set to certificate constant we created. 
     */
    //https.createServer({ key: privateKey, cert: certificate }, app).listen(process.env.PORT || 3000);
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

\* Chapter 453: Using A Hosting Provider
========================================

![](images/453-using-a-hosting-provider-1.png)

![](images/453-using-a-hosting-provider-2.png)![453-using-a-hosting-provider-1.png](resources/E035EF323A59CA1172CE329EA7E1F1E4.png)![453-using-a-hosting-provider-2.png](resources/FFD5031BB4146A5C81F569A0E840C316.png)

- i will use a hosting provider called ‘Heroku’. 

![](images/453-using-a-hosting-provider-3.png)![453-using-a-hosting-provider-3.png](resources/73F23BC3C159009E9B96A6AA795116B4.png)

- virtual server means that these providers have very large and powerful machines in their data center and you don’t rent an entire machine. your code runs totally separated from the averages apps which might be running on the same computer on the same server. 

- ‘Managed Servers’ is invisible to you which you don’t configure. 

- this all runs in a privagte network which means that your own server and your code is not directly exposed to the web but it’s exposed to that managed server which then in turn talks to the web and they offer to your users througha public server gateway. and that is like a door where requests can come in there and then forward it to your server to your virtual server. 

\* Chapter 454: Understanding The Project & The Git Setup
=========================================================

![](images/454-understanding-the-project-and-the-git-setup-1.png)

![](images/454-understanding-the-project-and-the-git-setup-2.png)![454-understanding-the-project-and-the-git-setup-1.png](resources/963CB3035A296011324CB62378E08CFE.png)![454-understanding-the-project-and-the-git-setup-2.png](resources/88CEEC6436985161197D6CD1F950E09A.png)

- first of all, we can ignore the pipeline feature here. the deployment method will use 'Heroku Git’. Git is a tool which is not part of Heroku but used by Heroku.

![](images/454-understanding-the-project-and-the-git-setup-3.png)![454-understanding-the-project-and-the-git-setup-3.png](resources/019BEDB535F8ADD36D9D5EB210B63D8F.png)

- Git is a version control system and it’s totally optional but it helps a lot with saving and managing your source code. 

- it allows you to work with so-called commits branches and remote repositories to name some of its most important features

- commits are basically snapshots of your code which you can take. but when you can always switch so you can go back to the older version of your code and have a look at it and then go back to your most recent one or rollback to an older commit. this allows you to revert to older snapshots easily or safely added to code because you can always go back. you can create commit after bug fixes, new features and so on. 

- branches also allow you to not just have one history of snapshots but multiple histories for different version of your app. so you could have the master project where your production ready cde is in and then you wanna fix bugs or add new features in other branches so that your main code is untouched. but when a new feature done you can do something which is called ‘merging’ and merge the new feature branch with your main bransh so that you have one branch which you can put back into production again. but it allows you to work on different features in different branches without affecting your main finished code for now. 

- remote repositories means that your code is not only stored locally as it is by default but that you can store it and it’s commit and braches in the cloud and that means you can protect against loss of local data nad you can also access your source code from different machines and share it with average developers and you can use that feature to deploy your code automatically. that is what Heroku does because you will use Heroku as a remote repository which means when you push your code to that remote repository to Heroku, it will then be takenn by Heroku, and it will be put into production and a server will be spun up based on it automatically. 

![](images/454-understanding-the-project-and-the-git-setup-4.png)

![](images/454-understanding-the-project-and-the-git-setup-5.png)![454-understanding-the-project-and-the-git-setup-4.png](resources/CE41426902D59C6870D646BF95BCBF43.png)![454-understanding-the-project-and-the-git-setup-5.png](resources/636830942B22AAECB44D3EF40060C358.png)

\* Chapter 455: A Deployment Example With Heroku
================================================

1\. update

- package.json

- app.js

- Procfile

- .gitignore

![](images/455-a-deployment-example-with-heroku-1.png)![455-a-deployment-example-with-heroku-1.png](resources/3E6D1AC98A387739926B8BDFCDB4F9B8.png)

- the next steps on Heroku to use its CLI it’s command line interface. and that is Heroku specific on our hosting providers. you might simply be able to drag and drop your code. but Heroku doesn’t use such a drag and drop alternative instead Heroku uses that command line interface which allows you to run your code or to deploy your code. the command line by typing on commands. 

![](images/455-a-deployment-example-with-heroku-2.png)![455-a-deployment-example-with-heroku-2.png](resources/EC657F104377169207E78DA1A709F2EB.png)

- make sure to follow the instructions on the page.now i will go with my Mac OS version and i will quickly walk through the installer there and install Heroku on my system. click ‘Download the Installer’

![](images/455-a-deployment-example-with-heroku-3.png)

![](images/455-a-deployment-example-with-heroku-4.png)![455-a-deployment-example-with-heroku-3.png](resources/7D53638B1A41D1761717F71AB4D85CFA.png)![455-a-deployment-example-with-heroku-4.png](resources/3A34D8E9DEBF74DDCD3A16BE213ECAE9.png)

- once you installed it, the next step is to run this command and you run this in your normal terminal or command prompt. 

![](images/455-a-deployment-example-with-heroku-5.png)

![](images/455-a-deployment-example-with-heroku-6.png)

![](images/455-a-deployment-example-with-heroku-7.png)![455-a-deployment-example-with-heroku-5.png](resources/4D33A9464DDF08592DD093D331D75CD2.png)![455-a-deployment-example-with-heroku-6.png](resources/E4506716A77402F04A98E41F647C4BDE.png)![455-a-deployment-example-with-heroku-7.png](resources/9145CAE7306572BDB9E9AFDA9087395C.png)

- next in your package.json and follow of your project, you wanna add a new entry ‘engines’ entry anywhere maybe above the scripts and there add “node” and now set the version of node you are using. you can detect that by running ’node -v’ in your project folder or anywhere on your computer.

![](images/455-a-deployment-example-with-heroku-8.png) 

![](images/455-a-deployment-example-with-heroku-9.png)![455-a-deployment-example-with-heroku-8.png](resources/746CB4513580CBEE898B4F688F9B8E0E.png)![455-a-deployment-example-with-heroku-9.png](resources/20FF82FB88B899BEA57788F1658E4FDB.png)

- ‘Procfile’ is Heroku specific. Procfile without a file extension and you add ‘web: node app.js’ which will instruct Heroku to execute your app.js file when it tries to run your application.

![](images/455-a-deployment-example-with-heroku-10.png)

![](images/455-a-deployment-example-with-heroku-11.png)![455-a-deployment-example-with-heroku-10.png](resources/BA95FDA0DF86D1B9C141512DAB17EAFC.png)![455-a-deployment-example-with-heroku-11.png](resources/595178BC289AC883DE76D766CBBADBBD.png)

- .gitignore will tell git which folders it should not include in its snapshots and here the node\_modules folder is important. all your 3rd party package are stored there. and we won’t deploy that. because that will just increase the size of data we have to transmit over the wire. instead this will automatically be recreated on the Heroku because Heroku and that is the case for the hosting providers do install your dependencies on the server after you deploy your code. remember package.json. we have a list of all the 3rd party packages we are using and the words we need. so package.json will be taken by the hosting provider and it will install all these packages on the server. that is why we always use ’npm install —save’ because that added such entries to the packages.json file which can be used during the deployment.

![](images/455-a-deployment-example-with-heroku-12.png)

![](images/455-a-deployment-example-with-heroku-13.png)

![](images/455-a-deployment-example-with-heroku-14.png)![455-a-deployment-example-with-heroku-12.png](resources/E41321129FF3A979E8E2DEF23DF5056E.png)![455-a-deployment-example-with-heroku-13.png](resources/B9E2578DB0CC0EAE74CB966848B72D92.png)![455-a-deployment-example-with-heroku-14.png](resources/2CB4D2E6470845C59E5D683BA210DBCF.png)

- after all installed, with that you can go back to your dashboard and click on overview and you should see that 'build succeed’ and you can now click on ‘Open app’. this will open your app in a new tab and most likely this will not really succeed. 

![](images/455-a-deployment-example-with-heroku-15.png)

![](images/455-a-deployment-example-with-heroku-16.png)![455-a-deployment-example-with-heroku-15.png](resources/76285C81018FF0391EA778C00F184561.png)![455-a-deployment-example-with-heroku-16.png](resources/6765BA257294B8DAFDD93C8FB74CB795.png)

- and the reason for that is that we deployed our application but now if you type ‘heroku logs’ in your terminal, you will see what went wrong. and to be percise and the error message you will see that it failed to connect to the database and that make sense 

![](images/455-a-deployment-example-with-heroku-17.png)

![](images/455-a-deployment-example-with-heroku-18.png)

![](images/455-a-deployment-example-with-heroku-19.png)![455-a-deployment-example-with-heroku-17.png](resources/8C86E3EEEB8FD90CAB9B1B2BFE5BC84C.png)![455-a-deployment-example-with-heroku-18.png](resources/EC471BF50EDD788A376AB636DC909ED4.png)![455-a-deployment-example-with-heroku-19.png](resources/DBB92DD2C2E076C4B4F57D721C3B8C2A.png)

- because all our node environment variables which we rely on for example to connect to the database are now not set anymore because in Procfile, we instruct heroku to just execute the app.js file. this will not pass the environment variables only one environment variable is passed by default by default. by Heroku and that is node. and this is set to production. 

![](images/455-a-deployment-example-with-heroku-20.png)

![](images/455-a-deployment-example-with-heroku-21.png)

![](images/455-a-deployment-example-with-heroku-22.png)![455-a-deployment-example-with-heroku-20.png](resources/64C56332317232AB1DD4EFFCC94C023A.png)![455-a-deployment-example-with-heroku-21.png](resources/EF0FB3581F2F99735F217790115619AF.png)![455-a-deployment-example-with-heroku-22.png](resources/0FE64F3CC91EB0263435C14E8F7199F2.png)

- so now we have to do it on our ownn by simply grabbing ‘MONGO\_USER’ and going back toward dashboard and there on the dashboard, you wanna go to settings for your app and then go to config Vars. and now we have all these environment variables edits here. 

![](images/455-a-deployment-example-with-heroku-23.png)

![](images/455-a-deployment-example-with-heroku-24.png)![455-a-deployment-example-with-heroku-23.png](resources/52B736C4812B77D86FF5D1641C91D10A.png)![455-a-deployment-example-with-heroku-24.png](resources/225C721821A73AC97C3A93F817108CC6.png)

- we also need to change something on our mongoDB set up in our case becasue we are using that hosted mongoDB atlas solution. in atlas and in IP Whitelist, you need to wide list of IP of your running application. 

- and the thing about Heroku and its basic version is that we don’t have a static IP assigned to our project. instead it’s a dynamic range. 

- running MongoDB on the same server as your web project is not really an alternative because a database server is all not very trivial to set up especially if it should be able to scale and so on. 

![](images/455-a-deployment-example-with-heroku-25.png)

![](images/455-a-deployment-example-with-heroku-26.png)![455-a-deployment-example-with-heroku-25.png](resources/CC52E259F1E4983900AB91630C2E05FE.png)![455-a-deployment-example-with-heroku-26.png](resources/1B5F3B62B7D793EF0818C1870F729A81.png)

- click ‘Restart all dynos’ and let’s dive into our application. let’s try reloading our application. now there you should see a running app.

![](images/455-a-deployment-example-with-heroku-27.png)

![](images/455-a-deployment-example-with-heroku-28.png)

![](images/455-a-deployment-example-with-heroku-29.png)

![](images/455-a-deployment-example-with-heroku-30.png) ![455-a-deployment-example-with-heroku-27.png](resources/2EE8A5E52B8E39ADF2A557E20BCA5266.png)![455-a-deployment-example-with-heroku-28.png](resources/BC7332CBB229FB8E62652562B57F865C.png)![455-a-deployment-example-with-heroku-29.png](resources/2A9E03544E9BD451948E6A1297F7F6B0.png)![455-a-deployment-example-with-heroku-30.png](resources/26856A4AD1E315A91C036D213876BC52.png)

```js
//package.json

{
  "name": "nodejs-complete-guide",
  "version": "1.0.0",
  "description": "Complete Node.js Guide",
  "main": "app.js",
  "engines": {
    "node": "10.15.0"
  }
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "NODE_ENV=production MONGO_USER=maximilian MONGO_PASSWORD=rldnjs12 MONGO_DEFAULT_DATABASE=shop STRIPE_KEY=sk_test_dAPYh6CKcipsTX13kbjOFklT00NICMWhhg node app.js",
    "start-server": "node app.js",
    "start:dev": "nodemon app.js"
  },
  "author": "Maximilian Schwarzmüller",
  "license": "ISC",
  "devDependencies": {
    "nodemon": "^1.18.3"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.18.3",
    "compression": "^1.7.4",
    "connect-flash": "^0.1.1",
    "connect-mongodb-session": "^2.0.3",
    "csurf": "^1.9.0",
    "ejs": "^2.6.1",
    "express": "^4.16.3",
    "express-handlebars": "^3.0.0",
    "express-session": "^1.15.6",
    "express-validator": "^5.3.0",
    "helmet": "^3.18.0",
    "lodash": "^4.17.11",
    "mongodb": "^3.1.6",
    "mongoose": "^5.2.17",
    "morgan": "^1.9.1",
    "multer": "^1.4.0",
    "mysql2": "^1.6.1",
    "nodemailer": "^4.6.8",
    "nodemailer-sendgrid-transport": "^0.2.0",
    "pdfkit": "^0.8.3",
    "pug": "^2.0.3",
    "sequelize": "^5.0.0-beta.11",
    "stripe": "^6.12.1"
  }
}

```

```js
//app.js

const path = require('path');
const fs = require('fs');
const https = require('https');

const express = require('express');
const bodyParser = require('body-parser');
const mongoose = require('mongoose');
const session = require('express-session');
const MongoDBStore = require('connect-mongodb-session')(session);
const csrf = require('csurf');
const flash = require('connect-flash');
const multer = require('multer');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');

const errorController = require('./controllers/error');
const shopController = require('./controllers/shop');
const isAuth = require('./middleware/is-auth');
const User = require('./models/user');

const MONGODB_URI =
  `mongodb+srv://${process.env.MONGO_USER}:${process.env.MONGO_PASSWORD}@cluster0-z3vlk.mongodb.net/${process.env.MONGO_DEFAULT_DATABASE}`;

const app = express();
const store = new MongoDBStore({
  uri: MONGODB_URI,
  collection: 'sessions'
});
const csrfProtection = csrf();

/**also make sure that you are not trying to read in our certificate and private key for SSL
 * so comment out
 * because these files will not be deployed
 */
//const privateKey = fs.readFileSync('server.key');
//const certificate = fs.readFileSync('server.cert');

const fileStorage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'images');
  },
  filename: (req, file, cb) => {
    cb(null, new Date().toISOString() + '-' + file.originalname);
  }
});

const fileFilter = (req, file, cb) => {
  if (
    file.mimetype === 'image/png' ||
    file.mimetype === 'image/jpg' ||
    file.mimetype === 'image/jpeg'
  ) {
    cb(null, true);
  } else {
    cb(null, false);
  }
};

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');
const authRoutes = require('./routes/auth');

const accessLogStream = fs.createWriteStream(
  path.join(
    __dirname,
    'access.log'),
    { flags: 'a' }
  );

app.use(helmet());
/**for Heroku, you may wanna make sure you are using compression
 * because Heroku doesn't offer you to set up compression on the fly over hosting providers do that.
 */
app.use(compression());
app.use(morgan('combined', { stream:accessLogStream }));

app.use(bodyParser.urlencoded({ extended: false }));
app.use(
  multer({ storage: fileStorage, fileFilter: fileFilter }).single('image')
);
app.use(express.static(path.join(__dirname, 'public')));
app.use('/images', express.static(path.join(__dirname, 'images')));
app.use(
  session({
    secret: 'my secret',
    resave: false,
    saveUninitialized: false,
    store: store
  })
);

app.use(flash());

app.use((req, res, next) => {
  res.locals.isAuthenticated = req.session.isLoggedIn;
  next();
});

app.use((req, res, next) => {
  // throw new Error('Sync Dummy');
  if (!req.session.user) {
    return next();
  }
  User.findById(req.session.user._id)
    .then(user => {
      if (!user) {
        return next();
      }
      req.user = user;
      next();
    })
    .catch(err => {
      next(new Error(err));
    });
});

app.post('/create-order', isAuth, shopController.postOrder);

app.use(csrfProtection);
app.use((req, res, next) => {
  res.locals.csrfToken = req.csrfToken();
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);
app.use(authRoutes);

app.get('/500', errorController.get500);

app.use(errorController.get404);

app.use((error, req, res, next) => {
  // res.status(error.httpStatusCode).render(...);
  // res.redirect('/500');
  res.status(500).render('500', {
    pageTitle: 'Error!',
    path: '/500',
    isAuthenticated: req.session.isLoggedIn
  });
});

mongoose
  .connect(MONGODB_URI)
  .then(result => {
    /**because will not use SSL,
     * here, you should not be spinning up your own HTTPS server
     * because we will do taht through Heroku managed server
     * or you would do it for Heroku's managed server
     * so spin up a normal HTTP server instead.
     */
    //https.createServer({ key: privateKey, cert: certificate }, app).listen(process.env.PORT || 3000);
    app.listen(process.env.PORT || 3000);
  })
  .catch(err => {
    console.log(err);
  });

```

```js
//Procfile

web: node app.js
```

```js
//.gitignore

node_modules
server.cert
server.key
```

\* Chapter 456: Storing User-Generated Files On Heroku
======================================================

- Storing User-generated Files on Heroku: The user-generated/ uploaded images are saved and served as intended. but like all hosting providers that offer virtual servers, your file storage is not persistent.

- your source code is saved and re-deployed when you shut down the server(or when it goes to sleep, as it does automatically after some time in the Heroku free tier)

- but you generated and uploaded files are not stored and re-created. they would be lost after a server restart

- therefore it’s recommended that you use a different storage place when using such a hosting provider. in case where you run your own server, which you fully own/ manage, that does of course not apply. what would be alternatives?

- a popular and very efficient + affordable alternative is AWS S3(Simple Storage Service): <https://aws.amazon.com/s3/>

- you can esily configure multer to store your files there with the help of another package: <https://www.npmjs.com/package/multer-s3>

- to also serve your files, you can use packages like s3-proxy: <https://www.npmjs.com/package/s3-proxy>

- for deleting the files (or interacting with them on your own in general), you would use the AWS SDK: <https://aws.amazon.com/sdk-for-node-js/>

\* Chapter 457: Deploying APIs
==============================

![](images/457-deploying-apis-1.png)![457-deploying-apis-1.png](resources/DB05C639D8A0176120FDA9473C6C5607.png)

- we have the API running now where we can send requests to and will then be our front-end application or our mobile application where we have to adjust. you are able to send the request to our now running hosted application and not to localhost anymore.

- so there in your application, you will have to exchange your hosted domain, not localhost.

- and then the front-end app or the mobile app is deployed differently anyways.