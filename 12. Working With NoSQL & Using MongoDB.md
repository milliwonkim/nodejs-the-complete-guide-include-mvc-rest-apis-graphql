\* Chapter 172: Module Introduction
===================================

![](images/172-module-introduction-1.png)

\* Chapter 173: What Is MongoDB?
================================

![](images/173-what-is-mongodb-1.png)

- for example a shop database, now in such a database in the SQL world, we would have multiple tables.

- in the NoSQL MongoDB world, we have multiple collections like the users and orders collection for example.

- inside of each collection, we don’t have so-called ‘records’ but we have a couple of ‘documents'. ‘documents’ also look different than records did and it’s not just about different names being used. the core philosophy behind the database is totally different one. 

- for example, MongoDB is schemaless, inside of one collection, your documents which is your data, your entry don’t have to have the same structure. but in SQL that was totally different. we had a users table and in that users table, we had an ID, a name, an email, a password. but in here we can have any kind of data in one and the same collection. often you will still end up with an at least similar structure but you are not forced to have exactly same structure. and this gives you more flexibility, also for your application to grow and to change its data requirements overtime without that being difficult to depict in your database world. 

![](images/173-what-is-mongodb-2.png)

- A Document in MongoDB looks like this. 

- MongoDB uses JSON to store data in collections. to be very precise, MongoDB uses something which is called BSON for binary JSON but that only means that MongoDB kind of transforms this behind the scenes before storing it in the files. but you will basically use it as JSON. 

- you can also have arrays inside of that document and that array can hold other documents, other objects or it could also just hold strings, numbers, anything of that kind. 

- the existence of these nested documents also means that relations are managed a bit differently in the NoSQL MongoDB world. 

\* Chapter 174: Relations In NoSQL
==================================

![](images/174-relations-in-nosql-1.png)

- this gives you more flexibility, also regarding the storage of relations between different data.

![](images/174-relations-in-nosql-2.png)

- In NoSQL, it would be pretty normal to have something like this.

- here are 3 collections and we have some duplicate data in there.

- instead of just matching by ID as you do in the SQL world, here you can also depict a relation by embeddnig data into other documents. you could embedded the ID which points at another document, so that you still have to merge 2 documents manually and you will have to do that pretty manually. 

- but you can also just take the information that is important for you in the context of another document. in here, some user data for the orders and you copy that into the orders. and then you have that data whenever you fetch all orders without you having to fetch all orders, then look for the fitting users and fetch them too. this is part of what makes NoSQL so fast and efficient. 

![](images/174-relations-in-nosql-3.png)

- here’s the embedded document example where the address is part of our customer document. so instead of having 2 collections, customers and address and then matching by ID, here we put the address right into the customer.

- there also are cases where you would have a lot of data duplication and where you need to work with that data a lot. and hence it would change a lot and you would have to manually update it in all duplicate plcaes where using embedded documents is not ideal. so for example if you have some favorite books for every customer, you would have lots of data duplication because a lot of customers might have the same favorite books and these books might change a lot. you would have to go to all customers who have these books as favorites and update the entries for each customer. 

- so it would be easier to go with 2 collections and only store the references to the books in a customers documents and then manually merge that with the books which are managed in a different collection

![](images/174-relations-in-nosql-4.png)

\* Chapter 175: Setting Up MongoDB
==================================

![](images/175-setting-up-mongodb-1.png)

- i would go for a cloud solution becasue it’s the more realistic environment. we would use for deployment and it’s really easy to set up and it’s free. 

- and that will be ‘Atlas’. so MongoDB Atlas. 

![](images/175-setting-up-mongodb-2.png)

- once you did sign up, you should end up on a page that looks something like this. 

![](images/175-setting-up-mongodb-3.png)

- maybe you need to create a new project first, give it any name you want and then you should be on that. 

- or you can build a new cluster. you might end up in that wizard right from the start. 

- you can generally leave all the default settings. make sure that you choose a regine where free tier is available. 

![](images/175-setting-up-mongodb-4.png)

- and then you choose the cluster tier and there you should use the free one. M0\. 

![](images/175-setting-up-mongodb-5.png)

- Under additional settings, you can leave all the defaults

![](images/175-setting-up-mongodb-6.png)

- you can change the cluster name and then you can click create cluster

![](images/175-setting-up-mongodb-7.png)

- while this is getting set up, you can already click on security and make sure that you add at least one new user which has ‘Read and write to any database’. 

- you can turn it into ‘Atlas admin’ but more realistic is this ‘Read and write to any database’ because this will later be the role which our node.js application assumes which should be able to read and write our database but not to administrate them because we will not do database administration through node.js, that would be something our database admin does. 

![](images/175-setting-up-mongodb-8.png)

- you can also sign your own password or auto-generate a secure one. make sure you save that because you will need it later. 

![](images/175-setting-up-mongodb-9.png)

- and also make sure you have a look at IP whitelist. there you see all the IP addresses that are allowed to connect to your MongoDB server. these server will probably be seen less for you. 

- one thing you should do here is you should add a new IP address and add your current IP address since the node app runs locally on your machine. your node app will have this IP address. later when you deploy the node app, this should use the IP address of your server where yo deploy it to. 

- here you can use your local one so that you can connect and your node app can connect to that server. that’s a good security feature because this makes sure that no unauthorised access can happen to your database. so your database is now locked down both from a IP perspective but also from a user perspective. 

![](images/175-setting-up-mongodb-10.png)

- now we can connect to our MongoDB server from insdie our node app and we can click on ‘connect’ here and choose a connection method which in our case will be an application. so ‘Connect Your Application’

![](images/175-setting-up-mongodb-11.png)

- here we can check i’m using this driver and we get this URL which we will need soon. but first of all, we need to install the MongoDB driver, in our case for Node.js. 

\* Chapter 176: Installing The MongoDB Driver
=============================================

1\. update

- app.js

- ./util/database.js

![](images/176-installing-the-mongodb-driver-1.png)

- we can start using it and we can start using it in the first file that gets executed when we bring up our server which would be the app.js file. 

![](images/176-installing-the-mongodb-driver-2.png)

- we see ‘connected’ and then we see this ‘MongoClient’ object which we got with some details about the connection and this is in the end the object which we will be able to interact with, to work with to create data in our database for example.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

//const adminRoutes = require('./routes/admin');
//const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
/*
    User.findByPk(1)
        .then(user => {
            req.user = user
            next()
        })
        .catch(err => console.log(err))
*/
})

//app.use('/admin', adminRoutes);
//app.use(shopRoutes);

app.use(errorController.get404);

/**we hve to pass a callback so function that will get executed
 * once we connect it
 * and here i will get access to the client object
 */
mongoConnect((client) => {
    console.log(client)
    app.listen(3000)
})
```

```js
//./util/database.js

const mongodb = require('mongodb')
/**we can extract a Mongo Client constructor by simply accessing mongodb */
const MongoClient = mongodb.MongoClient

const mongoConnect = (callback) => {
/**now we can use that client to connect to our mongodb database. 
 * this is all we need to do to create a connection to MongoDB
 * 
 * in 'connect()' takes a URL to connect and that URL is what you are have in the connect modal on the MongoDB Atlas cluster page
 * the important thing is that you need to make sure you are using the right user
 * and in my case that should be 'maximilian' the user you created in your MongoDB cluster under security
 * and the fitting password filled when you add user.
*/
MongoClient
    .connect(
        'mongodb+srv://maximilian:DD5EbADjazBuTqk@cluster0-z3vlk.mongodb.net/test?retryWrites=true'
    )
    .then(client => {
        console.log('Connected!')
        callback(client)
    })
    .catch(err => console.log(err))
}

module.exports = mongoConnect

```

\* Chapter 177: Creating The Database Connection
================================================

1\. update

- ./models/product.js

- ./util/database.js

- app.js

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
//const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
/*
    User.findByPk(1)
        .then(user => {
            req.user = user
            next()
        })
        .catch(err => console.log(err))
*/
})

//app.use('/admin', adminRoutes);
//app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect((client) => {
    console.log(client)
    app.listen(3000)
})
```

```js
//./models/product.js

const mongoConnect = require('./util/database')

class Product {
  constructor(title, price, description, imageUrl){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
  }
/** this is a function which can be executed on this class
 * and in here i now wanna connect to MongoDB and save my product.
 * now to do that, to be able to connect, i will need to import MongoDB or mongoConnect
 * 
 * so i simply import the function i created inside './util/database'
 * where you pass a callback to,
 * where we connect to MongoDB inside.
 */
  save(){

  }
}

const Product = sequelize.define('product', {
  id: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    allowNull: false,
    primaryKey: true
  },
  title: Sequelize.STRING,
  price: {
    type: Sequelize.DOUBLE,
    allowNull: false
  },
  imageUrl: {
    type: Sequelize.STRING,
    allowNull: false
  },
  description: {
    type: Sequelize.STRING,
    allowNull: false
  }
});

module.exports = Product;


```

```js
//./util/database.js

const mongodb = require('mongodb')

const MongoClient = mongodb.MongoClient

/**we execute the callback and return the connected client
 * so that we can interact with it
 * however if you would this,
 * we would have to connect to MongoDB for every operation we do
 * and we would not even disconnect thereafter
 * so this is not good way of connecting to MongoDB since we will wanna connect and interact with it from different places in our app.
 * 
 * so it would be better if we could manage one connection in our database
 * and then simply return access to the client which we set up once from there
 * or to the different place in our app that need access
 */
const mongoConnect = (callback) => {
MongoClient
    .connect(
        'mongodb+srv://maximilian:DD5EbADjazBuTqk@cluster0-z3vlk.mongodb.net/test?retryWrites=true'
    )
    .then(client => {
        console.log('Connected!')
        callback(client)
    })
    .catch(err => console.log(err))
}

module.exports = mongoConnect

```

\* Chapter 178: Finishing The Database Connection
=================================================

1\. update

- ./util/database.js

- app.js

- ./models/product.js

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
//const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
/*
    User.findByPk(1)
        .then(user => {
            req.user = user
            next()
        })
        .catch(err => console.log(err))
*/
})

//app.use('/admin', adminRoutes);
//app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
    app.listen(3000)
})
```

```js
//./models/product.js

/**Using 'getDb' means that i can now call this function
 * to get access to my database
 * and therefore i can use it to interact with the database.
 */
const getDb = require('./util/database').getDb

class Product {
  constructor(title, price, description, imageUrl){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
  }
  save(){

  }
}

const Product = sequelize.define('product', {
  id: {
    type: Sequelize.INTEGER,
    autoIncrement: true,
    allowNull: false,
    primaryKey: true
  },
  title: Sequelize.STRING,
  price: {
    type: Sequelize.DOUBLE,
    allowNull: false
  },
  imageUrl: {
    type: Sequelize.STRING,
    allowNull: false
  },
  description: {
    type: Sequelize.STRING,
    allowNull: false
  }
});

module.exports = Product;


```

```js
//./util/database.js

const mongodb = require('mongodb')
const MongoClient = mongodb.MongoClient

/**instead i willl add a variable _db
 * underscore '_' is only here to signal
 * that this will only be used internally in this file
 * initially '_db' is undefined.
 */
let _db

/**i'm exporting 2 method
 * one for connecting and then storing the connection to the database
 * this will keep on running
 */
const mongoConnect = (callback) => {
MongoClient
    .connect(
        /**what we will do is we will connect to the 'test' database by default
         * because that is what we specify in our connection string.'mongodb+srv://maximilian:DD5EbADjazBuTqk@cluster0-z3vlk.mongodb.net/\\\test\\\?retryWrites=true'
         * so we will connect to shop (replace 'test' to 'shop') 'mongodb+srv://maximilian:DD5EbADjazBuTqk@cluster0-z3vlk.mongodb.net/\\\shop\\\?retryWrites=true'
         * this will give us access to the shop database to which we automatically connect
         *
         * on the side note, unlike in SQL
         * we never need to create that database or the tables, the collections in there ahead of time
         * it will be created on the fly
         * when we first access it
         * which is again fitting that flexibility theme MongoDB gives us
         *
         * In SQL, we had to prepare everything in advance, at least when not using sequelize
         * which also had to do that but it did it for us.
         * we don't need to do anything. we are just telling MongoDB
         * hey connect me to the shop database
         * and if that database doesn't exist yet, MongoDB will create it as soon as we start writing data to it.
         */
        'mongodb+srv://maximilian:DD5EbADjazBuTqk@cluster0-z3vlk.mongodb.net/shop?retryWrites=true'
    )
    .then(client => {
        console.log('Connected!')
        /**i will store access to the database here*/
        _db = client.db()
        callback(client)
    })
    .catch(err => {
        console.log(err)
        throw err
    })
}

/**and i have one method where i return access to that connected database
 * if it exists and mongoDB behind the scenes will manage this very elegantly with something called 'connection pooling'
 * where mongoDB will make sure it provides sufficient connections for multiple simultaneous interactions with the database
 *
 * so this is really a good pattern we should follow
*/
const getDb = () => {
    if(_db){
        return _db
    }
    throw 'No database found!'
}

exports.mongoConnect = mongoConnect
exports.getDb = getDb
```

\* Chapter 179: Using The Database Connection
=============================================

![](images/179-using-the-database-connection-1.png)

\* Chapter 180: Creating Products
=================================

1\. update

- ./models/product.js

- ./controllers/admin.js

- ./routes/admin.js

- app.js

![](images/180-creating-products-1.png)

![](images/180-creating-products-2.png)

- go back to the form and resubmit that, i’m redirected to a page which is not found because i commented out all the shop pages. 

![](images/180-creating-products-3.png)

![](images/180-creating-products-4.png)

- but if we go back to our server side console, we see something interesting. 

- we see that this here has to be the output of this console log line in the ./models/product.js where i print the result of the insert operation and there we see a lot of data about that operation. 

![](images/180-creating-products-5.png)

- if we scroll down to the bottom, we see one document was inserted. ‘insertedCount: 1’. it received an ID and such an ID is managed automatically by MongoDB because every document needs to have such a \_id. this is must-have and MongoDB creates it on the fly automatically if the object you entered doesn’t have it. so we will use that auto-generated ID

- and then you see the data which we entered also was stored. 

- while we can’t look into database yet because we are not fetching anything, we see that our insert one operation was successful and did successfully add a product into the collection.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database').mongoConnect;

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
  // User.findById(1)
  //   .then(user => {
  //     req.user = user;
  //     next();
  //   })
  //   .catch(err => console.log(err));
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
  app.listen(3000);
});

```

```js
//./models/product.js

/**we are importing something
 * which allows us to get access to the database connection we set up initially
 * when starting our server which now is a concept that we can reuse
 */
const getDb = require('../util/database').getDb

class Product {
  constructor(title, price, description, imageUrl){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
  }
  save(){
    const db = getDb()
    /**you can call 'collection()'
     * to tell mongoDB into which collection you wanna insert something
     * or with which collection you wanna work
     * remember in MongoDB, you have database, collections, documents
     * 
     * we have database connection here
     * so the next level is a collection
     * we can connect to any collection and just as with the database,
     * if it doesn't exist yet, it will be created the first time you insert data.
     * 
     * on that collection, we can execute a couple of MongoDB commands or operations
     * if you wanna insert data,
     * you can do this with 'insertOne()'
     * or if it's multiple documents at once, 'insertMany()'
     * which takes an array of javascript objects you wanna insert
     */

     /**here our case, it's the Product which we wanna insert
      * so we could just say 'this'
      * and see how that works 
      */
    return db.collection('products')
      .insertOne(this)
      .then(result => {
        console.log(result)
      })
      .catch(err => {
        console.log(err)
      })
  }
}

module.exports = Product;


```

```js
// ./controllers/admin.js

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(title, price, description, imageUrl);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};

/*
exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  req.user
    .getProducts({ where: { id: prodId } })
  //Product.findByPk(prodId)
  /**keep in mind we get back an array even if it only holds one element.
   * so we got 'products'
   * and therefore we know that one product,
   * the one we are interested in will always be the first element
   * so we have to store that separately in a new constant */
/*  
  .then(products => {
    const product = products[0]
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;
  Product.findByPk(prodId)
    .then(product => {
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save();
    })
    .then(result => {
      console.log('UPDATED PRODUCT!');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  req.user
    .getProducts()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return product.destroy()
    })
    .then(result => {
      console.log('DESTROYED PRODUCT')
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err))
};
*/
```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');

const adminController = require('../controllers/admin');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', adminController.getAddProduct);

/*
// /admin/products => GET
router.get('/products', adminController.getProducts);
*/

// /admin/add-product => POST
router.post('/add-product', adminController.postAddProduct);

/*
router.get('/edit-product/:productId', adminController.getEditProduct);

router.post('/edit-product', adminController.postEditProduct);

router.post('/delete-product', adminController.postDeleteProduct);
*/

module.exports = router;
```

\* Chapter 181: Understanding The MongoDB Compass
=================================================

![](images/181-understanding-the-mongodb-compass-1.png)

- you can choose that and you can download and install MongoDB Compass for free as well.

![](images/181-understanding-the-mongodb-compass-2.png)

- once you get that installed, you can start your compass application on your machine. and this essentially is a tool that gives you a graphical user interface to connect to your database and to interact with it.

- once it did start up, you can connect to it.

![](images/181-understanding-the-mongodb-compass-3.png)

![](images/181-understanding-the-mongodb-compass-4.png)

![](images/181-understanding-the-mongodb-compass-5.png)

- to connect to it, go back to our MongoDB cluster and click ‘connect’ here and then click ‘connect with MongoDB Compass’ and choose your operating system and then copy that URL down there.

![](images/181-understanding-the-mongodb-compass-6.png)

- the one cool thing is if you now quickly close compass and again you restart it after you copied that URL, it should tell you that it detected a connection string. and if you click yes, it will insert the most important pieces here. 

![](images/181-understanding-the-mongodb-compass-7.png)

- you still need to choose how you wanna connect, make sure that your username is correct and also enter the password for this user. all the defaults can be left as they are and you should be able to now connect to your database. 

![](images/181-understanding-the-mongodb-compass-8.png)

- you are now connected to the database server. and you can see a couple of databases, 2 default ones which you don’t need to touch but then also your own one, ‘shop’

![](images/181-understanding-the-mongodb-compass-9.png)

- and the shop database here has a products collection. 

![](images/181-understanding-the-mongodb-compass-10.png)

- if we look into that products collection, in there, we can see the documents that are stored in there. here’s that one document we inserted. so it is one product we added in the last lecture. 

\* Chapter 182: Fetching All Products
=====================================

1\. update

- ./models/product.js

- ./controllers/shop.js

- ./routes/shop.js

- app.js

![](images/182-fetching-all-products-1.png)

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database').mongoConnect;

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
  // User.findById(1)
  //   .then(user => {
  //     req.user = user;
  //     next();
  //   })
  //   .catch(err => console.log(err));
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
  app.listen(3000);
});

```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findByPk(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(cart => {
      return cart
        .getProducts()
        .then(products => {
          res.render('shop/cart', {
            path: '/cart',
            pageTitle: 'Your Cart',
            products: products
          });
        })
        .catch(err => console.log(err));
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  let fetchedCart;
  let newQuantity = 1;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      let product;
      if (products.length > 0) {
        product = products[0];
      }

      if (product) {
        const oldQuantity = product.cartItem.quantity;
        newQuantity = oldQuantity + 1;
        return product;
      }
      return Product.findByPk(prodId);
    })
    .then(product => {
      return fetchedCart.addProduct(product, {
        through: { quantity: newQuantity }
      });
    })
    .then(() => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .getCart()
    .then(cart => {
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      const product = products[0];
      return product.cartItem.destroy();
    })
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({include: ['products']})
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

/*
router.get('/products/:productId', shopController.getProduct);

router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

router.post('/cart-delete-item', shopController.postCartDeleteProduct);

router.post('/create-order', shopController.postOrder)

router.get('/orders', shopController.getOrders);
*/

module.exports = router;

```

```js
//./models/product.js

const getDb = require('../util/database').getDb

class Product {
  constructor(title, price, description, imageUrl){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
  }
  save(){
    const db = getDb()
    return db.collection('products')
      .insertOne(this)
      .then(result => {
        console.log(result)
      })
      .catch(err => {
        console.log(err)
      })
  }

  static fetchAll(){
    const db = getDb()
    /**here i wanna interact with my MongoDB database
     * to 'fetchAll()' products
     * 
     * MongoDB has a method for finding data
     * which is called 'find()'
     * 'find()' could be configured to also use a filter
     * i wanna find all products which i can do
     * by calling 'find()'
     * 
     * the important thing is that
     * 'find()' doesn't immediately returna promise.
     * instead it returns so-called 'cursor' which is an object provieded by MongoDB
     * a 'cursor' is an object provided by MongoDB
     * which allows us to go through our elements, our documents step by step 
     * because theoretically in a collection, 
     * 'find()' could return millions of documents
     * and you don't wanna transfer them over the wire all at once.
     * instead 'find()' gives you a handle which you can use to tell MongoDB
     * OK give me the next document, OK give me the next document and so on.
     * 
     * there's 'toArray()' method you can execute to tell MongoDB
     * to get all documents and turn them into a javascript array.
     * but you should only use that if we are talking about a couple of dozens or maybe 1 hundred documents.
     * otherwise it's better to implemenet pagination
     * which is something we will implement at a later point of time.
     * 
     * */
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products)
        return products
      })
      .catch(err => {
        console.log(err)
      })
  }
}

module.exports = Product;


```

\* Chapter 183: Fetching A Single Product
=========================================

1\. update

- ./models/product.js

- ./routes/shop.js

- ./views/shop/index.ejs

- ./views/product-list.ejs

- ./controllers/shop.js

![](images/183-fetching-a-single-product-1.png)

![](images/183-fetching-a-single-product-2.png)

![](images/183-fetching-a-single-product-3.png)

- why do i get cannot read property ‘title' of null? for one it’s worth noting that null is printed here as well and that null should be stemming from my product model from findById() when i console.log the product. 

- so it looks like we didn’t find any product for that ID and what could be the reason for that? 

![](images/183-fetching-a-single-product-4.png)

- the reason for that is that The ID in MongoDB is stored a bit differently and we can see this in MongoDB Compass. the ID is such an object id thing. 

- MongoDB stores data in BSON format and this binary format of JSON is not used because it’s bit faster to work with. but also because MongoDB can store some special types of data in there and object id is such a type.

- it’s a type added by MongoDB, it’s not a default Javascript type, it doesn’t exist in javascript at all. it’s simply an ID object which MongoDB uses because this generates and manages IDs which looks random but actually not. so IDs are created in a way that if you create an ID not and an ID one second later, will alphabetically be a higher value than the previous one. that’s the one thing

- object id is an object provided by MongoDB. 

- we can’t compare ‘\_id’ which in the database will only hold object id values with a string because a string is not equal to the object id and the string in here doesn’t count, MongoDB will not compare this. it compares the entire object, the entire object ID. 

- so fix this, we simply go into our ./models/product.js, i will import ‘const mongodb = require(‘mongodb’)’ and i can use mongodb to get access to that object \_id type

- so i can use ‘{\_id: mongodb.ObjectId(prodId)}'

![](images/183-fetching-a-single-product-5.png)

- now if i save that, now you see this works.

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);
/*
router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

router.post('/cart-delete-item', shopController.postCartDeleteProduct);

router.post('/create-order', shopController.postOrder)

router.get('/orders', shopController.getOrders);
*/

module.exports = router;

```

```js
//./models/product.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

class Product {
  constructor(title, price, description, imageUrl){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
  }
  save(){
    const db = getDb()
    return db.collection('products')
      .insertOne(this)
      .then(result => {
        console.log(result)
      })
      .catch(err => {
        console.log(err)
      })
  }

  static fetchAll(){
    const db = getDb()
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products)
        return products
      })
      .catch(err => {
        console.log(err)
      })
  }

  static findById(prodId){
    const db = getDb()
    /**i will find a product here
     * but i will find only one product
     * and to do that,
     * i will narrow down the result set with 'find()'
     * and then i will pass a javascript object to it
     * which allow me to configure a filter and here i wanna look for a product where _id is equal to 'prodId'
     * because that's the ID i'm looking for
     * 
     * 'find()' will still give me a cursor 
     * because MongoDB doesn't know that i will only get one 
     * an here we can use 'next()' function to get next
     * and in this case also the last document that was returned by 'find()' here.
     */
    return db
      .collection('products')
/** why do i get cannot read property ‘title' of null? for one it’s worth noting that null is printed here as well and that null should be stemming from my product model from findById() when i console.log the product. 
  * so it looks like we didn’t find any product for that ID and what could be the reason for that? 

  * the reason for that is that The ID in MongoDB is stored a bit differently and we can see this in MongoDB Compass. the ID is such an object id thing. 
  * MongoDB stores data in BSON format and this binary format of JSON is not used because it’s bit faster to work with. but also because MongoDB can store some special types of data in there and object id is such a type.
  * it’s a type added by MongoDB, it’s not a default Javascript type, it doesn’t exist in javascript at all. it’s simply an ID object which MongoDB uses because this generates and manages IDs which looks random but actually not. so IDs are created in a way that if you create an ID not and an ID one second later, will alphabetically be a higher value than the previous one. that’s the one thing
  * object id is an object provided by MongoDB. 
  * we can’t compare ‘_id’ which in the database will only hold object id values with a string because a string is not equal to the object id and the string in here doesn’t count, MongoDB will not compare this. it compares the entire object, the entire object ID. 
  * so fix this, we simply go into our ./models/product.js, i will import ‘const mongodb = require(‘mongodb’)’ 
  * and i can use mongodb to get access to that object _id type
  * so i can use ‘{_id: mongodb.ObjectId(prodId)}'
  * 'new' is a constructor
  * and a new objectId to which i pass a string which will be wrapped by that.
  * */
      .find({_id: new mongodb.ObjectId(prodId)})
      .next()
      .then(product => {
        console.log(product)
        return product
      })
      .catch(err => {
        console.log(err)
      })
  }
}

module.exports = Product;


```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(cart => {
      return cart
        .getProducts()
        .then(products => {
          res.render('shop/cart', {
            path: '/cart',
            pageTitle: 'Your Cart',
            products: products
          });
        })
        .catch(err => console.log(err));
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  let fetchedCart;
  let newQuantity = 1;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      let product;
      if (products.length > 0) {
        product = products[0];
      }

      if (product) {
        const oldQuantity = product.cartItem.quantity;
        newQuantity = oldQuantity + 1;
        return product;
      }
      return Product.findByPk(prodId);
    })
    .then(product => {
      return fetchedCart.addProduct(product, {
        through: { quantity: newQuantity }
      });
    })
    .then(() => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .getCart()
    .then(cart => {
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      const product = products[0];
      return product.cartItem.destroy();
    })
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({include: ['products']})
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
<!--./views/shop/index.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
    <%- include('../includes/navigation.ejs') %>

    <main>
        <% if (prods.length > 0) { %>
            <div class="grid">
                <% for (let product of prods) { %>
                    <article class="card product-item">
                        <header class="card__header">
                            <h1 class="product__title"><%= product.title %></h1>
                        </header>
                        <div class="card__image">
                            <img src="<%= product.imageUrl %>"
                                alt="<%= product.title %>">
                        </div>
                        <div class="card__content">
                            <h2 class="product__price">$<%= product.price %></h2>
                            <p class="product__description"><%= product.description %></p>
                        </div>
                        <div class="card__actions">
                            <a href="/products/<%= product._id %>" class="btn">Details</a>
                            <%- include('../includes/add-to-cart.ejs', {product: product}) %>
                        </div>
                    </article>
                <% } %>
            </div>
        <% } else { %>
            <h1>No Products Found!</h1>
        <% } %>
    </main>
<%- include('../includes/end.ejs') %>
```

```js
<!--./views/shop/product-list.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>

            <main>
                <% if (prods.length > 0) { %>
                    <div class="grid">
                        <% for (let product of prods) { %>
                            <article class="card product-item">
                                <header class="card__header">
                                    <h1 class="product__title">
                                        <%= product.title %>
                                    </h1>
                                </header>
                                <div class="card__image">
                                    <img src="<%= product.imageUrl %>" alt="<%= product.title %>">
                                </div>
                                <div class="card__content">
                                    <h2 class="product__price">$
                                        <%= product.price %>
                                    </h2>
                                    <p class="product__description">
                                        <%= product.description %>
                                    </p>
                                </div>
                                <div class="card__actions">
                                    <a href="/products/<%= product._id %>" class="btn">Details</a>
                                    <%- include('../includes/add-to-cart.ejs', {product: product}) %>                                                        </div>
                            </article>
                            <% } %>
                    </div>
                    <% } else { %>
                        <h1>No Products Found!</h1>
                        <% } %>
            </main>
            <%- include('../includes/end.ejs') %>
```

\* Chapter 184: Making The “Edit” & “Delete” Buttons Work Again
===============================================================

1\. update

- ./routes/admin.js

- ./controllers/admin.js

- ./vies/admin/products.ejs

![](images/184-making-the-edit-and-delete-buttons-work-again-1.png)

![](images/184-making-the-edit-and-delete-buttons-work-again-2.png)

- now with that in place, if we reload that page, our edit and our delete button should work again and should make sure that we edit or delete the right product.

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');

const adminController = require('../controllers/admin');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', adminController.getAddProduct);

// /admin/products => GET
router.get('/products', adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', adminController.postAddProduct);

/*
router.get('/edit-product/:productId', adminController.getEditProduct);

router.post('/edit-product', adminController.postEditProduct);

router.post('/delete-product', adminController.postDeleteProduct);
*/

module.exports = router;
```

```js
// ./controllers/admin.js

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(title, price, description, imageUrl);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};

/*
exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  req.user
    .getProducts({ where: { id: prodId } })
  //Product.findByPk(prodId)
  /**keep in mind we get back an array even if it only holds one element.
   * so we got 'products'
   * and therefore we know that one product,
   * the one we are interested in will always be the first element
   * so we have to store that separately in a new constant */
/*  
  .then(products => {
    const product = products[0]
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;
  Product.findByPk(prodId)
    .then(product => {
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save();
    })
    .then(result => {
      console.log('UPDATED PRODUCT!');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};
*/

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

/*
exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return product.destroy()
    })
    .then(result => {
      console.log('DESTROYED PRODUCT')
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err))
};
*/
```

```js
<!--./views/admin/products.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/product.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>

            <main>
                <% if (prods.length > 0) { %>
                    <div class="grid">
                        <% for (let product of prods) { %>
                            <article class="card product-item">
                                <header class="card__header">
                                    <h1 class="product__title">
                                        <%= product.title %>
                                    </h1>
                                </header>
                                <div class="card__image">
                                    <img src="<%= product.imageUrl %>" alt="<%= product.title %>">
                                </div>
                                <div class="card__content">
                                    <h2 class="product__price">$
                                        <%= product.price %>
                                    </h2>
                                    <p class="product__description">
                                        <%= product.description %>
                                    </p>
                                </div>
                                <div class="card__actions">
                                    <a href="/admin/edit-product/<%= product._id %>?edit=true" class="btn">Edit</a>
                                    <form action="/admin/delete-product" method="POST">
                                        <!--set the value to productId using ejs templating syntax and the name to productId
                                            so that we can extract that information by that name.
                                        -->
                                        <input type="hidden" value="<%= product._id %>" name="productId">
                                        <button class="btn" type="submit">Delete</button>
                                    </form>

                                </div>
                            </article>
                            <% } %>
                    </div>
                    <% } else { %>
                        <h1>No Products Found!</h1>
                        <% } %>
            </main>
            <%- include('../includes/end.ejs') %>
```

\* Chapter 185: Working On The Product Model To Edit Our Product
================================================================

1\. update

- ./controllers/admin.js

- ./views/admin/edit-product.ejs

- ./routes/admin.js

- ./models/product.js

![](images/185-working-on-the-product-model-to-edit-our-product-1.png)

![](images/185-working-on-the-product-model-to-edit-our-product-2.png)

```js
// ./controllers/admin.js

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(title, price, description, imageUrl);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};


exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
//Product.findByPk(prodId)
  .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;
  Product.findByPk(prodId)
    .then(product => {
      product.title = updatedTitle;
      product.price = updatedPrice;
      product.description = updatedDesc;
      product.imageUrl = updatedImageUrl;
      return product.save();
    })
    .then(result => {
      console.log('UPDATED PRODUCT!');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

/*
exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return product.destroy()
    })
    .then(result => {
      console.log('DESTROYED PRODUCT')
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err))
};
*/
```

```js
<!--./views/admin/edit-product.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/forms.css">
    <link rel="stylesheet" href="/css/product.css">
</head>

<body>
   <%- include('../includes/navigation.ejs') %>

    <main>
        <form class="product-form" action="/admin/<% if (editing) { %>edit-product<% } else { %>add-product<% } %>" method="POST">
            <div class="form-control">
                <label for="title">Title</label>
                <input type="text" name="title" id="title" value="<% if (editing) { %><%= product.title %><% } %>">
            </div>
            <div class="form-control">
                <label for="imageUrl">Image URL</label>
                <input type="text" name="imageUrl" id="imageUrl" value="<% if (editing) { %><%= product.imageUrl %><% } %>">
            </div>
            <div class="form-control">
                <label for="price">Price</label>
                <input type="number" name="price" id="price" step="0.01" value="<% if (editing) { %><%= product.price %><% } %>">
            </div>
            <div class="form-control">
                <label for="description">Description</label>
                <textarea name="description" id="description" rows="5"><% if (editing) { %><%= product.description %><% } %></textarea>
            </div>
            <% if (editing) { %>
                <input type="hidden" value="<%= product._id %>" name="productId">
            <% } %>

            <button class="btn" type="submit"><% if (editing) { %>Update Product<% } else { %>Add Product<% } %></button>
        </form>
    </main>
<%- include('../includes/end.ejs') %>
```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');

const adminController = require('../controllers/admin');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', adminController.getAddProduct);

// /admin/products => GET
router.get('/products', adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', adminController.postAddProduct);

router.get('/edit-product/:productId', adminController.getEditProduct);
/*
router.post('/edit-product', adminController.postEditProduct);

router.post('/delete-product', adminController.postDeleteProduct);
*/

module.exports = router;
```

```js
//./models/product.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

class Product {
  /**how could we update our product which is stored in the database?
   * let's add a fifth arguement here, the ID
   * and then i will say 'this._id = id'
   * now we accept a kind of optional fifth argument. 
   */
  constructor(title, price, description, imageUrl, id){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
    this._id = id
  }
  save(){
    const db = getDb()
    let dbOp
    if(this._id){
      //Update the product
      /**i use 'updateOne()'
       * and as the name suggests,
       * 'updateOne()' will update exactly one element
       * there's also 'updateMany()' where you can update multiple elements at once.
       */
      dbOp = db.collection('products')
      /**'updateOne()' takes at least 2 arguments
       * the first one is that we add a filter
       * that defines which element or which document we wanna update
       * so i will pass a javascript object 
       * and we can filter for equality also or run more complex queries
       * anyway, here i only wanna find a document where the '_id' is equal to 
       * and now again '_id: new mongodb.ObjectId(this._id)'
       * so i'm looking for a document where the ID matches the ID i have here in my product i'm currently working with
       * 
       * and we now as a second argument to 'updateOne()',
       * we now specify how to update that document. 
       * this again is a javascript object where we describe the update
       * and this is now not the new object.
       * so we don't say 'this' here as you could imagine that we tell MongoDB find me the existing document and replace it with this.
       * 'updateOne()' doesn't replace
       * 
       * instead we have to describe the operation and we do this by using a special property name
       * which is understood by MongoDB, kind of a reserved name. '$set'
       * '$set' again takes an object as a value
       * and here we describe the changes we wanna make to the existing document which we found with this filter
       * and here you could say 'this' and you would instruct MongoDB to set these key value field like 'this.title = title' 'this.price = price' above.
       * which you have in your object to the document it found in the database
       * it will update the values of the document in the database with your new values.
       * we wanna replace all fields, we can just say {$set: this}
       */
        .updateOne({_id: new mongodb.ObjectId(this._id)}, {$set: this})
    } else {
      dbOp = db
              .collection('products')
              .insertOne(this)
    }
    return dbOp
      .then(result => {
        console.log(result)
      })
      .catch(err => {
        console.log(err)
      })
  }

  static fetchAll(){
    const db = getDb()
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products)
        return products
      })
      .catch(err => {
        console.log(err)
      })
  }

  static findById(prodId){
    const db = getDb()
    return db
      .collection('products')
      .find({_id: new mongodb.ObjectId(prodId)})
      .next()
      .then(product => {
        console.log(product)
        return product
      })
      .catch(err => {
        console.log(err)
      })
  }
}

module.exports = Product;


```

\* Chapter 186: Finishing The “Update Product” Code
===================================================

1\. update

- ./controllers/admin.js

- ./routes/admin.js

![](images/186-finishing-the-update-product-code-1.png)

![](images/186-finishing-the-update-product-code-2.png)

![](images/186-finishing-the-update-product-code-3.png)

```js
// ./controllers/admin.js

const mongodb = require('mongodb')
const Product = require('../models/product');

const ObjectId = mongodb.ObjectId

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(title, price, description, imageUrl);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};


exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
//Product.findByPk(prodId)
  .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;
  /**we already have code where we find a product by id
   * and this will work because 'findById()' is a method i created in my model
   * 
   */
      /**we don't even need 'findById()' and 'then()' anymore
       * we can just get rid of that
       * and for now also create a new product with all the updated information
       * and we also need to pass the product ID,
       * there you just need to make sure that you create a 'new mongodb.ObjectId' object
       * so make sure that at the top of the file,
       * you require 'mongodb'
       * and you can create a new constant, name it 'ObjectId'
       * and extract that 'ObjectId' constructor out of mongodb
       * and then you could write new ObjectId
       * and reference this.
       * so we can now go down to postEditProduct
       */
      const product = new Product(updatedTitle, updatedPrice, updatedDesc, updatedImageUrl, new ObjectId(prodId))
      product
      /**we call 'product.save()'
       * because we modified the 'save()' method to support both creation and updating
       */
        .save()
        .then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      })
      .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

/*
exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return product.destroy()
    })
    .then(result => {
      console.log('DESTROYED PRODUCT')
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err))
};
*/
```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');

const adminController = require('../controllers/admin');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', adminController.getAddProduct);

// /admin/products => GET
router.get('/products', adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', adminController.postAddProduct);

router.get('/edit-product/:productId', adminController.getEditProduct);

router.post('/edit-product', adminController.postEditProduct);
/*
router.post('/delete-product', adminController.postDeleteProduct);
*/

module.exports = router;
```

\* Chapter 187: One Note About Updating Products
================================================

1\. update

- ./controllers/admin.js

- ./models/product.js

![](images/187-one-note-about-updating-products-1.png)

![](images/187-one-note-about-updating-products-2.png)

```js
//./models/product.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

class Product {
  constructor(title, price, description, imageUrl, id){
    this.title = title
    this.price = price
    this.description = description
    this.imageUrl = imageUrl
    this._id = new mongodb.ObjectId(id)
  }
  save(){
    const db = getDb()
    let dbOp
    if(this._id){
      dbOp = db.collection('products')
      /**if we go to the ./models/product.js file,
       * and we have a look at the save() method,
       * i'm looking for the right object
       * but i will have a problem with updating it
       * because i will try set my obejct id to a different object id to a string
       * because i'm referring to these things like 'this.title = title' 'this.price = price' and so on
       * which will hold the unmodified objectId
       * so i should automatically convert the 'objectId' the id which is the string to an obejct
       * and the object in the constructor
       * so that we can remove down there. 'new mongodb.ObjectId'
       * because '_id' will always be an OjbectId field
       * no matter if i'm using it in a filter or if i'm using it for updating. 
       */
        .updateOne(
          {_id: this._id},
          {$set: this}
        )
    } else {
      dbOp = db
              .collection('products')
              .insertOne(this)
    }
    return dbOp
      .then(result => {
        console.log(result)
      })
      .catch(err => {
        console.log(err)
      })
  }

  static fetchAll(){
    const db = getDb()
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products)
        return products
      })
      .catch(err => {
        console.log(err)
      })
  }

  static findById(prodId){
    const db = getDb()
    return db
      .collection('products')
      .find({_id: new mongodb.ObjectId(prodId)})
      .next()
      .then(product => {
        console.log(product)
        return product
      })
      .catch(err => {
        console.log(err)
      })
  }
}

module.exports = Product;


```

```js
// ./controllers/admin.js

const mongodb = require('mongodb')
const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(
    title, 
    price, 
    description, 
    imageUrl
  );
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};


exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
//Product.findByPk(prodId)
  .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;
      const product = new Product(
        updatedTitle, 
        updatedPrice, 
        updatedDesc, 
        updatedImageUrl, 
        /**i passed an 'ObjectId' in ./controllers/admin.js to my Product constructor
         * now i could also just pass 'prodId' as a string
         * and therefore remove my 'ObjectId' constant above import
         * all of that is happening in the controller now
         * 
         * this is an important note
         * you don't have to convert the ID in the controller file
         * you can leave that untouched
         * but you can do a general conversion in the ./models/product.js file
         * which is the better approach of doing that.
         */
        prodId
      )
      product
        .save()
        .then(result => {
        console.log('UPDATED PRODUCT!');
        res.redirect('/admin/products');
      })
      .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

/*
exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return product.destroy()
    })
    .then(result => {
      console.log('DESTROYED PRODUCT')
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err))
};
*/
```

\* Chapter 188: Deleting Products
=================================

1\. update

- ./models/product.js

- ./controllers/admin.js

- ./routes/admin.js

![](images/188-deleting-products-1.png)

![](images/188-deleting-products-2.png)

![](images/188-deleting-products-3.png)

![](images/188-deleting-products-4.png)

- let’s confirm in compass by quickly refreshing that page and our product is gone. so deleting works well.

[nodemon] clean exit - waiting for changes before restart

[nodemon] restarting due to changes...

[nodemon] starting `node app.js`

(node:33113) DeprecationWarning: current URL string parser is deprecated, and will be removed in a future version. To use the new parser, pass option { useNewUrlParser: true } to MongoClient.connect.

{ MongoNetworkError: connection 3 to cluster0-shard-00-00-z3vlk.mongodb.net:27017 closed

 at TLSSocket.\<anonymous\> (/Users/kiwonkim/Desktop/nodejs-complete-guide/node\_modules/mongodb-core/lib/connection/connection.js:352:9)

 at Object.onceWrapper (events.js:273:13)

 at TLSSocket.emit (events.js:182:13)

 at \_handle.close (net.js:610:12)

 at TCP.done (\_tls\_wrap.js:386:7)

 name: 'MongoNetworkError',

 errorLabels: [ 'TransientTransactionError' ],

 [Symbol(mongoErrorContextSymbol)]: {} }

(node:33113) UnhandledPromiseRejectionWarning: MongoNetworkError: connection 3 to cluster0-shard-00-00-z3vlk.mongodb.net:27017 closed

 at TLSSocket.\<anonymous\> (/Users/kiwonkim/Desktop/nodejs-complete-guide/node\_modules/mongodb-core/lib/connection/connection.js:352:9)

 at Object.onceWrapper (events.js:273:13)

 at TLSSocket.emit (events.js:182:13)

 at \_handle.close (net.js:610:12)

 at TCP.done (\_tls\_wrap.js:386:7)

(node:33113) UnhandledPromiseRejectionWarning: Unhandled promise rejection. This error originated either by throwing inside of an async function without a catch block, or by rejecting a promise which was not handled with .catch(). (rejection id: 1)

(node:33113) [DEP0018] DeprecationWarning: Unhandled promise rejections are deprecated. In the future, promise rejections that are not handled will terminate the Node.js process with a non-zero exit code.

- this Error message is due to wrong IP Whitelist in MongoDB Atlas. IP Whitelist is periodly changed. so if you got error like that, you should go to your Clusters you have been using in MongoDB Atlas, go to IP whitelist and edit or replace your expired IP to new IP whiltelist. as soon as you edit it, Status of IP Address will be on ‘pending’ and after that go to ‘Active’ then Error is gone.

![](images/188-deleting-products-5.png)

```js
//./models/product.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

class Product {
  constructor(title, price, description, imageUrl, id) {
    this.title = title;
    this.price = price;
    this.description = description;
    this.imageUrl = imageUrl;
    this._id = new mongodb.ObjectId(id);
  }

  save() {
    const db = getDb();
    let dbOp;
    if (this._id) {
      // Update the product
      dbOp = db
        .collection('products')
        .updateOne({ _id: this._id }, { $set: this });
    } else {
      dbOp = db.collection('products').insertOne(this);
    }
    return dbOp
      .then(result => {
        console.log(result);
      })
      .catch(err => {
        console.log(err);
      });
  }

  static fetchAll() {
    const db = getDb();
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products);
        return products;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static findById(prodId) {
    const db = getDb();
    return db
      .collection('products')
      .find({ _id: new mongodb.ObjectId(prodId) })
      .next()
      .then(product => {
        console.log(product);
        return product;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static deleteById(prodId) {
    const db = getDb();
    /**you need to specify a filter now
     * so pass in object where you describe how to find that product
     * and again it will be our _id equal to check here
     * here product id is an argument
     * so we need to convert it to an Object.Id manually again
     * by passing it to the ObjectId constructor.
     * now mongodb will go ahead and delete the first element it finds that has this criteria fulfilled.
     */
    return db
      .collection('products')
      .deleteOne({ _id: new mongodb.ObjectId(prodId) })
      .then(result => {
        console.log('Deleted');
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = Product;
```

```js
// ./controllers/admin.js

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  const product = new Product(title, price, description, imageUrl);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    // Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const product = new Product(
    updatedTitle,
    updatedPrice,
    updatedDesc,
    updatedImageUrl,
    prodId
  );
  product
    .save()
    .then(result => {
      console.log('UPDATED PRODUCT!');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

exports.postDeleteProduct = (req, res, next) => {
  /**we extract prodId
   * and here we had a different flow
   * i first of all found the product here
   * we just call 'Product.deleteById(prodId)'
   * we pass in the 'prodId' as a string
   * and then we just have our 'then()' block which won't receive an argument
   */
  const prodId = req.body.productId;
  Product.deleteById(prodId)
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};
```

```js
// ./routes/admin.js

const path = require('path');

const express = require('express');

const adminController = require('../controllers/admin');

const router = express.Router();

// /admin/add-product => GET
router.get('/add-product', adminController.getAddProduct);

// /admin/products => GET
router.get('/products', adminController.getProducts);

// /admin/add-product => POST
router.post('/add-product', adminController.postAddProduct);

router.get('/edit-product/:productId', adminController.getEditProduct);

router.post('/edit-product', adminController.postEditProduct);

router.post('/delete-product', adminController.postDeleteProduct);

module.exports = router;
```

\* Chapter 189: Fixing The “Add Product” Functionality
======================================================

1\. update

- ./models/product.js

![](images/189-fixing-the-add-product-functionality-1.png)

![](images/189-fixing-the-add-product-functionality-2.png)

```js
//./models/product.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

/**even if we pass no 'id' as an argument and this therefore is undefined, 
 * this will create an object and store it in '_id'
 * so 'this._id' down there will always be defined. 
 * and if it's just such an empty or automatically generated ObjectId object,
 * this should be the issue here.
 */
class Product {
  constructor(title, price, description, imageUrl, id) {
    this.title = title;
    this.price = price;
    this.description = description;
    this.imageUrl = imageUrl;
    /**for example with a ternary expression,
     * we can check if ID exists,
     * so if this returns true in an if statement
     * and if it's the case,
     * then i wanna create my ObjectId object
     * otherwise i will store null and null will be treated as false down there.
     * 
     */
    this._id = id ? new mongodb.ObjectId(id) : null
  }

  save() {
    const db = getDb();
    let dbOp;
    if (this._id) {
      // Update the product
      dbOp = db
        .collection('products')
        .updateOne({ _id: this._id }, { $set: this });
    } else {
      dbOp = db.collection('products').insertOne(this);
    }
    return dbOp
      .then(result => {
        console.log(result);
      })
      .catch(err => {
        console.log(err);
      });
  }

  static fetchAll() {
    const db = getDb();
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products);
        return products;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static findById(prodId) {
    const db = getDb();
    return db
      .collection('products')
      .find({ _id: new mongodb.ObjectId(prodId) })
      .next()
      .then(product => {
        console.log(product);
        return product;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static deleteById(prodId) {
    const db = getDb();
    return db
      .collection('products')
      .deleteOne({ _id: new mongodb.ObjectId(prodId) })
      .then(result => {
        console.log('Deleted');
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = Product;
```

\* Chapter 190: Creating New Users
==================================

1\. update

- ./models/user.js

- app.js

![](images/190-creating-new-users-1.png)

- i will connect to the shop database and i will create a new collection called ‘users’ and of course this collection name here should be the collection name you chose in your code. 

![](images/190-creating-new-users-2.png)

![](images/190-creating-new-users-3.png)

- after you create ‘users’ collection, then go into users collection. 

![](images/190-creating-new-users-4.png)

![](images/190-creating-new-users-5.png)

- if we wanna create one behind the scenes in compass, we can insert a new document here. and here is the automatically generated ID and i can enter a name and you can use any name you want and an email and insert that document

![](images/190-creating-new-users-6.png)

- and this ID, this part here between the quotation marks that matters to me. i will take that and i will use that in app.js file

```js
//./models/user.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

/** i will follow a slightly different approach
 * which i already showed before
 * and i will create an ObjectId constant
 * and simply store access to it by accessing it up here.
 * but i'm not calling it, i'm not creating an object in here.
 * i'm storing the reference to the ObjectId class in my ObjectId constant
 * and then down there, i can just write 'new ObjectId'
 */
const ObjectId = mongodb.ObjectId

class User {
    constructor(username, email){
        this.name = username
        this.email = email
    }

    save(){
        const db = getDb()
        /**i wanna insert one new element
         * and that new element will be 'this'
         * so this javascript object we will in
         * an object with a name and an email property
         * this is what i wanna store as a user for now.
         */

        /**we can again use the 'then()' and 'catch()'
         * or we just return that and let whoever calls this listen to that.
         */
        db.collection('users').insertOne(this)
    }

    static findById(userId){
        const db = getDb()
        /**i wanna use 'find()' to find a specific user
         * the important thing here is that you need to convert user ID which i expect to be a string to an ObjectId
         * so let me import 'mongodb' by requiring 'mongodb'
         * 
         * thanks to my constant up there
         * and pass 'userId' to it.
         * 
         * this should fine me all fitting users and i therefore get back a cursor.
         * and now i can call 'next()' to get the first and as we know only element that matters to us
         * so i'm returning this here
         */

         /**as a side note,
          * also use 'findOne()' if you sure that you only find one element
          * this will now not give you a cursor
          * but immediately return that one element. 
          * then this would be an alternative and i will use that here.
          */
        return db
            .collection('users')
            .find({_id: new ObjectId(userId)})
            .next()
    }
}


module.exports = User
```

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database').mongoConnect;
const User = require('./models/user')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
  /** here in my middleware,
   * where i find a user by ID
   * i can search for that ID
   * and i convert that in the user model.
   * that is why i can use a string here.
   */
  User.findById('5cb7d12855fbe74b129c0b7c')
    .then(user => {
      req.user = user;
      next();
    })
    .catch(err => console.log(err));
  next();
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
  app.listen(3000);
});

```

\* Chapter 191: Storing The User In Our Database
================================================

1\. update

- ./models/product.js

- ./controllers/admin.js

- ./models/user.js

- app.js

![](images/191-storing-the-user-in-our-database-1.png)

![](images/191-storing-the-user-in-our-database-2.png)

- i just fetch the user with the ID which is string here, so that is valid. 

![](images/191-storing-the-user-in-our-database-3.png)

- if we have a look at our products here, we see that products also have a user Id which is just a reference pointing at the user who did create that product which is one way of establishing relations. 

- when we are fetching products, we don’t really need any user information. hence we do it just like that. 

- this will change once we start storing orders, it does make sense to store information about the user, for example the e-mail at leat, and for the product you wanna store the title and the price maybe.

```js
//./models/product.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

/**i wanna use that user object when creating a new product
 * when saving a product, i wanna store a reference to a user
 * or embed the entire user data
 * however for products in users, you could in arguments for both approaches here
 * you don't wanna enclose all the user data in an embedded document
 * because that would means that if the user data changes, you need to change that data in all products
 * if you do include something which is unlikely to change very often like the username for example,
 * then you could go ahead and embed that together with the ID
 * so that you always have that ID to fetch more data about the user
 * you have got to 'findById()' in the user model
 * or that you have at least some snapshot data like the username available immediately
 * if that should change, you need to update it everywhere.
 * 
 * The alternative to this is that you store the ID
 * so just a reference and therefore if you need connected data,
 * you always have to fetch it manually from 2 collections
 * but on the other hand, you might not do that too often 
 * and therefore here when i fetch the product,
 * i don't really need the user data,
 * we are not displaying the user name anywhere in our app
 * i wanna store the user id so that we know who is connected even though we are not fetching that a lot
 * 
 * what does this mean for our application here though?
 * it means when creating a new product,
 * we can pass the user id, we can accept the user 
 */
class Product {
  constructor(title, price, description, imageUrl, id, userId) {
    this.title = title;
    this.price = price;
    this.description = description;
    this.imageUrl = imageUrl;
    this._id = id ? new mongodb.ObjectId(id) : null
    this.userId = userId
  }

  save() {
    const db = getDb();
    let dbOp;
    if (this._id) {
      // Update the product
      dbOp = db
        .collection('products')
        .updateOne({ _id: this._id }, { $set: this });
    } else {
      dbOp = db.collection('products').insertOne(this);
    }
    return dbOp
      .then(result => {
        console.log(result);
      })
      .catch(err => {
        console.log(err);
      });
  }

  static fetchAll() {
    const db = getDb();
    return db
      .collection('products')
      .find()
      .toArray()
      .then(products => {
        console.log(products);
        return products;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static findById(prodId) {
    const db = getDb();
    return db
      .collection('products')
      .find({ _id: new mongodb.ObjectId(prodId) })
      .next()
      .then(product => {
        console.log(product);
        return product;
      })
      .catch(err => {
        console.log(err);
      });
  }

  static deleteById(prodId) {
    const db = getDb();
    return db
      .collection('products')
      .deleteOne({ _id: new mongodb.ObjectId(prodId) })
      .then(result => {
        console.log('Deleted');
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = Product;
```

```js
// ./controllers/admin.js

const Product = require('../models/product');

exports.getAddProduct = (req, res, next) => {
  res.render('admin/edit-product', {
    pageTitle: 'Add Product',
    path: '/admin/add-product',
    editing: false
  });
};

exports.postAddProduct = (req, res, next) => {
  const title = req.body.title;
  const imageUrl = req.body.imageUrl;
  const price = req.body.price;
  const description = req.body.description;
  /**when adding new products,
   * i wanna pass 'null' for the product Id
   * because we don't have that when creating a new product
   * but for the user id,
   * i wanna pass the ID of that user which we now store in our request
   *
   * 'req.user._id' will be just string
   * because when retrieving data, the object id is converted to a string.
   * so we have just the string here.
   */
  const product = new Product(
    title,
    price,
    description,
    imageUrl,
    null,
    req.user._id);
  product
    .save()
    .then(result => {
      // console.log(result);
      console.log('Created Product');
      res.redirect('/admin/products');
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getEditProduct = (req, res, next) => {
  const editMode = req.query.edit;
  if (!editMode) {
    return res.redirect('/');
  }
  const prodId = req.params.productId;
  Product.findById(prodId)
    // Product.findById(prodId)
    .then(product => {
      if (!product) {
        return res.redirect('/');
      }
      res.render('admin/edit-product', {
        pageTitle: 'Edit Product',
        path: '/admin/edit-product',
        editing: editMode,
        product: product
      });
    })
    .catch(err => console.log(err));
};

exports.postEditProduct = (req, res, next) => {
  const prodId = req.body.productId;
  const updatedTitle = req.body.title;
  const updatedPrice = req.body.price;
  const updatedImageUrl = req.body.imageUrl;
  const updatedDesc = req.body.description;

  const product = new Product(
    updatedTitle,
    updatedPrice,
    updatedDesc,
    updatedImageUrl,
    prodId
  );
  product
    .save()
    .then(result => {
      console.log('UPDATED PRODUCT!');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('admin/products', {
        prods: products,
        pageTitle: 'Admin Products',
        path: '/admin/products'
      });
    })
    .catch(err => console.log(err));
};

exports.postDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  Product.deleteById(prodId)
    .then(() => {
      console.log('DESTROYED PRODUCT');
      res.redirect('/admin/products');
    })
    .catch(err => console.log(err));
};
```

```js
//./models/user.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

/** i will follow a slightly different approach
 * which i already showed before
 * and i will create an ObjectId constant
 * and simply store access to it by accessing it up here.
 * but i'm not calling it, i'm not creating an object in here.
 * i'm storing the reference to the ObjectId class in my ObjectId constant
 * and then down there, i can just write 'new ObjectId'
 */
const ObjectId = mongodb.ObjectId

class User {
    constructor(username, email){
        this.name = username
        this.email = email
    }

    save(){
        const db = getDb()
        /**i wanna insert one new element
         * and that new element will be 'this'
         * so this javascript object we will in
         * an object with a name and an email property
         * this is what i wanna store as a user for now.
         */

        /**we can again use the 'then()' and 'catch()'
         * or we just return that and let whoever calls this listen to that.
         */
        db.collection('users').insertOne(this)
    }

    static findById(userId){
        const db = getDb()
        /**i wanna use 'find()' to find a specific user
         * the important thing here is that you need to convert user ID which i expect to be a string to an ObjectId
         * so let me import 'mongodb' by requiring 'mongodb'
         * 
         * thanks to my constant up there
         * and pass 'userId' to it.
         * 
         * this should fine me all fitting users and i therefore get back a cursor.
         * and now i can call 'next()' to get the first and as we know only element that matters to us
         * so i'm returning this here
         */

         /**as a side note,
          * also use 'findOne()' if you sure that you only find one element
          * this will now not give you a cursor
          * but immediately return that one element. 
          * then this would be an alternative and i will use that here.
          */
        return db
            .collection('users')
            .findOne({_id: new ObjectId(userId)})
            .then(user => {
                console.log(user)
                return user
            })
            .catch(err => 
                console.log(err)
            )
    }
}


module.exports = User
```

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database').mongoConnect;
const User = require('./models/user')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
  /** here in my middleware,
   * where i find a user by ID
   * i can search for that ID
   * and i convert that in the user model.
   * that is why i can use a string here.
   */
  User.findById('5cb7d12855fbe74b129c0b7c')
    .then(user => {
      req.user = user;
      next();
    })
    .catch(err => console.log(err));
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
  app.listen(3000);
});

```

\* Chapter 192: Working On Cart Items & Orders
==============================================

1\. update

- delete ./models/cart.js, cart-item.js

- ./models/user.js

```js
//./models/user.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

const ObjectId = mongodb.ObjectId

class User {
    constructor(username, email, cart, id){
        this.name = username
        this.email = email
        this.cart = cart //{items: []}
        this._id = id
    }

    save(){
        const db = getDb()
        db.collection('users').insertOne(this)
    }

    addToCart(product){
        /**you must not forget that 'addToCart' will be called on a user object
         * and we will create that obejct with data we fetched from the database with help of 'findById()'
         *
         * the cart will essentially be an object which has the items array
         *
         * i will pass a function to find index which is a function
         * that javascript will execute for every element in the items array
         * and here i wanna return true if i found the right product in my items array
         * and this will be the case if 'cp' which is the product in the items array
         *if 'cp._id' matches the _id of the product i'm trying to insert,
         */
        /*
        const cartProduct = this.cart.item.findIndex(cp => {
            return cp._id === prodId
        })
        */

        /**you create a object with curly braces
         * because we will add an object here
         * and then you use the javascript spread operator
         * 3 dots '...' to pull out all properties of this object
         * so of the product object
         * and then with a comma, you can add or overwrite a property
         * and here i will add the quantity property and set it to 1
         */
        const updatedCart = {items: [{...product, quantity: 1}]}
        const db = getDb()
        db
            .collection('users')
            .updateOne(
                {_id: new ObjectId(this._id)},
                /**i will describe how to update and i will use '$set'
                 * where i pass an object which holds all the information about which field to update in which way.
                 * 
                 * here i wanna keep everything as it is,
                 * i don't wanna change the user name or anything like that.
                 * so 'cart' which i expect to have in a user in the database will now receive 'updatedCart'
                 * so 'updatedCart' object as a new value which will overwrite the old one 
                 * and this is important. it will not merge this with the old one,
                 * it will not merge the elements in teh items array, 
                 * it will overwrite the old cart with the new cart. 
                 */
                {$set: {cart: updateCart}}
            )
    }

    static findById(userId){
        const db = getDb()
        return db
            .collection('users')
            .findOne({_id: new ObjectId(userId)})
            .then(user => {
                console.log(user)
                return user
            })
            .catch(err =>
                console.log(err)
            )
    }
}


module.exports = User
```

\* Chapter 193: Adding The “Add To Cart” Functionality
======================================================

1\. update

- app.js

- ./controllers/shop.js

- ./routes/shop.js

- ./views/includes/add-to-cart.ejs

- ./models/user.js

![](images/193-adding-the-add-to-cart-functionality-1.png)

![](images/193-adding-the-add-to-cart-functionality-2.png)

- we did modify something as our result tells us and if we go to MongoDB Compass and have a look at our users, you see there is an embedded document, a cart document with items with an object which holds product data. now that user ID here is a bit redundant because were already are in that user, we could strip that out and only store what we want but it also that doesn’t matter too much. 

- The important thisn is that we now store a whole product which we store in a separate collection as part of an embedded document in our user.

- so we clearly have duplicate data here. we have the same product here as an embedded document and we have it in products.

- this is maybe something which we should change becasue if we change the product, if we change the title or the price, this will not be reflected in the cart and in the cart, we should have correct data becasue if the price changes, we can show the wrong price in our cart. 

![](images/193-adding-the-add-to-cart-functionality-3.png)

![](images/193-adding-the-add-to-cart-functionality-4.png)

- if i click ‘Add To Cart ‘ and go to MongoDB Atlas and reload, then you see i’m only storing the reference and the quantity and this is the imformation i want.

```js
//app.js

const path = require('path');

const express = require('express');
const bodyParser = require('body-parser');

const errorController = require('./controllers/error');
const mongoConnect = require('./util/database').mongoConnect;
const User = require('./models/user')

const app = express();

app.set('view engine', 'ejs');
app.set('views', 'views');

const adminRoutes = require('./routes/admin');
const shopRoutes = require('./routes/shop');

app.use(bodyParser.urlencoded({ extended: false }));
app.use(express.static(path.join(__dirname, 'public')));

app.use((req, res, next) => {
  User.findById('5cb7d12855fbe74b129c0b7c')
    .then(user => {
      /**it's important to understand that
       * the user as i'm storing it will just be an object with the property
       * so the data we have in the database
       * all the methods of our ./models/user will not be in there
       * because the user i'm getting here is data i'm getting out of the database
       * and the methods are not stored there.
       * they couldn't be stored there.
       *
       * to have a real user obejct with which we can interact,
       * i should create a new user
       * and pass 'user.name', 'user.email', 'user.cart', 'user._id'
       * so i should create such a user object
       * and store that in the request
       * because now this enables me to work with all the user data
       * or with the whole user model
       * and this allows me to also call all these methods like 'addToCart()' on it. */
      req.user = new User(user.namem, user.email, user.cart, user._id);
      next();
    })
    .catch(err => console.log(err));
});

app.use('/admin', adminRoutes);
app.use(shopRoutes);

app.use(errorController.get404);

mongoConnect(() => {
  app.listen(3000);
});

```

```js
//./models/user.js

const mongodb = require('mongodb')
const getDb = require('../util/database').getDb

const ObjectId = mongodb.ObjectId

class User {
    constructor(username, email, cart, id){
        this.name = username
        this.email = email
        this.cart = cart //{items: []}
        this._id = id
    }

    save(){
        const db = getDb()
        db.collection('users').insertOne(this)
    }

    addToCart(product){
        /**i don't wanna store all product data in this object and a quantity
         * i wanna store the product ID by creating a new ObjectId
         * and passing product _Id as an argument and the quantity
         * now only the reference and the quantity and not the rest of the data
         */
        const updatedCart = {
            items: [
                        { 
                            productId: new ObjectId(product._id), 
                            quantity: 1
                        }
                    ]}
        const db = getDb()
        db
            .collection('users')
            .updateOne(
                {_id: new ObjectId(this._id)},
                {$set: {cart: updatedCart}}
            )
    }

    static findById(userId){
        const db = getDb()
        return db
            .collection('users')
            .findOne({_id: new ObjectId(userId)})
            .then(user => {
                console.log(user)
                return user
            })
            .catch(err =>
                console.log(err)
            )
    }
}


module.exports = User
```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);
/*
router.get('/cart', shopController.getCart);
*/

router.post('/cart', shopController.postCart);

/*
router.post('/cart-delete-item', shopController.postCartDeleteProduct);

router.post('/create-order', shopController.postOrder)

router.get('/orders', shopController.getOrders);
*/

module.exports = router;

```

```js
<!--./views/includes/add-to-cart.ejs-->

<form action="/cart" method="post">
    <button class="btn" type="submit">Add to Cart</button>
    <input type="hidden" name="productId" value="<%= product._id %>">
</form>

```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(cart => {
      return cart
        .getProducts()
        .then(products => {
          res.render('shop/cart', {
            path: '/cart',
            pageTitle: 'Your Cart',
            products: products
          });
        })
        .catch(err => console.log(err));
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product
    .findById(prodId)
    .then(product => {
      /** pass in 'product' in 'addToCart()'
       * because in the ./models/user.js file,
       * 'addToCart()' does expect 'product'
       * and then i return the result of 'updateOne' which will be a promise.
       * 
       */
      return req.user.addToCart(product)
    })
    .then(result => {
      console.log(result)
    })
    .catch(err => {
    console.log(err)
  })
  /*
  let fetchedCart;
  let newQuantity = 1;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      let product;
      if (products.length > 0) {
        product = products[0];
      }

      if (product) {
        const oldQuantity = product.cartItem.quantity;
        newQuantity = oldQuantity + 1;
        return product;
      }
      return Product.findByPk(prodId);
    })
    .then(product => {
      return fetchedCart.addProduct(product, {
        through: { quantity: newQuantity }
      });
    })
    .then(() => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
  */
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .getCart()
    .then(cart => {
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      const product = products[0];
      return product.cartItem.destroy();
    })
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({include: ['products']})
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

\* Chapter 194: Storing Multiple Products In The Cart
=====================================================

1\. update

- ./models/user.js

![](images/194-storing-multiple-products-in-the-cart-1.png)

![](images/194-storing-multiple-products-in-the-cart-2.png)

![](images/194-storing-multiple-products-in-the-cart-3.png)

![](images/194-storing-multiple-products-in-the-cart-4.png)

![](images/194-storing-multiple-products-in-the-cart-5.png)

![](images/194-storing-multiple-products-in-the-cart-6.png)

![](images/194-storing-multiple-products-in-the-cart-7.png)

![](images/194-storing-multiple-products-in-the-cart-8.png)

![](images/194-storing-multiple-products-in-the-cart-9.png)

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      /**'product' in 'addToCart(product)' is a 'product' i just retrieved from the database
       * '_id' in here is treated as a string in javascript
       * but is not exactly of type string
       * since i'm using 3 equal signs'===' in my check here
       * however i'm telling javascript that this should only return true
       * if these 2 don't only match by value but also by type
       * and technically '_id' is not string even though we can use it as such.
       *
       * so one solution is to use 2 equal signs or to use 'toString()' on both here.
       * make sure we only works with strings here in both cases.
       */
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    /**this gives me a new array with all the items that are in the cart
     * and they are now stored here.
     *
     * now i can edit my updatedCartItems
     * and now i need to differentiate,
     * do we already have that item in cart or not
     * so 'updatedCartItems' position is here, before my if check
     */
    const updatedCartItems = [...this.cart.items];
    /**if i make it into this if statement,
     * i know that we have this product already.
     * i can access updatedCartItems for the cartProductIndex i found
     * now i have access to that item i'm interested in.
     * i know it already existed
     * so i can set its quantity equal to the 'newQuantity'
     */
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
    /**and i can edit this array without touching the old array
     * due to the way javascript works with reference and primitive types
     */
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
    /**if the item didn't exist before,
     * i will take my updatedCartItems and add a new one with 'push()'
     * i will add a new cartItem and i will add a new cartItem
     * which looks exactly as described down there. '{ productId: new ObjectId(product._id), quantity: newQuantity }'
     * so i will grab that code and add it here.
     */
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      /**i can always set my items equal to the updatedCartItems
       * because that will always be an array with all the old elements '[...this.cart.items]'
       * because i copy '[...this.cart.items]' first and then with the update added
       * so either with the quantity increated for the existing element
       * or with a new element added to the cart.
       *
       * so i can safely have my updatedCart down there and save that to the database with all the updatedItems in there.
       */
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

\* Chapter 195: Displaying The Cart Items
=========================================

1\. update

- ./models/user.js

- ./controllers/shop.js

- ./views/shop/cart.ejs

- ./routes/shop.js

![](images/195-displaying-the-cart-items-1.png)

![](images/195-displaying-the-cart-items-2.png)

![](images/195-displaying-the-cart-items-3.png)

![](images/195-displaying-the-cart-items-4.png)

![](images/195-displaying-the-cart-items-5.png)

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    const updatedCartItems = [...this.cart.items];
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }
/**'getCart()' should return products which are enriched with all the data that is stored in a product's collection
 * because in users, in the cart we will only store the reference
 * and this is what we need to do in MongoDB
 * if we then have a connection between 2 collections with a reference,
 * we need to merge them manually as we are doing it here
 * with that merging being done manually,
 * we can now use that data.
 * so 'getCart()' should return a cart with all the information we need.
 */

  getCart() {
    const db = getDb();
    /**object have a productID and quantity
     * but we are only interested in product ID
     * so 'map()' this, this is a default javascript function
     * i will map this to transform every item in there
     * and i wanna return the product ID
     *
     * so what i'm doing is that
     * i'm mapping an array of items where every item is a javascript object into an array of just string, of the product IDs
     * and this is then stored in this new 'productIds' constant
     */
    const productIds = this.cart.items.map(i => {
      return i.productId;
    });
    /**i reach out to the products collection
     * now because i have all the user data
     * i have all the cart data
     * now i need to fill it with some live from the products database
     *
     * in there, i wanna find all products that are in my cart
     * for this, we can use special query syntax MongoDB supports.
     * in 'find()', i can tell i wanna find all products where '_id' is equal to
     * and i don't pass an ID here because i'm not looking for a single ID
     * instead i pass an object becasue this allows me to use some special MongoDB query operator
     * we are looking for '$in' operator
     * and this operator takes an array of IDs
     * and therefore every ID which is in the array will be accepted
     * and will get back a cursor which holds references to all products with one of the IDs mentioned in this array
     *
     * then my array which i wanna use to tell MongoDB
     * give me all elements where the ID is one of the IDs mentioned in this array here.
     * this gives me a cursor with all the matching products
     *
     * and i will again use 'toArray()' to get quickly that converted to a javascript array
     * and then i will add 'then()' method
     * in 'then()' method, i will have all my product data for the products that were in my cart
     * and of course we wanna add the quantity back to every product
     * because that is something that is important to us
     */
    return db
      .collection('products')
      .find({ _id: { $in: productIds } })
      .toArray()
      .then(products => {
        return products.map(p => {
          /**i wanna keep all the data i retrieved
           * but then i will add a new quantity property
           * and that quantity property needs to be populated with data i have on that product
           * we have the products stored in the cart of this user
           * and make sure you use arrow function to ensure that 'this' inside of this functio still refers to the overall class
           * with normal functions, it would not
           * and access my items and find the item with that ID at hand here
           */
          return {
            ...p,
            quantity: this.cart.items.find(i => {
            /**in the end, i have an array of 'products'
             * fresh from the database
             * then i wanna transform this which i'm doing with 'map()'
             * 'map()' takes a function that executes on every element and products
             * which describes how to transform this element
             * and in 'p', i'm returning the new value which is an object
             * where i still have all the old product properties
             * but i add a new quantity property and to get the right quantity for that given product,
             * i reach out to 'cart.items' which exist on that user
             * and i again use a built in javascript method,
             * find to look at all elements in cart.items with this function in 'i'
             * then identify the one product where the productId i'm storing in my cart.items matches the ID of the product i have fetched from the database
             * and since with 'map()' i'm going through all these products,
             * this will also vary for every run.
             *
             * now from the cart.items i have, i extract a quantity for that given product.
             */
              return i.productId.toString() === p._id.toString();
            }).quantity
          };
        });
      });
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(products => {
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    });
  // let fetchedCart;
  // let newQuantity = 1;
  // req.user
  //   .getCart()
  //   .then(cart => {
  //     fetchedCart = cart;
  //     return cart.getProducts({ where: { id: prodId } });
  //   })
  //   .then(products => {
  //     let product;
  //     if (products.length > 0) {
  //       product = products[0];
  //     }

  //     if (product) {
  //       const oldQuantity = product.cartItem.quantity;
  //       newQuantity = oldQuantity + 1;
  //       return product;
  //     }
  //     return Product.findById(prodId);
  //   })
  //   .then(product => {
  //     return fetchedCart.addProduct(product, {
  //       through: { quantity: newQuantity }
  //     });
  //   })
  //   .then(() => {
  //     res.redirect('/cart');
  //   })
  //   .catch(err => console.log(err));
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .getCart()
    .then(cart => {
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      const product = products[0];
      return product.cartItem.destroy();
    })
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({ include: ['products'] })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
<!--./views/shop/cart.ejs-->

<%- include('../includes/head.ejs') %>
    <link rel="stylesheet" href="/css/cart.css">
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>
        <main>
            <% if (products.length > 0) { %>
                <ul class="cart__item-list">
                    <% products.forEach(p => { %>
                        <li class="cart__item">
                            <h1><%= p.title %></h1>
                            <h2>Quantity: <%= p.quantity %></h2>
                            <form action="/cart-delete-item" method="POST">
                                <input type="hidden" value="<%= p._id %>" name="productId">
                                <button class="btn danger" type="submit">Delete</button>
                            </form>
                        </li>
                    <% }) %>
                </ul>
                <hr>
                <div class="centered">
                    <form action="/create-order" method="POST">
                        <button type="submit" class="btn">Order Now!</button>
                    </form>
                </div>
                
            <% } else { %>
                <h1>No Products in Cart!</h1>
            <% } %>
        </main>
        <%- include('../includes/end.ejs') %>
```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);

router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

// router.post('/cart-delete-item', shopController.postCartDeleteProduct);

// router.post('/create-order', shopController.postOrder);

// router.get('/orders', shopController.getOrders);

module.exports = router;
```

\* Chapter 196: Fixing A Bug
============================

1\. update

- ./controllers/shop.js

![](images/196-fixing-a-bug-1.png)

![](images/196-fixing-a-bug-2.png)

- if i click ‘Add to cart’, then redirect to ‘/cart'

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(products => {
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    });
  // let fetchedCart;
  // let newQuantity = 1;
  // req.user
  //   .getCart()
  //   .then(cart => {
  //     fetchedCart = cart;
  //     return cart.getProducts({ where: { id: prodId } });
  //   })
  //   .then(products => {
  //     let product;
  //     if (products.length > 0) {
  //       product = products[0];
  //     }

  //     if (product) {
  //       const oldQuantity = product.cartItem.quantity;
  //       newQuantity = oldQuantity + 1;
  //       return product;
  //     }
  //     return Product.findById(prodId);
  //   })
  //   .then(product => {
  //     return fetchedCart.addProduct(product, {
  //       through: { quantity: newQuantity }
  //     });
  //   })
  //   .then(() => {
  //     res.redirect('/cart');
  //   })
  //   .catch(err => console.log(err));
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .getCart()
    .then(cart => {
      return cart.getProducts({ where: { id: prodId } });
    })
    .then(products => {
      const product = products[0];
      return product.cartItem.destroy();
    })
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({ include: ['products'] })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

\* Chapter 197: Deleting Cart Items
===================================

1\. update

- ./controllers/shop.js

- ./models/user.js

- ./routes/shop.js

![](images/197-deleting-cart-items-1.png)

![](images/197-deleting-cart-items-2.png)

![](images/197-deleting-cart-items-3.png)

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(products => {
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .deleteItemFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .getCart()
    .then(cart => {
      fetchedCart = cart;
      return cart.getProducts();
    })
    .then(products => {
      return req.user
        .createOrder()
        .then(order => {
          return order.addProducts(
            products.map(product => {
              product.orderItem = { quantity: product.cartItem.quantity };
              return product;
            })
          );
        })
        .catch(err => console.log(err));
    })
    .then(result => {
      return fetchedCart.setProducts(null);
    })
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({ include: ['products'] })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    const updatedCartItems = [...this.cart.items];
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }

  getCart() {
    const db = getDb();
    const productIds = this.cart.items.map(i => {
      return i.productId;
    });
    return db
      .collection('products')
      .find({ _id: { $in: productIds } })
      .toArray()
      .then(products => {
        return products.map(p => {
          return {
            ...p,
            quantity: this.cart.items.find(i => {
              return i.productId.toString() === p._id.toString();
            }).quantity
          };
        });
      });
  }

  deleteItemFromCart(productId){
    /**'filter()' is a method provided by vanila javascript
     * 'filter()' allows us to define a criteria
     * on how we wanna filter the elements in that array
     * so in this case, the elements of the items array
     * and then it will return a new array with all the filtered items
     * so all the items that make it through the filter
     *
     * 'filter()' is a function which runs on every item
     * and we return true if we wanna keep the item in the new array
     * or false if you want to get rid of it.
     */
    const updatedCartItems = this.cart.items.filter(item => {
      return item.productId.toString() !== productId.toString()
    })
    const db = getDb()
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        /**i wanna assign this to an object with an items property
         * because that was what our cart has.
         * 
         */
        { $set: { cart: {items: updatedCartItems} } }
      )
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);

router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

router.post('/cart-delete-item', shopController.postCartDeleteProduct);

// router.post('/create-order', shopController.postOrder);

// router.get('/orders', shopController.getOrders);

module.exports = router;

```

\* Chapter 198: Adding An Order
===============================

1\. update

- ./models/user.js

- ./controllers/shop.js

- ./routes/shop.js

![](images/198-adding-an-order-1.png)

![](images/198-adding-an-order-2.png)

![](images/198-adding-an-order-3.png)

![](images/198-adding-an-order-4.png)

![](images/198-adding-an-order-5.png)

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    const updatedCartItems = [...this.cart.items];
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }

  getCart() {
    const db = getDb();
    const productIds = this.cart.items.map(i => {
      return i.productId;
    });
    return db
      .collection('products')
      .find({ _id: { $in: productIds } })
      .toArray()
      .then(products => {
        return products.map(p => {
          return {
            ...p,
            quantity: this.cart.items.find(i => {
              return i.productId.toString() === p._id.toString();
            }).quantity
          };
        });
      });
  }

  deleteItemFromCart(productId){
    const updatedCartItems = this.cart.items.filter(item => {
      return item.productId.toString() !== productId.toString()
    })
    const db = getDb()
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: {items: updatedCartItems} } }
      )
  }

  addOrder(){
    /**this doesn't take any arguments
     * because the cart which will be passed as an order or as the data for the order
     * is already registered on this user
     * so i need to add the orders to my user or the other way around
     */
    const db = getDb()
    /**i will return the entire thing
     * and the one new order will be well the cart i currently have
     * i wanna insert my cart which refers to the users cart
     */
    return db
      .collection('orders')
      .insertOne(this.cart)
      .then(result => {
        this.cart = {items: []}
        return db
                .collection('users')
                .updateOne(
                  { _id: new ObjectId(this._id) },
                  { $set: { cart: { items: [] } } }
                )
    })
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(products => {
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .deleteItemFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .addOrder()
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders({ include: ['products'] })
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);

router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

router.post('/cart-delete-item', shopController.postCartDeleteProduct);

router.post('/create-order', shopController.postOrder);

// router.get('/orders', shopController.getOrders);

module.exports = router;

```

\* Chapter 199: Adding Relational Order Data
============================================

1\. update

- ./models/user.js

![](images/199-adding-relational-order-data-1.png)

![](images/199-adding-relational-order-data-2.png)

![](images/199-adding-relational-order-data-3.png)

![](images/199-adding-relational-order-data-4.png)

- this is the new order we just added and there you see items does have all the enriched product information, the snapshots of our products and the quantity in there and we have some user data

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    const updatedCartItems = [...this.cart.items];
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }

  getCart() {
    const db = getDb();
    const productIds = this.cart.items.map(i => {
      return i.productId;
    });
    return db
      .collection('products')
      .find({ _id: { $in: productIds } })
      .toArray()
      .then(products => {
        return products.map(p => {
          return {
            ...p,
            quantity: this.cart.items.find(i => {
              return i.productId.toString() === p._id.toString();
            }).quantity
          };
        });
      });
  }

  deleteItemFromCart(productId){
    const updatedCartItems = this.cart.items.filter(item => {
      return item.productId.toString() !== productId.toString()
    })
    const db = getDb()
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: {items: updatedCartItems} } }
      )
  }

  addOrder(){
    const db = getDb()
    /**i have that products data
     * because outside of that 'then()' block,
     * the code would execute too early.
     * 
     * i need to 'return' the result of this 'addOrder()'
     * so that outside of addOrder(), in my ./controllers/shop.js,
     * i can call 'then()' in 'postOrder()'
     */
    return this.getCart().then(products => {
      const order = {
        /**then my items will be my products
         * so an array of products with the product information and the quantity
         * so now the product information will also be part of the order
         * 
         * and here i really don't care about that information changing
         * because if it should change, for orders, we need a snapshot anyways
         * if the price of a product changes, that doesn't affect the past order
         * so we wouldn't wanna update the price even if it would change
         * so for orders, such a snapshot and therefore an embedded document is a great way of relating the order and the product
         * because the product data might be duplicate but it doesn't need to change in the orders collection
         * because we want a snapshot. 
         */
        items: products,
        /**we wanna have the 'cart.items' in there
         * but we also wanna have some information about the user
         * and i will add an embedded document where i add the '_id' and here,
         * i wanna create a 'new objectId' based on the ID of the user we are working with
         * but i also wanna store the name which we have as a property here and the email
         * so i will duplicate data because this will then end up in the orders collection and in this users collection
         */
        user: {
          _id: new ObjectId(this._id),
          name: this.name,
        }
      }
      return db
      .collection('orders')
      .insertOne(order)
    })
      .then(result => {
        this.cart = {items: []}
        return db
                .collection('users')
                .updateOne(
                  { _id: new ObjectId(this._id) },
                  { $set: { cart: { items: [] } } }
                )
    })
  }

  getOrders(){
    const db = getDb()
    //return db.collection('orders').
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

\* Chapter 200: Getting Orders
==============================

1\. update

- ./models/user.js

- ./controllers/shop.js

- ./views/shop/orders.js

- ./routes/shop.js

![](images/200-getting-orders-1.png)

- our user, for example, has 2 orders because we got 2 orders for that userId. 

![](images/200-getting-orders-2.png)

```js
//./models/user.js

const mongodb = require('mongodb');
const getDb = require('../util/database').getDb;

const ObjectId = mongodb.ObjectId;

class User {
  constructor(username, email, cart, id) {
    this.name = username;
    this.email = email;
    this.cart = cart; // {items: []}
    this._id = id;
  }

  save() {
    const db = getDb();
    return db.collection('users').insertOne(this);
  }

  addToCart(product) {
    const cartProductIndex = this.cart.items.findIndex(cp => {
      return cp.productId.toString() === product._id.toString();
    });
    let newQuantity = 1;
    const updatedCartItems = [...this.cart.items];
    if (cartProductIndex >= 0) {
      newQuantity = this.cart.items[cartProductIndex].quantity + 1;
      updatedCartItems[cartProductIndex].quantity = newQuantity;
    } else {
      updatedCartItems.push({
        productId: new ObjectId(product._id),
        quantity: newQuantity
      });
    }
    const updatedCart = {
      items: updatedCartItems
    };
    const db = getDb();
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: updatedCart } }
      );
  }

  getCart() {
    const db = getDb();
    const productIds = this.cart.items.map(i => {
      return i.productId;
    });
    return db
      .collection('products')
      .find({ _id: { $in: productIds } })
      .toArray()
      .then(products => {
        return products.map(p => {
          return {
            ...p,
            quantity: this.cart.items.find(i => {
              return i.productId.toString() === p._id.toString();
            }).quantity
          };
        });
      });
  }

  deleteItemFromCart(productId){
    const updatedCartItems = this.cart.items.filter(item => {
      return item.productId.toString() !== productId.toString()
    })
    const db = getDb()
    return db
      .collection('users')
      .updateOne(
        { _id: new ObjectId(this._id) },
        { $set: { cart: {items: updatedCartItems} } }
      )
  }

  addOrder(){
    const db = getDb()
    return this.getCart().then(products => {
      const order = {
        items: products,
        user: {
          _id: new ObjectId(this._id),
          name: this.name,
        }
      }
      return db
      .collection('orders')
      .insertOne(order)
    })
      .then(result => {
        this.cart = {items: []}
        return db
                .collection('users')
                .updateOne(
                  { _id: new ObjectId(this._id) },
                  { $set: { cart: { items: [] } } }
                )
    })
  }

  getOrders(){
    const db = getDb()
    /**each order has a user object
     * and in that user object, we have the ID of that user
     * so we need to compare that ID to the current user ID
     * now to do that, we add a filter 
     * and now in MongoDB, you can check nested properties by defining the path to them
     * the important thing to know here is that
     * you need to use quotation marks '' around the path
     * and then you can say check user and then the ID for the user
     * 
     * 'user._id' will look for _id in the user property which holds an embedded document
     * and then i can compare it is to a new objectId for this ID
     * and this should give me all orders for that user
     * and this will now be more than one
     * so again we can use the 'toArray()' shortcut
     * and return that data to return an array of orders for that user
     */
    return db
      .collection('orders')
      .find({ 'user._id': new ObjectId(this._id) })
      .toArray()
  }

  static findById(userId) {
    const db = getDb();
    return db
      .collection('users')
      .findOne({ _id: new ObjectId(userId) })
      .then(user => {
        console.log(user);
        return user;
      })
      .catch(err => {
        console.log(err);
      });
  }
}

module.exports = User;
```

```js
//./controllers/shop.js

const Product = require('../models/product');

exports.getProducts = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/product-list', {
        prods: products,
        pageTitle: 'All Products',
        path: '/products'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getProduct = (req, res, next) => {
  const prodId = req.params.productId;
  // Product.findAll({ where: { id: prodId } })
  //   .then(products => {
  //     res.render('shop/product-detail', {
  //       product: products[0],
  //       pageTitle: products[0].title,
  //       path: '/products'
  //     });
  //   })
  //   .catch(err => console.log(err));
  Product.findById(prodId)
    .then(product => {
      res.render('shop/product-detail', {
        product: product,
        pageTitle: product.title,
        path: '/products'
      });
    })
    .catch(err => console.log(err));
};

exports.getIndex = (req, res, next) => {
  Product.fetchAll()
    .then(products => {
      res.render('shop/index', {
        prods: products,
        pageTitle: 'Shop',
        path: '/'
      });
    })
    .catch(err => {
      console.log(err);
    });
};

exports.getCart = (req, res, next) => {
  req.user
    .getCart()
    .then(products => {
      res.render('shop/cart', {
        path: '/cart',
        pageTitle: 'Your Cart',
        products: products
      });
    })
    .catch(err => console.log(err));
};

exports.postCart = (req, res, next) => {
  const prodId = req.body.productId;
  Product.findById(prodId)
    .then(product => {
      return req.user.addToCart(product);
    })
    .then(result => {
      console.log(result);
      res.redirect('/cart');
    });
};

exports.postCartDeleteProduct = (req, res, next) => {
  const prodId = req.body.productId;
  req.user
    .deleteItemFromCart(prodId)
    .then(result => {
      res.redirect('/cart');
    })
    .catch(err => console.log(err));
};

exports.postOrder = (req, res, next) => {
  let fetchedCart;
  req.user
    .addOrder()
    .then(result => {
      res.redirect('/orders');
    })
    .catch(err => console.log(err));
};

exports.getOrders = (req, res, next) => {
  req.user
    .getOrders()
    .then(orders => {
      res.render('shop/orders', {
        path: '/orders',
        pageTitle: 'Your Orders',
        orders: orders
      });
    })
    .catch(err => console.log(err));
};

```

```js
// ./routes/shop.js

const path = require('path');

const express = require('express');

const shopController = require('../controllers/shop');

const router = express.Router();

router.get('/', shopController.getIndex);

router.get('/products', shopController.getProducts);

router.get('/products/:productId', shopController.getProduct);

router.get('/cart', shopController.getCart);

router.post('/cart', shopController.postCart);

router.post('/cart-delete-item', shopController.postCartDeleteProduct);

router.post('/create-order', shopController.postOrder);

router.get('/orders', shopController.getOrders);

module.exports = router;

```

```js
<!--./views/shop/orders.ejs-->

<%- include('../includes/head.ejs') %>
    </head>

    <body>
        <%- include('../includes/navigation.ejs') %>
        <main>
            <% if (orders.length <= 0) { %>
                <h1>Nothing there!</h1>
            <% } else { %>
                <ul>
                    <% orders.forEach(order => { %>
                        <li>
                            <h1># <%= order._id %></h1>
                            <ul>
                                <% order.items.forEach(product => { %>
                                    <li><%= product.title %> (<%= product.quantity %>)</li>
                                <% }); %>
                            </ul>
                        </li>
                    <% }); %>
                </ul>
            <% } %>
        </main>
        <%- include('../includes/end.ejs') %>
```

\* Chapter 202: Wrap Up
=======================

![](images/202-wrap-up-1.png)

\* Chapter 204: 2 Adjustments(Behind The Scenes)
================================================

Behind the scenes, 2 files were deleted

- order-item.js

- order.js

Why? We simply don’t need them anymore, the way we now structured our models
