\* Chapter 460: What Is Testing?
================================

![](images/460-what-is-testing-1.png)![460-what-is-testing-1.png](resources/571A0E120687E8393406E3FA3F699AA2.png)

- it’s a combination of both. manual testing which we did for the course in which you naturally do and automated testing what you will learn about in this module. 

\* Chapter 461: Why & How?
==========================

![](images/461-why-and-how-1.png)

![](images/461-why-and-how-2.png)![461-why-and-how-1.png](resources/1DE5E3DB7203F94FE307D565CCC5E56E.png)![461-why-and-how-2.png](resources/117B5A8C7411BCADA5F2BA1356A1ADBF.png)

- we will use mocha and Chai in this module here too. there are alternatives like ‘Jest’ but mocha and Chai are really popular exist for a long time. 

\* Chapter 462: Setup And Writing A First Test
==============================================

1\. update

- package.json

- ./test/start.js

![](images/462-setup-and-writing-a-first-test-1.png)

![](images/462-setup-and-writing-a-first-test-2.png)

![](images/462-setup-and-writing-a-first-test-3.png)

![](images/462-setup-and-writing-a-first-test-4.png)

![](images/462-setup-and-writing-a-first-test-5.png)![462-setup-and-writing-a-first-test-1.png](resources/1164C20507CF3F6C6C67FE34AD2047E6.png)![462-setup-and-writing-a-first-test-2.png](resources/ECFFA2F8DB2E351F2F239A727C55AF35.png)![462-setup-and-writing-a-first-test-3.png](resources/54C4D9961C2617BC378AE863B83050A0.png)![462-setup-and-writing-a-first-test-4.png](resources/957A3CA43563429D981E2404725CD863.png)![462-setup-and-writing-a-first-test-5.png](resources/E73714913A3921DCEA6748FCE7B7DE15.png)

- ’npm test’ will now run all your tests you defined in this project. and mocha by default looks for a folder named ’test’. it should be named as ’test’ folder. 

- so if you run npm test, it will automatically look for test folder and execute all tests and all files defined in that test folder. 

![](images/462-setup-and-writing-a-first-test-6.png)![462-setup-and-writing-a-first-test-6.png](resources/BB3F4661FC6B9414940770D106455CE5.png)

- in the output, we see it a checkmark which is now executed correctly as you can see and that is what you wannna see when writing tests. 

![](images/462-setup-and-writing-a-first-test-7.png)

![](images/462-setup-and-writing-a-first-test-8.png)

![](images/462-setup-and-writing-a-first-test-9.png)

![](images/462-setup-and-writing-a-first-test-10.png)![462-setup-and-writing-a-first-test-7.png](resources/C948B18A34F3EDCA85B97460547E15D3.png)![462-setup-and-writing-a-first-test-8.png](resources/D8932ED7783645E54E66D47F3D660542.png)![462-setup-and-writing-a-first-test-9.png](resources/919333B9B1A02FB7CDEB89134D009FFC.png)![462-setup-and-writing-a-first-test-10.png](resources/8AD5395940D64B9BF35175245F46BB71.png)

- if i change to get failed result, then get failed test result.

```js
{
  "name": "nodejs-complete-guide",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "mocha",
    "start": "nodemon app.js"
  },
  "repository": {
    "type": "git",
    "url": "https://git-codecommit.us-east-1.amazonaws.com/v1/repos/udemy-course-nodejs-complete"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.18.3",
    "express": "^4.16.3",
    "express-validator": "^5.3.0",
    "jsonwebtoken": "^8.3.0",
    "mongoose": "^5.3.2",
    "multer": "^1.4.0"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^6.1.4",
    "nodemon": "^1.18.4"
  }
}

```

```js
//./test/start.js

/**they are all different way of defining our conditions
 * like 'should, or 'assert'
 */
const expect = require('chai').expect;

/**'it()' function is provided by mocha
 * that gives your test name and read like plain english sentences
 * because indeed it takes 2 arguments
 * and the 1st one is a string which describes your test.
 * so this should be a title
 * that describes what is happening in the test.
 * 
 * 2nd argument is the function
 * which defines your actual test code.
 */
it('should add numbers correctly', function() {
    const num1 = 2;
    const num2 = 3;
    /**mocha is responsible for running our tests
     * and for  giving us this 'it()' function
     * that defines where we define our test code
     * chai is responsible for defining our success conditions
     * and for this we just need to import something Chai
     * 
     * inside 'expect()',
     * you pass your code or result that you wanna test
     * and there you have properties like 'to'
     * and then on 'to' property,
     * you have another object which gives you things like 'equal()'
     * which is a function where you can define the value you expect as 'to.equal()'
     */
    expect(num1 + num2).to.equal(5)
})

it('should not give a result of 6', function(){
    const num1 = 2;
    const num2 = 3;
    /**we are checking whether this is not only 5 but also not 6*/
    expect(num1 + num2).not.to.equal(6);
})
```

\* Chapter 463: Testing The Auth Middleware
===========================================

1\. update

- ./test/auth-middleware.js

![](images/463-testing-the-auth-middleware-1.png)![463-testing-the-auth-middleware-1.png](resources/B3E91EF8AB0E372D565484EDE0D6DE6D.png)

- we are not simulating a click of the user which then sends a request which then triggers the middleware. we just wanna test our middleware function. this is called ‘unit test' we test one unit of our application. in this case, these code is a unit the function. 

- ‘intergration test’ would be where we test a more complete flow. whether your request is routed correctly and then all of the middleware and then also the controller function. but you don’t test that too often because it’s very complex to test such long chains. there are multiple things to fail. by unit test, it’s way easier to test different scenarios for each unit. and if all your unit tests succeed, you have a great chance of your overall application working correctly. and therefore unit test is very helpful. if a unit test fails, it’s easy to find out why it fails. 

- i know that the code i wanna test calls to get method and i wanna return null to simulate that there is no authorization header because i know the code and testing and i wanna test different scenarios and this is how you have to think about testing your testing different scenarios. you are not trying to rebuild the framework. you wanna force your code into certain scenarios you wanna test them under certain scenarios. and here the scenario is that the get method on the request object returns null.

![](images/463-testing-the-auth-middleware-2.png)

![](images/463-testing-the-auth-middleware-3.png)![463-testing-the-auth-middleware-2.png](resources/A9B98D1776C72D581570AF6F6F77FE6E.png)![463-testing-the-auth-middleware-3.png](resources/DD0FEB982D8670EC8763611F0FB8452A.png)

- if you are expecting a slightly different error message from ’Not authenticated.’ to ’Not authenticated!’ which is different from ./middleware/is-auth.js file, then you get a failure because we expect it to throw an error including ’Not authenticated!’ not ’Not authenticated.’ so we have to be clear because you can test for all kinds of different things. 

- therefore this test only succeeds if we have an error.

![](images/463-testing-the-auth-middleware-4.png)

![](images/463-testing-the-auth-middleware-5.png)![463-testing-the-auth-middleware-4.png](resources/F492FD96B118426817288B9EB01904B2.png)![463-testing-the-auth-middleware-5.png](resources/EC5C98D2D7A1DABECA543C5F1DF3E1CC.png)

- the cool thing is if we ever change something about this code for example, we decide to remove this chek where we check for the header and i run my npm test, i get an error and that tells me i need to do something because my test failed. this test where i wanna make sure that not being able to retrieve the header throw the error. that doesn’t pass anymore and therefore i should have a look at my middleware and i can find out i commont that out or maybe i never added this functionality in the first place.

```js
//./test/auth-middleware.js

const expect = require('chai').expect;

const authMiddleware = require('../middleware/is-auth');
it('should throw an error if no authorization header is present', function(){
    /**we are not simulating a click of the user
     * which then send a request
     * which then triggers the middleware
     * we just wanna test our middleware function
     * this is called 'unit test'
     * by the way we test one unit of our application
     *
     * we wanna define our own request object
     * and that is great
     * because that allows us to define different scenarios.
     */
    const req = {
        /**'get' is from 
         * 'const authHeader = req.get('Authorization')' 
         * in ./middleware/is-auth.js 
         * 
         * in reality,
         * it returns the value of authorization header
         * in reality,
         * it doesn't only scan headers,
         * it scans different parts of the incoming request
         * but our goal now is not to replicate the express.js
         * but to test one specific scenario
         * so 'get('Authorization')' doesn't return an authorization header
         * because that's what we wanna test here
         * that in this case we throw an error.
         * */
        get: function(headerName){
            /**this means it doesn't return a value for our authorization call here 
             * i know that the code i wanna test calls to get method 
             * and i wanna return null to simulate 
             * that there is no authorization header 
             * because i know the code and testing 
             * and i wanna test different scenarios 
             * and this is how you have to think about testing different scenarios. 
             * you are not trying to rebuild the framework. 
             * you wanna force your code into certain scenarios 
             * you wanna test them under certain scenarios. 
             * and here the scenario is that the get method on the request object returns null.
            */
            return null;
        }
    };
    /**we can call authMiddleware
     * and pass in our own request object
     * which has nothing else
     * the request object normally has
     * but it has everything we need for this test there.
     * we only need get method
     * and it has that now for the response object we can pass on an empty object
     * becuase we are not testing anything related to this response object
     * and the code we are testing also doesn't rely on it
     * it doesn't use the resopnse object in this entire function
     * and therefore we don't need to spend any thime on adding any logic to this response object
     * 
     * the next function which is called at the end
     * we wanna pass it in
     * but we don't care about what it does
     * because we are not really executing on next step anyways.
     * so i will just pass in an empty arrow function
     * so that it's able to call that without throwing it error
     * but it doesn't do anything
     * because it's not when i want a test
     * i only wanna test behavior when get returns null
     */

     /**so i expect this function call for a request 
      * that returns null
      * when we try to get something for given header name.
      */

      /**i'm calling my middleware function
       * and this middleware function happens to throw an error
       * i don't wanna call it myself,
       * i wanna let my testing framework mocha and chai
       * so that they can handle the flow and error
       * instead of calling authMiddleware function directly ourselves,
       * we instead only pass a reference to this function
       * 
       * we only wanna bind the arguments we wanna pass in
       * when our testing set up calls this function
       * 'bind' first of all requires input for the 'this' keyword
       * it has 3 arguments
       * that will be passed into the authMiddleware function once it gets called
       * we are instead passing a prepared reference to our function
       * you could say prepared in the sense of where defining 
       * which argument get passed in
       * so we are passing the prepared reference to expect.
       * 
       * this test therefore only succeeds if we have an error
       * but if we are not throwing an error
       * or if we are instead sending our own error response
       * and we are not throwing an error,
       * then this test wouldn't succeed
      */
    expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
})
```

\* Chapter 464: Organizing Multiple Tests
=========================================

1\. update

- ./test/auth-middleware.js

![](images/464-organizing-multiple-tests-1.png)![464-organizing-multiple-tests-1.png](resources/1265401CE5CAD64A7B4B363731609679.png)

- it succeed because we get an error if we passed this ‘xyz’ in

![](images/464-organizing-multiple-tests-2.png)![464-organizing-multiple-tests-2.png](resources/61908E069EB5450C370FB0E83E41273A.png)

- if i check for ‘.not.to.throw()’, then we get error here because it expected that not to throw an error but we got an error here.

![](images/464-organizing-multiple-tests-3.png)![464-organizing-multiple-tests-3.png](resources/B6DA42444FF791C8446A821CA2EB953E.png)

- you can group test using ‘describe()’ function which can be nested inside itself.

```js
//./test/auth-middleware.js

const expect = require('chai').expect;

/**'describe()' function group your tests
 * and you can nest as many describe function calls 
 * as you want inside of each other
 * 'describe' also takes a title
 * and that is not english sentence
 * but instead like a header for the group you are describing like for example authMiddleware
 * 
 * in 2nd argument,
 * you pass all your test cases as this function calls are called.
 */
describe('Auth middleware', function(){
    const authMiddleware = require('../middleware/is-auth');
    it('should throw an error if no authorization header is present', function(){
        const req = {
            get: function(headerName){
                return null;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    })
    
    it('should throw an error if the authorization header is only one string', function(){
        const req = {
            get: function(headerName){
                return xyz;
            }
        };
        /**you could check for an exact error message
         * but if you are not sure or
         * if you only care about whether an error is frozen at all,
         * you can also just check for just 'throw()'
         * without passing any argument to it.
         */
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })
})
```

\* Chapter 465: What Not To Test
================================

1\. update

- ./test/auth-middleware.js

- you should not test whether the verify function works correctly. you should not test whether this verifies a token correctly. because this is not a function or a method owned by you. this is coming from a 3rd party package from the jsonwebtoken package and it’s the job of the package offeres to test their own code and to make sure that works correctly. it’s not your job. 

- we only wanna test if our code behaves correctly when verifications fails for example or when it succeeds. we wanna test if our code then behaves correctly depending what verify does

- this introduce one new problem. verify comes from a 3rd party package and therefore it does its job. if you wanna test if our code works correctly, it’s easy to test for failure. we can pass on a token that is not verified by this package because we don’t know which tokens it creates for us. tokens are these super long strings. we can’t guess them. so whatever we pass into function will probably fail here in the verification step. 

![](images/465-what-not-to-test-1.png)

![](images/465-what-not-to-test-2.png)

![](images/465-what-not-to-test-3.png)

![](images/465-what-not-to-test-4.png)![465-what-not-to-test-1.png](resources/DFB5AC3604248112ABCD2253D0EB3707.png)![465-what-not-to-test-2.png](resources/5F3ACEF4C5D32D2AE8C3677551CB8CF1.png)![465-what-not-to-test-3.png](resources/55A415D82592ADDA5E73D58F26FFB73A.png)![465-what-not-to-test-4.png](resources/DB62F63C001F9C128325E882C3408726.png)

- this test failed. it should yield a userId after decoding the token. but what we get is an error. we get that error because our token is malformed because it’s too short ‘Bearer fjdkslaf;d’. it’s not fulfilling the criteria of the JWT verify method and therefore it’s filling an error. it’s throwing an error that the token is malformed. 

![](images/465-what-not-to-test-5.png)![465-what-not-to-test-5.png](resources/0F5BFEDDBA6B27985B6135FB7FB8244F.png)

- we can’t always test if it fails but we also wanna test the success case because maybe we have scenarios in our application where it’s not failing with an error and still the userId is not getting stored in the request because we don’t have that code here. then we would have a bug in our application which we wanna detect with tests and this would not throw an error at any point. and still we wanna detect this error already 

![](images/465-what-not-to-test-6.png)![465-what-not-to-test-6.png](resources/67ABC8E5B686F671B02BB07272A85557.png)

- therefore test like this one would be super important because we test whether we have a userId stored in the request object after running ‘authMiddleware’

![](images/465-what-not-to-test-7.png)![465-what-not-to-test-7.png](resources/3C0D552678712CC8C855CFBEC001DE79.png)

- so to find that, we need some way of shutting down that verify method. 

![](images/465-what-not-to-test-8.png)![465-what-not-to-test-8.png](resources/61AB06242B2EE007E31F83724870AF9F.png)

- we know that this is not a valid token but for this test we don’t care. we wanna test scenario where we have a valid token. we know that this would not be a valid token vut this is not important to us here. we don’t need to test whether it is really fails for a random token here. 

- we wanna succeed for a random token because we then wanna test something different. we wanna test if our app works correctly for valid tokens no matter if this really is a valid token here or not. 

- how can we shut down verify and make sure it simply gives us an object with a userId so that we can pull that userId from that object?

```js
//./test/auth-middleware.js

const expect = require('chai').expect;

describe('Auth middleware', function(){
    const authMiddleware = require('../middleware/is-auth');
    it('should throw an error if no authorization header is present', function(){
        const req = {
            get: function(headerName){
                return null;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    })
    
    it('should throw an error if the authorization header is only one string', function(){
        const req = {
            get: function(headerName){
                return xyz;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })

    it('should throw an error if the token cannot be verified', function(){
        const req = {
            get: function(headerName){
                /**'xyz' will be incorrect token, not a token by the JWT package
                 */
                return 'Bearer xyz';
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })
    /**if we add another test where we wanna check
     * if this is a valid token,
     * then decodedToken should have a user id
    */
    it('should yield a userId after decoding the token', function(){
        const req = {
            get: function(headerName){
                return 'Bearer fjdkslaf;d';
            }
        };
        authMiddleware(req, {}, () => {});
        /**we now expect our request object to have a new property
         * because we add a new property in the middleware userId property
         * 
         * this is something we could expect for a valid token
         * because if the token is valid
         * if it is verified,
         * then we we make it pass 'try and catch' block
         * then it checks if it is defined
         * then it checks again if it really is defined
         * and we expect that to be defined
         * and then we get the userId from the decodedToken
         * and we store it in request
         * so expecting that userId property to exist on the request seems vaild
         * 
         */
        expect(req).to.have.property('userId')
    })
})
```

\* Chapter 466: Using Stubs
===========================

![](images/466-using-stubs-1.png)

![](images/466-using-stubs-2.png)

![](images/466-using-stubs-3.png)![466-using-stubs-1.png](resources/0F5BFEDDBA6B27985B6135FB7FB8244F.png)![466-using-stubs-1.png](resources/5C8F333D8FC9175B210548B3DC759D66.png)![466-using-stubs-2.png](resources/D38AD620AFEF1FB9C3905CFC2901681B.png)

- to solve that, we can use marks or stubs which means we replace this verify method with a simpler method. 

- ‘decodedToken = jwt.verify(token, ’somesupersecretsecret’)’ we are overwriting the actual verify method that is package has. the way module imports work in node.js. if we overwrite it here, this will be the case in the middleware when it runs to. because we have one global package.

- so we overwrite with our own function. so if i run npm test, our own function gets executed and that will return a userId in that object that gives us and therefore it will first of all nont throw an error and it also gives us a way of pulling out our userId. 

- if i npm test, this will still fail. but now it fails because we expected to have a property userId but we don’t. we only have an object with a get method 

![](images/466-using-stubs-4.png)![466-using-stubs-3.png](resources/FE1B308DFCBCDECA6DAA7493BDE81904.png)

- because we only have this object. we don’t have a userId 

![](images/466-using-stubs-5.png)

![](images/466-using-stubs-6.png)

![](images/466-using-stubs-7.png)

![](images/466-using-stubs-8.png)![466-using-stubs-4.png](resources/51140728BA0F3E39CCC5F733B0D40E49.png)![466-using-stubs-5.png](resources/15120B1111C0FFB2CDE373E76C78516B.png)![466-using-stubs-6.png](resources/6024DAA81527D31A2F753068BA40604E.png)![466-using-stubs-7.png](resources/2267441CEE41AFDA73996C7F7A53DB18.png)

- and we can look into our code and see we should add this code again to make sure we stored at userId in the request object. 

- and if we npm test, then we have 4 passing tests because we replace the built-in verify method and that is common way of handling such cases. 

- however instead of manually overwriting like this, there is a more elegant way. 

![](images/466-using-stubs-9.png)

![](images/466-using-stubs-10.png)

![](images/466-using-stubs-11.png)![466-using-stubs-8.png](resources/C2013524BEEAC5D53B922893B62C8C1E.png)![466-using-stubs-9.png](resources/D58727E2F59C75C5DA2D0A3599AA7B60.png)![466-using-stubs-10.png](resources/52DAA27810F7D2A2C6822CF8F5889BBC.png)

- because this has a huge downside which becomes evident if i cut this test, i put it in front of the test, we had before that ‘should throw an error if the token cannot be verified', 

![](images/466-using-stubs-12.png)![466-using-stubs-11.png](resources/1D9B180C01343398F38C5AABC5F0B5DB.png)

- that is the test where it should throw an error if we have an invalid token. ‘Bearer xyz'

- note that before all test passed, so we get an error for an invalid token.

![](images/466-using-stubs-13.png)

![](images/466-using-stubs-14.png)![466-using-stubs-12.png](resources/EAD9F659C8EDFC5059D734F15E1E2AF4.png)![466-using-stubs-13.png](resources/BD488C29E94693626990B5FE33FEEDAE.png)

- here we are then overwriting verify to never throw an error. so now after i switched the order of tests, i have a problem with my last test 

![](images/466-using-stubs-15.png)![466-using-stubs-14.png](resources/A1C494BC2DF401D5EAE45B57C55739D4.png)

- because this doesn’t throw an error anymore. because in this test, i globally replaced the verify method. that is not ideal. it’s good for this test to succeed but it means that if i have any other test that needs the original verify method. it has no chance of getting that. because we replaced it here

- therefore instead of manually stopping or mocking functionalities and replacing them, it’s good to use packages that allow you to restore the original setup. 

![](images/466-using-stubs-16.png)![466-using-stubs-15.png](resources/C300EF3B37598630D5CEC3F85B74BEED.png)

- for that will install extra package. ’npm install —save-dev sinon’ which is the package that allows us to create a so-called stub which is replacement for the original function where we can easily restore the original function.

![](images/466-using-stubs-17.png)![466-using-stubs-16.png](resources/E3C448B8E1A6CC820B5763C3076310C7.png)

- 4 tests passing. because if i run npm test again, all tests pass again because i restore the original function after this test where i needed a different behavior. 

![](images/466-using-stubs-18.png)

![](images/466-using-stubs-19.png)![466-using-stubs-17.png](resources/AADA8FF08C3E198D8960FB62F7B28685.png)![466-using-stubs-18.png](resources/3B3E8772D8CE05BB3E9734F848258059.png)

- if so, our average test would still succeed. but we get an error because we expect that false(jwt.verify.called is comment now) to be true.

```js
//./test/auth-middleware.js

const expect = require('chai').expect;
const jwt = require('jsonwebtoken');
const sinon = require('sinon');

describe('Auth middleware', function(){
    const authMiddleware = require('../middleware/is-auth');
    it('should throw an error if no authorization header is present', function(){
        const req = {
            get: function(headerName){
                return null;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw('Not authenticated.');
    })

    it('should throw an error if the authorization header is only one string', function(){
        const req = {
            get: function(headerName){
                return xyz;
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })

    it('should yield a userId after decoding the token', function(){
        const req = {
            get: function(headerName){
                return 'Bearer fjdkslaf;d';
            }
        };
        /**instead of manually replacing it like this,
         * i call sinon.stub()
         * and i pass in the object
         * where i have the method i wanna replace.
         * that is jwt
         * and 2nd argument is passing the object
         * which has the method i wanna replace
         * and then as a string the method name 'verify'
         * 
         * sinon will replace that
         * by default, it replace it with an empty function
         * that doesn't do anything special though that's not entirely true
         * it will do with things like registering function calls and so on. 
         * so you can test for things like
         * has this function be called no matter what it executes
         */
        sinon.stub(jwt, 'verify')
        /**'returns()' is by sinon
         * that allows us to configure what this function should return
         * 
         * this stub also register things like function calls
         */
        jwt.verify.returns({userId: 'abc'})
        authMiddleware(req, {}, () => {});
        expect(req).to.have.property('userId')
        /**for completeness sake,
         * we can test if request has a property userId with certain value
         * that's optional 2nd argument you can pass to that property method
         * so we wanna make sure the value 'abc'
         * that's a redundant test
         * because we defined the value down there.
         */
        expect(req).to.have.property('userId', 'abc')
        /**this stub also register things like function calls
         * verify method has been called in our authMiddleware
         * and
         */
        expect(jwt.verify.called).to.be.true;
        /**after checking our expectation,
         * we can call jwt.verify.restore()
         * which will restore the original function
         * that is the big difference to our own stub
         * where we replace as on our own. 
         */
        jwt.verify.restore();
    })

    it('should throw an error if the token cannot be verified', function(){
        const req = {
            get: function(headerName){
                /**'xyz' will be incorrect token, not a token by the JWT package
                 */
                return 'Bearer xyz';
            }
        };
        expect(authMiddleware.bind(this, req, {}, () => {})).to.throw();
    })
})
```

\* Chapter 468: Testing Asynchronous Code
=========================================

1\. update

- ./routes/auth.js

- ./controllers/auth.js

- ./test/auth-controller.js

![](images/468-testing-asynchronous-code-1.png)![468-testing-asynchronous-code-1.png](resources/BF87EE490D799AB99939C635EDB89F2D.png)

- we can see all pass which is strange 

![](images/468-testing-asynchronous-code-2.png)![468-testing-asynchronous-code-2.png](resources/CCFEA9BA55672BC8811840A9A103761A.png)

- but if we scroll up a bit, you can see ‘undefined’ here. 

![](images/468-testing-asynchronous-code-3.png)![468-testing-asynchronous-code-3.png](resources/8E9D12FE48DD551CFE36F1D0353C094F.png)

- because go back to ./controllers/auth.js file, i return undefined and that is what i return as a value of that promise that gets returned.

![](images/468-testing-asynchronous-code-4.png)

![](images/468-testing-asynchronous-code-5.png)![468-testing-asynchronous-code-4.png](resources/D36CA61F777A336C439CAF2AFF4C90E8.png)![468-testing-asynchronous-code-5.png](resources/47211504C795D1B0C96D6F635E791D70.png)

- now if i rerun npm test, we see that error object being log up. 

![](images/468-testing-asynchronous-code-6.png)![468-testing-asynchronous-code-6.png](resources/0D6F6E1740C9B6DA1F1B31D80A23B676.png)

- this looks good everything passes.

![](images/468-testing-asynchronous-code-7.png)![468-testing-asynchronous-code-7.png](resources/255929218B899A0E6599586BCE8048EB.png)

- but this is false pass here.

![](images/468-testing-asynchronous-code-8.png)![468-testing-asynchronous-code-8.png](resources/4C5A3C092A90D4216E957D1CED816127.png)

- it passes because mocha doesn’t wait for this test case to finish because we have async code. and by default it doesn’t wait for that async code to resolve. it doesn’t wait for this promise to resolve no matter how fast is this. 

- we can tell mocha to wait and we do this by adding extra argument in this function. we pass to it and that’s the ‘done’ argument. 

![](images/468-testing-asynchronous-code-9.png)

![](images/468-testing-asynchronous-code-10.png)![468-testing-asynchronous-code-9.png](resources/1C5C59516EEFFD99D75A2BC43478329C.png)![468-testing-asynchronous-code-10.png](resources/C914C167AC7AF8E7CF0F046E9F74551F.png)

- now it passes again but now this is a valid test and we can confirm this by changing this expected statusCode to 401

![](images/468-testing-asynchronous-code-11.png)

![](images/468-testing-asynchronous-code-12.png)![468-testing-asynchronous-code-11.png](resources/9DE6FE97C11B320548620ADADD1C966A.png)![468-testing-asynchronous-code-12.png](resources/0C006A92E9523D6C8D132FBC9CEBA4A3.png)

- if i now run npm test, it fails. it should throw an error code 500 and if you scroll up here, you see you got an error code 401\. 

![](images/468-testing-asynchronous-code-13.png)![468-testing-asynchronous-code-13.png](resources/36609D2A7106F8D5F7A72E5DD20324D2.png)

- without ‘done’, all tests pass even though it gets error. so it’s important to pass ‘done’ and then call it once you are done to make sure that your tests were correctly.

```js
//./routes/auth.js

const express = require('express');
const { body } = require('express-validator/check');

const User = require('../models/user');
const authController = require('../controllers/auth');
const isAuth = require('../middleware/is-auth');

const router = express.Router();

router.put(
  '/signup',
  [
    body('email')
      .isEmail()
      .withMessage('Please enter a valid email.')
      .custom((value, { req }) => {
        return User.findOne({ email: value }).then(userDoc => {
          if (userDoc) {
            return Promise.reject('E-Mail address already exists!');
          }
        });
      })
      .normalizeEmail(),
    body('password')
      .trim()
      .isLength({ min: 5 }),
    body('name')
      .trim()
      .not()
      .isEmpty()
  ],
  authController.signup
);

/**what will not test is the routing here '/login'
 * we will not test whether we can send a request to login
 * and we execute the login function in the ./controllers/auth.js
 * because that entire forwarding of the request the execution of this method here
 * 'authController.login'
 * that is all handled by express.js
 * as i mentioned earlier, you don't wanna test our libraries.
 * you wanna test your own code
 * so we will just test 'login' or 'singup' in ./controllers/auth.js
 */
router.post('/login', authController.login);

router.get('/status', isAuth, authController.getUserStatus);

router.patch(
  '/status',
  isAuth,
  [
    body('status')
      .trim()
      .not()
      .isEmpty()
  ],
  authController.updateUserStatus
);

module.exports = router;

```

```js
//./controllers/auth.js

const { validationResult } = require('express-validator/check');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');

const User = require('../models/user');

exports.signup = async (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed.');
    error.statusCode = 422;
    error.data = errors.array();
    throw error;
  }
  const email = req.body.email;
  const name = req.body.name;
  const password = req.body.password;
  try {
    const hashedPw = await bcrypt.hash(password, 12);

    const user = new User({
      email: email,
      password: hashedPw,
      name: name
    });
    const result = await user.save();
    res.status(201).json({ message: 'User created!', userId: result._id });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.login = async (req, res, next) => {
  const email = req.body.email;
  const password = req.body.password;
  let loadedUser;
  try {
    /**User model is based on mongoose and MongoDB
     * so how can we test our Database?
     * 
     * strategy 1 for testing code that involves database operations
     * is that we stub or mock the part that rely on dataase access
     * when we execute findOne,
     * we again create a step that returns a predefined result
     * and we then test if our code behaves correctly.
     * for example,
     * we might be interested in finding out
     * how our code behaves when findOne throws error.
     * so if we are having trouble interacting with the database
     * or how our code behaves if we don't have a user with that email address when logging in
     * these are 2 different scenarios
     * and we can write 2 different tests for that.
     * 
     * we throw error on 'no user' manually
     * and if fineOne fails, it will throw an error
     * but statusCode for example should be different
     * because the statusCode should be 500
     * if the database fails
     * because we use our default code
     * or we set our own 401 code.
     * if we have no user
     */
    const user = await User.findOne({ email: email });
    if (!user) {
      const error = new Error('A user with this email could not be found.');
      error.statusCode = 401;
      throw error;
    }
    loadedUser = user;
    const isEqual = await bcrypt.compare(password, user.password);
    if (!isEqual) {
      const error = new Error('Wrong password!');
      error.statusCode = 401;
      throw error;
    }
    const token = jwt.sign(
      {
        email: loadedUser.email,
        userId: loadedUser._id.toString()
      },
      'somesupersecretsecret',
      { expiresIn: '1h' }
    );
    res.status(200).json({ token: token, userId: loadedUser._id.toString() });
    /**so in the success case,
     * i return nothing in that promise
     */
    return;
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  /**or which in the end gets returned the error. */
    return err;
  }
};

exports.getUserStatus = async (req, res, next) => {
  try {
    const user = await User.findById(req.userId);
    if (!user) {
      const error = new Error('User not found.');
      error.statusCode = 404;
      throw error;
    }
    res.status(200).json({ status: user.status });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.updateUserStatus = async (req, res, next) => {
  const newStatus = req.body.status;
  try {
    const user = await User.findById(req.userId);
    if (!user) {
      const error = new Error('User not found.');
      error.statusCode = 404;
      throw error;
    }
    user.status = newStatus;
    await user.save();
    res.status(200).json({ message: 'User updated.' });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

```

```js
//./test/auth-controller.js

const expect = require('chai').expect;
const sinon = require('sinon');

const User = require('../models/user');
const AuthController = require('../controllers/auth');

describe('Auth Controller - Login', function() {
    /**mocha doesn't wait for this test case to finish
     * because we have async code
     * and by default, it doesn't wait for async code to resolve
     * it doesn't wait for promises to resolve no matter how fast is this
     * 
     * we can tell mocha to wait
     * and we do this by adding extra argument in this function
     * we pass to it
     * and that's 'done' argument
     * this is optional
     * and it's the function which you can call
     * so mocha gives you a function 'done'
     * which you can call once this test case is done 
     * by default, it's done once the execute the code top to bottom
     * but if you accept this argument,
     * it will wait for you to call it
     * and then you can call it in a asynchronous code snippet.
     */
  it('should throw an error with code 500 if accessing the database fails', function(done) {
        /**the important thing is that
         * i'm faking that database fails
         * because i replace findOne method with stub
         * that throw an error
         * because i wanna check we should throw an error with code 500
         * so i wanna check whether our default statusCode 500 get applied correctly
         */
    sinon.stub(User, 'findOne');
    User.findOne.throws();
        /**in login in ./controllers/auth.js file,
         * we use async code
         * which means in the end we use promises in there
         * and that means we have asynchronous code
         * which is a some complexity we have to deal with
         * because the execution of that code will not happen synchronously
         * that means by default our expectation won't work the way you might expect it to work
         * 
         * we wanna check whether that promises we had there
         * eventually returns an error for this test
         * for that, let's make a tiny adjustment in ./controllers/auth.js file
         */
        //expect(AuthController.login)
    const req = {
      body: {
        email: 'test@test.com',
        password: 'tester'
      }
    };

    AuthController.login(req, {}, () => {}).then(result => {
            /**Chai is able to detect a couple of types of data
             * and error is one of them*/
      expect(result).to.be.an('error');
      expect(result).to.have.property('statusCode', 500);
            /**this is the signal
             * that i want mocha to wait for this code to execute
             * because before this async code,
             * this test above case is done
             */
      done();
    });

    User.findOne.restore();
  });
});

```

\* Chapter 470: Testing Code With An Active Database
====================================================

![](images/470-testing-code-with-an-active-database-1.png)![470-testing-code-with-an-active-database-1.png](resources/1EDF43C57CFC3AC14B38F50355FAA688.png)

- if i run npm test, we have 6 passing tests including this one here. it took quite long. 

![](images/470-testing-code-with-an-active-database-2.png)![470-testing-code-with-an-active-database-2.png](resources/75FADC109CDFFD2A61C6DAA88187A8CD.png)

- by the way, if this time’s out, you can define a longer timeout period by going to your scripts and adding ‘—timeout 5000’ 5second because this is milliseconds. default is 2000 milliseconds. 

![](images/470-testing-code-with-an-active-database-3.png)![470-testing-code-with-an-active-database-3.png](resources/489293033FA08E886EEDAC4D5691D734.png)

- if i go to database, i have that dummy user. 

![](images/470-testing-code-with-an-active-database-4.png)![470-testing-code-with-an-active-database-4.png](resources/43978435D581EDFCEE0B277F7857063F.png)

- if you wanna really be sure, if i check for a different status not ‘I am new!’ but ‘I am new!!’ which is incorrect and rerun this.

![](images/470-testing-code-with-an-active-database-5.png)![470-testing-code-with-an-active-database-5.png](resources/7CF409A6C637ABAF7819C732F001D3DE.png)

- then we get a timeout error because we got one failing test where we have that test up there failing. 

![](images/470-testing-code-with-an-active-database-6.png)![470-testing-code-with-an-active-database-6.png](resources/BC97FC40A0404A4397408061E503FB53.png)

- however it fails for a different reason if you watch closely, you will see it fails because we have a duplicate key issue 

![](images/470-testing-code-with-an-active-database-7.png)![470-testing-code-with-an-active-database-7.png](resources/5AE4318E66C1EBD94E2EF2A761761A48.png)

- and that stems from our setup code. create a new user. that now for the second test run, already exists and they are all different issues. this process doesn’t quit as it did before we manually have to do this with control+c let’s fix in the next lecture.

\* Chapter 471: Cleaning Up
===========================

![](images/471-cleaning-up-1.png)![471-cleaning-up-1.png](resources/15A90C15C6F47326F7FD2B98EB1FC417.png)

- why do i need to quit this process with control+c? the reason is despite me calling done mocha detects that there is still some open process in the event loop and indeed there is our database connection which we opn but never close. 

![](images/471-cleaning-up-2.png)

![](images/471-cleaning-up-3.png)

![](images/471-cleaning-up-4.png)![471-cleaning-up-2.png](resources/29E3475B832E8EF4D46765B0AA399D11.png)![471-cleaning-up-3.png](resources/DE6B2A06DE66686FA4D4828820CA0432.png)![471-cleaning-up-4.png](resources/124D72327F1454911811F8ABDE14E1C6.png)

- so one thing we should do is when we are done with our expectations, we might wanna call Mongoose disconnect and only when this is done. but it wouldn’t work because we have an overall error in our test case. 

![](images/471-cleaning-up-5.png)![471-cleaning-up-5.png](resources/2BB9609475CAA8474FC86AB452EC1BCA.png)

- this is not perfect as you can tell whenever a test fails, we don’t make it into this cleanup phase because that will throw an error and therefore we would have to add a catch phrase overall so we don’t make it into this cleanup part here. if an expectation fails and in general this is pretty clucky and pretty hard to read code and if we have a test that require a MongoDB database or our dummy set up, then we have to repeat all that code and therefore there is a cleaner solution to all of that. 

\* Chapter 472: Hooks
=====================

1\. update

- ./test/auth-controller.js

- package.json

- the cleaner solution comes in the form of lifecycle hooks provided by mocha. inside describe() function, we have a certain extra functions we can call that will run before each tests at the same for after and after each what do i mean with that? 

- let’s say connecting to the database and creating one dummy user is something we wanna do when our tests run not before every test. so we don’tn wanna reconnect and recreate a user before every test. but initially when our test run starts. 

![](images/472-hooks-1.png)![472-hooks-1.png](resources/AD5EDC6A83C50E10EF657A62E4B47C1A.png)

- so i wanna run this code. i will cut it before every test. 

![](images/472-hooks-2.png)![472-hooks-2.png](resources/F4914F61DE5BED825169D5DE549E490E.png)

- you can be achieved by ‘before()’ function. once you are done, mocha knows you are done with your initialization and it will start running your test cases. so it runs all your test cases after 'before()’ and before() only executes once not before every test case but before all test cases. 

![](images/472-hooks-3.png)![472-hooks-3.png](resources/1E7EE4E8206185F39C03FC979A2FBA1A.png)

- besides ‘before()’ and ‘after()’, there also are ‘beforeEach()’ and ‘afterEach()’. the differences is that ‘beforeEach’ is initialization work that it runs before every test case. before runs before all test case. it’s not repetitive. it only runs once per test. so it’s useful if you need to reset something before every test case or if you wanna have some initialization work that has to run before every test case and there are all those 'afterEach()’ in case, there is some functionality which need to run after every test case. so cleanup work which needs to be done after every test case.

```js
//package.json

{
  "name": "nodejs-complete-guide",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "mocha --timeout 5000",
    "start": "nodemon app.js"
  },
  "repository": {
    "type": "git",
    "url": "https://git-codecommit.us-east-1.amazonaws.com/v1/repos/udemy-course-nodejs-complete"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "body-parser": "^1.18.3",
    "express": "^4.16.3",
    "express-validator": "^5.3.0",
    "jsonwebtoken": "^8.3.0",
    "mongoose": "^5.3.2",
    "multer": "^1.4.0"
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "^6.1.4",
    "nodemon": "^1.18.4",
    "sinon": "^7.3.2"
  }
}

```

```js
//./test/auth-controller.js

const expect = require('chai').expect;
const sinon = require('sinon');
const mongoose = require('mongoose');

const User = require('../models/user');
const AuthController = require('../controllers/auth');

describe('Auth Controller', function() {
    before(function(done){
        mongoose
        .connect(
            /**don't use the production database
             * so 'test-messages' not the 'messages'
             */
          'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/test-messages?retryWrites=true&w=majority'
        )
        .then(result => {
          const user = new User({
              email: 'test@test.com',
              password: 'tester',
              name: 'Test',
              posts: [],
              /**this format of string matters
               * consider to be a valid Id by MongoDB
               * so i will give this user my own Id
               * so taht i can pass the userId
               */
              _id: '5c0f66b979af55031b34728a'
              /**status doesn't have to be set
               * because there is a default defined
               * then we call save
               * and i return this
               * because this will always return a promise
               * so we can now add another '.then()' block in this function
               */
          });
          return user.save();
        })
        .then(() => {
            done();
        });
    });

    /**besides ‘before()’ and ‘after()’,
     * there also are ‘beforeEach()’ and ‘afterEach()’.
     * the differences is that
     * ‘beforeEach’ is initialization work
     * that it runs before every test case.
     *
     * before runs before all test case.
     * it’s not repetitive.
     * it only runs once per test.
     * so it’s useful if you need to reset something
     * before every test case
     * or if you wanna have some initialization work
     * that has to run before every test case
     * and there are all those 'afterEach()’ in case,
     * there is some functionality
     * which need to run after every test case.
     * so cleanup work which needs to be done after every test case.
     * */
    beforeEach(function(){});

    afterEach(function(){});

  it('should throw an error with code 500 if accessing the database fails', function(done) {
    sinon.stub(User, 'findOne');
    User.findOne.throws();
    const req = {
      body: {
        email: 'test@test.com',
        password: 'tester'
      }
    };

    AuthController.login(req, {}, () => {}).then(result => {
      expect(result).to.be.an('error');
      expect(result).to.have.property('statusCode', 500);
      done();
    });

    User.findOne.restore();
  });

  it('should send a response with a valid user status for an existing user', function(done){
        const req = { userId: '5c0f66b979af55031b34728a' }
        const res = {
            statusCode: 500,
            userStatus: null,
            status: function(code){
                this.statusCode = code;
                /**so that this status returns this response object again */
                return this;
            },
            json: function(data){
                this.userStatus = data.status;
            }
        };
        AuthController.getUserStatus(req, res, () => {}).then(() => {
            expect(res.statusCode).to.be.equal(200);
            /**'i am new!' is from ./models/user.js file */
            expect(res.userStatus).to.be.equal('I am new!');
            /**i wanna call 'User.deleteMany()'
             * and apss on an empty object
             * which means all users are deleted
             * and that is not the worst idea
             * if you have a test for use setup dummy data
             * clean up everything after that test
             * so that you can be sure
             * that you have a clean setup for the next test
             * and also for the next test run
             * which is the issue here for our second test run
             */
            /**clearing our users and disconnecting is not something i wanna do here
             * i just wanna extra expectations and call 'done()'
              */
            done();
        });
    });
    /**'after()' will run after all your test cases.
     * you execute your synchronous or async code
     * if it's async,
     * you must not forget to call done once you are done.
     */
    after(function(done){
        User.deleteMany({}).then(() => {
            return mongoose.disconnect();
        })
        .then(() => {
            done();
        })
    })
});
```

\* Chapter 473: Testing Code That Requires Authentication
=========================================================

1\. update

- ./test/feed-controller.js

- ./controllers/feed.js

![](images/473-testing-code-that-require-authentication-1.png)![473-testing-code-that-require-authentication-1.png](resources/3CB1F8E64D8E7CF2522C1F32BD150BD1.png)

- how can we make this work if we only wanna test the controller and not the full flow? it’s important that you configure your tests you pass in a request response object and the next function. 

![](images/473-testing-code-that-require-authentication-2.png)

![](images/473-testing-code-that-require-authentication-3.png)![473-testing-code-that-require-authentication-2.png](resources/D964B98D0A5A9CED895E513D149907DA.png)![473-testing-code-that-require-authentication-3.png](resources/EDB146295CC7BF1C745A32D2865836D9.png)

- and if you have code that tries to get something out of the request object like the userId in ‘creator'. in the real app that is set by the middleware and we are testing this middleware but for the controller, we can just fake that and we can pass on a request object that has a userId and we are done. let’s now write a test for ‘createPost’ in ./controllers/feed.js file

![](images/473-testing-code-that-require-authentication-4.png)

![](images/473-testing-code-that-require-authentication-5.png)![473-testing-code-that-require-authentication-4.png](resources/FBC3771E7C1F40ED394C9394BE05DEB6.png)![473-testing-code-that-require-authentication-5.png](resources/476AED7248BDF2AC241B30ECF7827210.png)

---------------------------

![](images/473-testing-code-that-require-authentication-6.png)

![](images/473-testing-code-that-require-authentication-7.png)![473-testing-code-that-require-authentication-6.png](resources/2D1466F8802375BA9B8180951E423553.png)![473-testing-code-that-require-authentication-7.png](resources/6114A75FC4443541B8752BFB9825403A.png)

- but if we change from ‘length(1)’ to ‘length(0)’, then fail. if we scroll up, we see that it failed it expected array with a length(1) but we did length(0) but got length(1).

```js
//./test/feed-controller.js

const expect = require('chai').expect;
const sinon = require('sinon');
const mongoose = require('mongoose');

const User = require('../models/user');
const FeedController = require('../controllers/feed');

describe('Feed Controller', function() {
  before(function(done) {
    mongoose
      .connect(
        'mongodb+srv://maximilian:rldnjs12@cluster0-z3vlk.mongodb.net/test-messages?retryWrites=true&w=majority'
      )
      .then(result => {
        const user = new User({
          email: 'test@test.com',
          password: 'tester',
          name: 'Test',
          posts: [],
          _id: '5c0f66b979af55031b34728a'
        });
        return user.save();
      })
      .then(() => {
        done();
      });
  });

  beforeEach(function() {});

  afterEach(function() {});

  it('should add a created post to the posts of the creator', function(done) {
      /**we need these fields
       * because we are using them in the ./controllers/feed.js file
       */
    const req = {
      body: {
        title: 'Test Post',
        content: 'A Test Post'
      },
      file: {
        path: 'abc'
      },
    /**userId matter because the creator we assign here doesn't matter
     * but to really work later 
     * or to be connected to the user object the database,
     * we need a real userId
     */
      userId: '5c0f66b979af55031b34728a'
    };
    const res = {
      status: function() {
    /**the tiny problem is that
     * we are calling '.json()' method, not on the response object
     * buth on the result of the status method call
     * so for that to work,
     * back in ./test/feed-controller.js file,
     * we need to make sure that
     * in this status function,
     * we call first to return 'this'
     * so that we return to other reference at the entire object
     * which hen has this json function below
     */
        return this;
      },
      json: function() {}
    };
    /**for the response object,
     * we need to make sure
     * that we don't get an error.
     * so we need to provide a status method and adjacent method
     * even if we don't care about what they do but we need them
     * so i pass in a dummy response object you are queue
     * which is an object which needs these 2 methods
     * so they can be called without throwing error.
     * why are they not doing anything?
     * because for this test, i don't care
     * 
     * in ./controllers/feed.js,
     * 'creatPost' has async keyword
     * and therefore it returns a promise automatically
     * and hence into '.then' block.
     */
    FeedController.createPost(req, res, () => {}).then(savedUser => {
      expect(savedUser).to.have.property('posts');
      /**'length(1)' is because there should be one new post added to it.
       */
      expect(savedUser.posts).to.have.length(1);
      done();
    });
  });

  after(function(done) {
    User.deleteMany({})
      .then(() => {
        return mongoose.disconnect();
      })
      .then(() => {
        done();
      });
  });
});


```

```js
//./controllers/feed.js

const fs = require('fs');
const path = require('path');

const { validationResult } = require('express-validator/check');

const Post = require('../models/post');
const User = require('../models/user');

exports.getPosts = async (req, res, next) => {
  const currentPage = req.query.page || 1;
  const perPage = 2;
  try {
    const totalItems = await Post.find().countDocuments();
    const posts = await Post.find()
      .skip((currentPage - 1) * perPage)
      .limit(perPage);

    res.status(200).json({
      message: 'Fetched posts successfully.',
      posts: posts,
      totalItems: totalItems
    });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.createPost = async (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  if (!req.file) {
    const error = new Error('No image provided.');
    error.statusCode = 422;
    throw error;
  }
  const imageUrl = req.file.path;
  const title = req.body.title;
  const content = req.body.content;
  const post = new Post({
    title: title,
    content: content,
    imageUrl: imageUrl,
    creator: req.userId
  });
  try {
    await post.save();
    /**userId matter because the creator we assign here doesn't matter
     * but to really work later 
     * or to be connected to the user object the database,
     * we need a real userId
     */
    const user = await User.findById(req.userId);
    user.posts.push(post);
    const savedUser = await user.save();
    /**the tiny problem is that
     * we are calling '.json()' method, not on the response object
     * buth on the result of the status method call
     */
    res.status(201).json({
      message: 'Post created successfully!',
      post: post,
      creator: { _id: user._id, name: user.name }
    });
    return savedUser;
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.getPost = async (req, res, next) => {
  const postId = req.params.postId;
  const post = await Post.findById(postId);
  try {
    if (!post) {
      const error = new Error('Could not find post.');
      error.statusCode = 404;
      throw error;
    }
    res.status(200).json({ message: 'Post fetched.', post: post });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.updatePost = async (req, res, next) => {
  const postId = req.params.postId;
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    const error = new Error('Validation failed, entered data is incorrect.');
    error.statusCode = 422;
    throw error;
  }
  const title = req.body.title;
  const content = req.body.content;
  let imageUrl = req.body.image;
  if (req.file) {
    imageUrl = req.file.path;
  }
  if (!imageUrl) {
    const error = new Error('No file picked.');
    error.statusCode = 422;
    throw error;
  }
  try {
    const post = await Post.findById(postId);
    if (!post) {
      const error = new Error('Could not find post.');
      error.statusCode = 404;
      throw error;
    }
    if (post.creator.toString() !== req.userId) {
      const error = new Error('Not authorized!');
      error.statusCode = 403;
      throw error;
    }
    if (imageUrl !== post.imageUrl) {
      clearImage(post.imageUrl);
    }
    post.title = title;
    post.imageUrl = imageUrl;
    post.content = content;
    const result = await post.save();
    res.status(200).json({ message: 'Post updated!', post: result });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

exports.deletePost = async (req, res, next) => {
  const postId = req.params.postId;
  try {
    const post = await Post.findById(postId);

    if (!post) {
      const error = new Error('Could not find post.');
      error.statusCode = 404;
      throw error;
    }
    if (post.creator.toString() !== req.userId) {
      const error = new Error('Not authorized!');
      error.statusCode = 403;
      throw error;
    }
    // Check logged in user
    clearImage(post.imageUrl);
    await Post.findByIdAndRemove(postId);

    const user = await User.findById(req.userId);
    user.posts.pull(postId);
    await user.save();

    res.status(200).json({ message: 'Deleted post.' });
  } catch (err) {
    if (!err.statusCode) {
      err.statusCode = 500;
    }
    next(err);
  }
};

const clearImage = filePath => {
  filePath = path.join(__dirname, '..', filePath);
  fs.unlink(filePath, err => console.log(err));
};

```

\* Chapter 474: Wrap Up & Mastering Tests
=========================================

- always ask yourself are you testing something that you are responsible for with your code regarding the status code. we don’t need to test whether the status code is set on the response but if that exact status code you are looking for is correct that is something you test. is it status code 201 or 500

- if you have problem testing large functions, try splitting them in smaller more testable functions.